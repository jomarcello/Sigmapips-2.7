From 4016fa2c706d0d3f2fb94a7c88c53622d5b0d68a Mon Sep 17 00:00:00 2001
From: Jovanni Tilborg <jovannitilborg@example.com>
Date: Thu, 15 May 2025 07:51:10 +0700
Subject: [PATCH] Update trading_bot/main.py

---
 trading_bot/main.py | 20877 +++++-------------------------------------
 1 file changed, 2509 insertions(+), 18368 deletions(-)

diff --git a/trading_bot/main.py b/trading_bot/main.py
index 35e984b..a2a6c42 100644
--- a/trading_bot/main.py
+++ b/trading_bot/main.py
@@ -6,7 +6,115 @@ import logging
 import logging.config
 from datetime import datetime
 
+# Setup detailed logging configuration
+def setup_logging(log_level=None):
+    """Configure structured logging for the application"""
+    log_level = log_level or os.environ.get("LOG_LEVEL", "INFO").upper()
+    
+    # Create logs directory if it doesn't exist
+    os.makedirs("logs", exist_ok=True)
+    
+    # Generate a log filename with timestamp
+    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
+    log_file = f"logs/trading_bot_{timestamp}.log"
+    
+    # Define logging configuration
+    logging_config = {
+        "version": 1,
+        "disable_existing_loggers": False,
+        "formatters": {
+            "standard": {
+                "format": "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
+            },
+            "detailed": {
+                "format": "%(asctime)s - %(name)s - %(levelname)s - [%(filename)s:%(lineno)d] - %(message)s"
+            },
+        },
+        "handlers": {
+            "console": {
+                "class": "logging.StreamHandler",
+                "level": log_level,
+                "formatter": "standard",
+                "stream": "ext://sys.stdout"
+            },
+            "file": {
+                "class": "logging.FileHandler",
+                "level": "DEBUG",
+                "formatter": "detailed",
+                "filename": log_file,
+                "encoding": "utf8"
+            }
+        },
+        "loggers": {
+            "": {  # Root logger
+                "handlers": ["console", "file"],
+                "level": "DEBUG",
+                "propagate": True
+            },
+            "trading_bot": {
+                "handlers": ["console", "file"],
+                "level": "DEBUG",
+                "propagate": False
+            },
+            "trading_bot.services": {
+                "handlers": ["console", "file"],
+                "level": "DEBUG",
+                "propagate": False
+            }
+        }
+    }
+    
+    # Apply the configuration
+    logging.config.dictConfig(logging_config)
+    
+    # Log startup information
+    logger = logging.getLogger(__name__)
+    logger.info(f"Logging configured with level {log_level}, writing to {log_file}")
+    logger.info(f"Python version: {sys.version}")
+    logger.info(f"Running on platform: {sys.platform}")
+    
+    # Log environment variables (excluding sensitive information)
+    safe_env = {}
+    for key, value in os.environ.items():
+        if any(sensitive in key.lower() for sensitive in ['key', 'token', 'secret', 'password', 'pwd']):
+            safe_env[key] = f"{value[:3]}...{value[-3:]}" if len(value) > 6 else "[REDACTED]"
+        else:
+            safe_env[key] = value
+    
+    logger.debug(f"Environment variables: {json.dumps(safe_env, indent=2)}")
+    
+    return logger
 
+# Initialize logging early in the application startup
+logger = setup_logging()
+
+import os
+import json
+import asyncio
+import traceback
+from typing import Dict, Any, List, Optional, Union, Set
+from datetime import datetime, timedelta
+import logging
+import copy
+import re
+import time
+import random
+
+from fastapi import FastAPI, Request, HTTPException, status
+from telegram import Bot, Update, BotCommand, InlineKeyboardButton, InlineKeyboardMarkup, CallbackQuery, InputMediaPhoto, InputMediaAnimation, InputMediaDocument, ReplyKeyboardMarkup, ReplyKeyboardRemove, InputFile
+from telegram.constants import ParseMode
+from telegram.request import HTTPXRequest
+from telegram.ext import (
+    Application,
+    CommandHandler,
+    CallbackQueryHandler,
+    ConversationHandler,
+    ContextTypes,
+    CallbackContext,
+    MessageHandler,
+    filters,
+    PicklePersistence
+)
 from telegram.error import TelegramError, BadRequest
 import httpx
 import telegram.error  # Add this import for BadRequest error handling
@@ -114,38 +222,38 @@ SUBSCRIBE = 10
 BACK_TO_MENU = 11  # Add this line
 
 # Messages
-WELCOME_MESSAGE = r"""
-<b>Sigmapips AI - Main Menu</b>
+WELCOME_MESSAGE = """
+üöÄ <b>Sigmapips AI - Main Menu</b> üöÄ
 
 Choose an option to access advanced trading support:
 
-Services:
-- <b>Technical Analysis</b> - Real-time chart analysis and key levels
+üìä Services:
+‚Ä¢ <b>Technical Analysis</b> ‚Äì Real-time chart analysis and key levels
 
-- <b>Market Sentiment</b> - Understand market trends and sentiment
+‚Ä¢ <b>Market Sentiment</b> ‚Äì Understand market trends and sentiment
 
-- <b>Economic Calendar</b> - Stay updated on market-moving events
+‚Ä¢ <b>Economic Calendar</b> ‚Äì Stay updated on market-moving events
 
-- <b>Trading Signals</b> - Get precise entry/exit points for your favorite pairs
+‚Ä¢ <b>Trading Signals</b> ‚Äì Get precise entry/exit points for your favorite pairs
 
 Select your option to continue:
 """
 
 # Abonnementsbericht voor nieuwe gebruikers
-SUBSCRIPTION_WELCOME_MESSAGE = r"""
-<b>Welcome to Sigmapips AI!</b>
+SUBSCRIPTION_WELCOME_MESSAGE = """
+üöÄ <b>Welcome to Sigmapips AI!</b> üöÄ
 
 To access all features, you need a subscription:
 
-<b>Trading Signals Subscription - $29.99/month</b>
-- Access to all trading signals (Forex, Crypto, Commodities, Indices)
-- Advanced timeframe analysis
-- Detailed chart analysis for each signal
+üìä <b>Trading Signals Subscription - $29.99/month</b>
+‚Ä¢ Access to all trading signals (Forex, Crypto, Commodities, Indices)
+‚Ä¢ Advanced timeframe analysis (1m, 15m, 1h, 4h)
+‚Ä¢ Detailed chart analysis for each signal
 
 Click the button below to subscribe:
 """
 
-MENU_MESSAGE = r"""
+MENU_MESSAGE = """
 Welcome to Sigmapips AI!
 
 Choose a command:
@@ -159,7 +267,7 @@ View, edit or delete your saved trading pairs
 Need help? Use /help to see all available commands.
 """
 
-HELP_MESSAGE = r"""
+HELP_MESSAGE = """
 Available commands:
 /menu - Show main menu
 /start - Set up new trading pairs
@@ -168,23 +276,23 @@ Available commands:
 
 # Start menu keyboard
 START_KEYBOARD = [
-    [InlineKeyboardButton("Analyze Market", callback_data=CALLBACK_MENU_ANALYSE)],
-    [InlineKeyboardButton("Trading Signals", callback_data=CALLBACK_MENU_SIGNALS)]
+    [InlineKeyboardButton("üîç Analyze Market", callback_data=CALLBACK_MENU_ANALYSE)],
+    [InlineKeyboardButton("üìä Trading Signals", callback_data=CALLBACK_MENU_SIGNALS)]
 ]
 
 # Analysis menu keyboard
 ANALYSIS_KEYBOARD = [
-    [InlineKeyboardButton("Technical Analysis", callback_data=CALLBACK_ANALYSIS_TECHNICAL)],
-    [InlineKeyboardButton("Market Sentiment", callback_data=CALLBACK_ANALYSIS_SENTIMENT)],
-    [InlineKeyboardButton("Economic Calendar", callback_data=CALLBACK_ANALYSIS_CALENDAR)],
-    [InlineKeyboardButton("Back", callback_data=CALLBACK_BACK_MENU)]
+    [InlineKeyboardButton("üìà Technical Analysis", callback_data=CALLBACK_ANALYSIS_TECHNICAL)],
+    [InlineKeyboardButton("üß† Market Sentiment", callback_data=CALLBACK_ANALYSIS_SENTIMENT)],
+    [InlineKeyboardButton("üìÖ Economic Calendar", callback_data=CALLBACK_ANALYSIS_CALENDAR)],
+    [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data=CALLBACK_BACK_MENU)]
 ]
 
 # Signals menu keyboard
 SIGNALS_KEYBOARD = [
-    [InlineKeyboardButton("Add New Pairs", callback_data=CALLBACK_SIGNALS_ADD)],
-    [InlineKeyboardButton("Manage Signals", callback_data=CALLBACK_SIGNALS_MANAGE)],
-    [InlineKeyboardButton("Back", callback_data=CALLBACK_BACK_MENU)]
+    [InlineKeyboardButton("‚ûï Add New Pairs", callback_data=CALLBACK_SIGNALS_ADD)],
+    [InlineKeyboardButton("‚öôÔ∏è Manage Signals", callback_data=CALLBACK_SIGNALS_MANAGE)],
+    [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data=CALLBACK_BACK_MENU)]
 ]
 
 # Market keyboard voor signals
@@ -193,7 +301,7 @@ MARKET_KEYBOARD_SIGNALS = [
     [InlineKeyboardButton("Crypto", callback_data="market_crypto_signals")],
     [InlineKeyboardButton("Commodities", callback_data="market_commodities_signals")],
     [InlineKeyboardButton("Indices", callback_data="market_indices_signals")],
-    [InlineKeyboardButton("Back", callback_data="back_signals")]
+    [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="back_signals")]
 ]
 
 # Market keyboard voor analyse
@@ -202,7 +310,7 @@ MARKET_KEYBOARD = [
     [InlineKeyboardButton("Crypto", callback_data="market_crypto")],
     [InlineKeyboardButton("Commodities", callback_data="market_commodities")],
     [InlineKeyboardButton("Indices", callback_data="market_indices")],
-    [InlineKeyboardButton("Back", callback_data="back_analysis")]
+    [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="back_analysis")]
 ]
 
 # Market keyboard specifiek voor sentiment analyse
@@ -211,7 +319,7 @@ MARKET_SENTIMENT_KEYBOARD = [
     [InlineKeyboardButton("Crypto", callback_data="market_crypto_sentiment")],
     [InlineKeyboardButton("Commodities", callback_data="market_commodities_sentiment")],
     [InlineKeyboardButton("Indices", callback_data="market_indices_sentiment")],
-    [InlineKeyboardButton("Back", callback_data="back_analysis")]
+    [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="back_analysis")]
 ]
 
 # Forex keyboard voor technical analyse
@@ -226,7 +334,7 @@ FOREX_KEYBOARD = [
         InlineKeyboardButton("USDCAD", callback_data="instrument_USDCAD_chart"),
         InlineKeyboardButton("EURGBP", callback_data="instrument_EURGBP_chart")
     ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
+    [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="back_market")]
 ]
 
 # Forex keyboard voor sentiment analyse
@@ -241,7 +349,7 @@ FOREX_SENTIMENT_KEYBOARD = [
         InlineKeyboardButton("USDCAD", callback_data="instrument_USDCAD_sentiment"),
         InlineKeyboardButton("EURGBP", callback_data="instrument_EURGBP_sentiment")
     ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
+    [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="back_market")]
 ]
 
 # Forex keyboard voor kalender analyse
@@ -256,7 +364,7 @@ FOREX_CALENDAR_KEYBOARD = [
         InlineKeyboardButton("USDCAD", callback_data="instrument_USDCAD_calendar"),
         InlineKeyboardButton("EURGBP", callback_data="instrument_EURGBP_calendar")
     ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
+    [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="back_market")]
 ]
 
 # Crypto keyboard voor analyse
@@ -266,15 +374,15 @@ CRYPTO_KEYBOARD = [
         InlineKeyboardButton("ETHUSD", callback_data="instrument_ETHUSD_chart"),
         InlineKeyboardButton("XRPUSD", callback_data="instrument_XRPUSD_chart")
     ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
+    [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="back_market")]
 ]
 
 # Signal analysis keyboard
 SIGNAL_ANALYSIS_KEYBOARD = [
-    [InlineKeyboardButton("Technical Analysis", callback_data="signal_technical")],
-    [InlineKeyboardButton("Market Sentiment", callback_data="signal_sentiment")],
-    [InlineKeyboardButton("Economic Calendar", callback_data="signal_calendar")],
-    [InlineKeyboardButton("Back", callback_data="back_to_signal")]
+    [InlineKeyboardButton("üìà Technical Analysis", callback_data="signal_technical")],
+    [InlineKeyboardButton("üß† Market Sentiment", callback_data="signal_sentiment")],
+    [InlineKeyboardButton("üìÖ Economic Calendar", callback_data="signal_calendar")],
+    [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="back_to_signal")]
 ]
 
 # Crypto keyboard voor sentiment analyse
@@ -284,7 +392,7 @@ CRYPTO_SENTIMENT_KEYBOARD = [
         InlineKeyboardButton("ETHUSD", callback_data="instrument_ETHUSD_sentiment"),
         InlineKeyboardButton("XRPUSD", callback_data="instrument_XRPUSD_sentiment")
     ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
+    [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="back_market")]
 ]
 
 # Indices keyboard voor analyse
@@ -294,7 +402,7 @@ INDICES_KEYBOARD = [
         InlineKeyboardButton("US500", callback_data="instrument_US500_chart"),
         InlineKeyboardButton("US100", callback_data="instrument_US100_chart")
     ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
+    [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="back_market")]
 ]
 
 # Indices keyboard voor signals - Fix de "Terug" knop naar "Back"
@@ -304,7 +412,7 @@ INDICES_KEYBOARD_SIGNALS = [
         InlineKeyboardButton("US500", callback_data="instrument_US500_signals"),
         InlineKeyboardButton("US100", callback_data="instrument_US100_signals")
     ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
+    [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="back_market")]
 ]
 
 # Commodities keyboard voor analyse
@@ -314,7 +422,7 @@ COMMODITIES_KEYBOARD = [
         InlineKeyboardButton("SILVER", callback_data="instrument_XAGUSD_chart"),
         InlineKeyboardButton("OIL", callback_data="instrument_USOIL_chart")
     ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
+    [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="back_market")]
 ]
 
 # Commodities keyboard voor signals - Fix de "Terug" knop naar "Back"
@@ -324,7 +432,7 @@ COMMODITIES_KEYBOARD_SIGNALS = [
         InlineKeyboardButton("XAGUSD", callback_data="instrument_XAGUSD_signals"),
         InlineKeyboardButton("USOIL", callback_data="instrument_USOIL_signals")
     ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
+    [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="back_market")]
 ]
 
 # Forex keyboard for signals
@@ -338,7 +446,7 @@ FOREX_KEYBOARD_SIGNALS = [
         InlineKeyboardButton("USDCAD", callback_data="instrument_USDCAD_signals"),
         InlineKeyboardButton("EURGBP", callback_data="instrument_EURGBP_signals")
     ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
+    [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="back_market")]
 ]
 
 # Crypto keyboard for signals
@@ -348,7 +456,7 @@ CRYPTO_KEYBOARD_SIGNALS = [
         InlineKeyboardButton("ETHUSD", callback_data="instrument_ETHUSD_signals"),
         InlineKeyboardButton("XRPUSD", callback_data="instrument_XRPUSD_signals")
     ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
+    [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="back_market")]
 ]
 
 # Indices keyboard voor sentiment analyse
@@ -358,7 +466,7 @@ INDICES_SENTIMENT_KEYBOARD = [
         InlineKeyboardButton("US500", callback_data="instrument_US500_sentiment"),
         InlineKeyboardButton("US100", callback_data="instrument_US100_sentiment")
     ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
+    [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="back_market")]
 ]
 
 # Commodities keyboard voor sentiment analyse
@@ -368,24 +476,24 @@ COMMODITIES_SENTIMENT_KEYBOARD = [
         InlineKeyboardButton("SILVER", callback_data="instrument_XAGUSD_sentiment"),
         InlineKeyboardButton("OIL", callback_data="instrument_USOIL_sentiment")
     ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
+    [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="back_market")]
 ]
 
 # Style keyboard
 STYLE_KEYBOARD = [
-    [InlineKeyboardButton("‚ö° Test (one_min)", callback_data="style_test")],
-    [InlineKeyboardButton("üèÉ Scalp (fifteen_min)", callback_data="style_scalp")],
-    [InlineKeyboardButton(" Intraday (one_hour)", callback_data="style_intraday")],
-    [InlineKeyboardButton("üåä Swing (four_hour)", callback_data="style_swing")],
-    [InlineKeyboardButton("Back", callback_data="back_instrument")]
+    [InlineKeyboardButton("‚ö° Test (1m)", callback_data="style_test")],
+    [InlineKeyboardButton("üèÉ Scalp (15m)", callback_data="style_scalp")],
+    [InlineKeyboardButton("üìä Intraday (1h)", callback_data="style_intraday")],
+    [InlineKeyboardButton("üåä Swing (4h)", callback_data="style_swing")],
+    [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="back_instrument")]
 ]
 
 # Timeframe mapping
 STYLE_TIMEFRAME_MAP = {
-    "test": "one_min",
-    "scalp": "fifteen_min",
-    "intraday": "one_hour",
-    "swing": "four_hour"
+    "test": "1m",
+    "scalp": "15m",
+    "intraday": "1h",
+    "swing": "4h"
 }
 
 # Mapping of instruments to their allowed timeframes - updated 2023-03-23
@@ -507,7 +615,7 @@ def require_subscription(func):
             if payment_failed:
                 # Show payment failure message
                 failed_payment_text = f"""
- <b>Subscription Payment Failed</b> 
+‚ùó <b>Subscription Payment Failed</b> ‚ùó
 
 Your subscription payment could not be processed and your service has been deactivated.
 
@@ -524,24 +632,24 @@ To continue using Sigmapips AI and receive trading signals, please reactivate yo
             else:
                 # Show subscription screen with the welcome message from the screenshot
                 failed_payment_text = f"""
- <b>Welcome to Sigmapips AI!</b> 
+üöÄ <b>Welcome to Sigmapips AI!</b> üöÄ
 
 <b>Discover powerful trading signals for various markets:</b>
-- <b>Forex</b> - Major and minor currency pairs
-- <b>Crypto</b> - Bitcoin, Ethereum and other top cryptocurrencies
-- <b>Indices</b> - Global market indices
-- <b>Commodities</b> - Gold, silver and oil
+‚Ä¢ <b>Forex</b> - Major and minor currency pairs
+‚Ä¢ <b>Crypto</b> - Bitcoin, Ethereum and other top cryptocurrencies
+‚Ä¢ <b>Indices</b> - Global market indices
+‚Ä¢ <b>Commodities</b> - Gold, silver and oil
 
 <b>Features:</b>
- Real-time trading signals
+‚úÖ Real-time trading signals
 
- Multi-timeframe analysis (timeframes)
+‚úÖ Multi-timeframe analysis (1m, 15m, 1h, 4h)
 
- Advanced chart analysis
+‚úÖ Advanced chart analysis
 
- Sentiment indicators
+‚úÖ Sentiment indicators
 
- Economic calendar integration
+‚úÖ Economic calendar integration
 
 <b>Start today with a FREE 14-day trial!</b>
                 """
@@ -610,7 +718,7 @@ class TelegramService:
         self.signals_dir = "data/signals"
         self.signals_enabled_val = True
         self.polling_started = False
-        self.admin_users = [2004519703]  # Updated with correct Telegram ID from logs
+        self.admin_users = [1093307376]  # Add your Telegram ID here for testing
         self._signals_enabled = True  # Enable signals by default
         
         # Setup logger
@@ -667,7 +775,7 @@ class TelegramService:
         self.sentiment_cache_ttl = 60 * 60  # 1 hour in seconds
         
         # Start the bot
-    try:
+        try:
             # Check for bot token
             if not self.bot_token:
                 raise ValueError("Missing Telegram bot token")
@@ -689,9 +797,9 @@ class TelegramService:
             # Keep track of processed updates
             self.processed_updates = set()
             
-    except Exception as e:
-        logger.error(f"Error initializing Telegram service: {str(e)}")
-        raise
+        except Exception as e:
+            logger.error(f"Error initializing Telegram service: {str(e)}")
+            raise
 
     async def initialize_services(self):
         """Initialize services that require an asyncio event loop"""
@@ -703,16059 +811,87 @@ class TelegramService:
             # Load stored signals
             await self._load_signals()
             logger.info("Signals loaded")
-            
-            # Schedule periodic cleanup of old signals
-            if hasattr(self, 'db') and self.db and self.db.using_redis:
-                # Run initial cleanup
-                cleaned = await self._cleanup_old_signals(max_age_days=7)
-                logger.info(f"Initial signal cleanup completed, removed {cleaned} old signals")
-                
-                # Schedule periodic cleanup (every 24 hours)
-                async def periodic_cleanup():
-                    while True:
-                        try:
-                            # Wait for 24 hours
-                            await asyncio.sleep(24 * 60 * 60)
-                            # Run cleanup
-                            cleaned = await self._cleanup_old_signals(max_age_days=7)
-                            logger.info(f"Periodic signal cleanup completed, removed {cleaned} old signals")
-                        except Exception as e:
-                            logger.error(f"Error in periodic signal cleanup: {str(e)}")
-                
-                # Start the periodic cleanup task
-                asyncio.create_task(periodic_cleanup())
-                logger.info("Scheduled periodic signal cleanup")
         except Exception as e:
             logger.error(f"Error initializing services: {str(e)}")
             raise
-
-# Calendar service helpers
+            
+    # Calendar service helpers
     @property
-    def signals_enabled(self):
-        """Get whether signals processing is enabled"""
-        return self._signals_enabled
-    
-    @signals_enabled.setter
-    def signals_enabled(self, value):
-        """Set whether signals processing is enabled"""
-        self._signals_enabled = bool(value)
-        logger.info(f"Signal processing is now {'enabled' if value else 'disabled'}")
-
-    async def start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE = None) -> None:
-        """Handle the /start command"""
-        user = update.effective_user
-        logger.info(f"User {user.id} ({user.username}) started the bot")
+    def calendar_service(self):
+        """Lazy loaded calendar service"""
+        if self._calendar_service is None:
+            # Only initialize the calendar service when it's first accessed
+            self.logger.info("Lazy loading calendar service")
+            self._calendar_service = EconomicCalendarService()
+        return self._calendar_service
         
-        # Check if user is subscribed
-        is_subscribed = await self.db.is_user_subscribed(user.id)
+    def _get_calendar_service(self):
+        """Get the calendar service instance"""
+        self.logger.info("Getting calendar service")
+        return self.calendar_service
+
+    async def _format_calendar_events(self, calendar_data):
+        """Format the calendar data into a readable HTML message"""
+        self.logger.info(f"Formatting calendar data with {len(calendar_data)} events")
+        if not calendar_data:
+            return "<b>üìÖ Economic Calendar</b>\n\nNo economic events found for today."
         
-        # Create welcome message
-        welcome_text = (
-            f"üëã Welcome to SigmaPips Trading Bot, {user.first_name}!\n\n"
-            "I'm your AI-powered trading assistant. Here's what I can do for you:\n\n"
-            " <b>Market Analysis</b> - Technical and sentiment analysis for major markets\n"
-            " <b>Signal Management</b> - Receive and manage trading signals\n"
-            " <b>Economic Calendar</b> - Stay updated with important economic events\n\n"
-        )
+        # Sort events by time
+        try:
+            # Try to parse time for sorting
+            def parse_time_for_sorting(event):
+                time_str = event.get('time', '')
+                try:
+                    # Extract hour and minute if in format like "08:30 EST"
+                    if ':' in time_str:
+                        parts = time_str.split(' ')[0].split(':')
+                        hour = int(parts[0])
+                        minute = int(parts[1])
+                        return hour * 60 + minute
+                    return 0
+                except:
+                    return 0
+            
+            # Sort the events by time
+            sorted_events = sorted(calendar_data, key=parse_time_for_sorting)
+        except Exception as e:
+            self.logger.error(f"Error sorting calendar events: {str(e)}")
+            sorted_events = calendar_data
         
-        # Add subscription status
-        if is_subscribed:
-            welcome_text += " <b>Subscription Status:</b> Active\n\n"
-        else:
-            welcome_text += " <b>Subscription Status:</b> Inactive\n\n"
+        # Format the message
+        message = "<b>üìÖ Economic Calendar</b>\n\n"
         
-        welcome_text += "Use the /menu command to access all features."
+        # Get current date
+        current_date = datetime.now().strftime("%B %d, %Y")
+        message += f"<b>Date:</b> {current_date}\n\n"
         
-        # Create keyboard for main menu
-        keyboard = [
-            [InlineKeyboardButton(" Analyze Markets", callback_data="menu_analyse")],
-            [InlineKeyboardButton(" Signal Management", callback_data="menu_signals")],
-            [InlineKeyboardButton("‚ùì Help", callback_data="menu_help")]
-        ]
-        reply_markup = InlineKeyboardMarkup(keyboard)
+        # Add impact legend
+        message += "<b>Impact:</b> üî¥ High   üü† Medium   üü¢ Low\n\n"
         
-        # Send welcome message with keyboard
-        await update.message.reply_html(
-            welcome_text,
-            reply_markup=reply_markup
-        )
+        # Group events by country
+        events_by_country = {}
+        for event in sorted_events:
+            country = event.get('country', 'Unknown')
+            if country not in events_by_country:
+                events_by_country[country] = []
+            events_by_country[country].append(event)
         
-        # Log the user interaction
-        logger.info(f"Sent welcome message to user {user.id}")
+        # Format events by country
+        for country, events in events_by_country.items():
+            country_flag = CURRENCY_FLAG.get(country, '')
+            message += f"<b>{country_flag} {country}</b>\n"
+            
+            for event in events:
+                time = event.get('time', 'TBA')
+                title = event.get('title', 'Unknown Event')
+                impact = event.get('impact', 'Low')
+                impact_emoji = {'High': 'üî¥', 'Medium': 'üü†', 'Low': 'üü¢'}.get(impact, 'üü¢')
+                
+                message += f"{time} - {impact_emoji} {title}\n"
+            
+            message += "\n"  # Add extra newline between countries
         
-        # Store user data if needed
-        if context:
-            context.user_data['is_signals_context'] = False
-            context.user_data['from_signal'] = False
-            context.user_data['in_signal_flow'] = False
-        
-        return MAIN_MENU
-
-# Initialize logging early in the application startup
-logger = setup_logging()
-
-import os
-import json
-import asyncio
-import traceback
-from typing import Dict, Any, List, Optional, Union, Set
-from datetime import datetime, timedelta
-import logging
-import copy
-import re
-import time
-import random
-
-from fastapi import FastAPI, Request, HTTPException, status
-from telegram import Bot, Update, BotCommand, InlineKeyboardButton, InlineKeyboardMarkup, CallbackQuery, InputMediaPhoto, InputMediaAnimation, InputMediaDocument, ReplyKeyboardMarkup, ReplyKeyboardRemove, InputFile
-from telegram.constants import ParseMode
-from telegram.request import HTTPXRequest
-from telegram.ext import (
-    Application,
-    CommandHandler,
-    CallbackQueryHandler,
-    ConversationHandler,
-    ContextTypes,
-    CallbackContext,
-    MessageHandler,
-    filters,
-    PicklePersistence
-)
-from telegram.error import TelegramError, BadRequest
-import httpx
-import telegram.error  # Add this import for BadRequest error handling
-
-from trading_bot.services.database.db import Database
-from trading_bot.services.chart_service.chart import ChartService
-from trading_bot.services.sentiment_service.sentiment import MarketSentimentService
-from trading_bot.services.calendar_service import EconomicCalendarService
-from trading_bot.services.payment_service.stripe_service import StripeService
-from trading_bot.services.payment_service.stripe_config import get_subscription_features
-from trading_bot.services.telegram_service.states import (
-    MENU, ANALYSIS, SIGNALS, CHOOSE_MARKET, CHOOSE_INSTRUMENT, CHOOSE_STYLE,
-    CHOOSE_ANALYSIS, SIGNAL_DETAILS,
-    CALLBACK_MENU_ANALYSE, CALLBACK_MENU_SIGNALS, CALLBACK_ANALYSIS_TECHNICAL,
-    CALLBACK_ANALYSIS_SENTIMENT, CALLBACK_ANALYSIS_CALENDAR, CALLBACK_SIGNALS_ADD,
-    CALLBACK_SIGNALS_MANAGE, CALLBACK_BACK_MENU
-)
-import trading_bot.services.telegram_service.gif_utils as gif_utils
-
-# Initialize logger
-logger = logging.getLogger(__name__)
-
-# Major currencies to focus on
-MAJOR_CURRENCIES = ["USD", "EUR", "GBP", "JPY", "CHF", "AUD", "NZD", "CAD"]
-
-# Currency to flag emoji mapping
-CURRENCY_FLAG = {
-    "USD": "üá∫üá∏",
-    "EUR": "üá™üá∫",
-    "GBP": "üá¨üáß",
-    "JPY": "üáØüáµ",
-    "CHF": "üá®üá≠",
-    "AUD": "üá¶üá∫",
-    "NZD": "üá≥üáø",
-    "CAD": "üá®üá¶"
-}
-
-# Map of instruments to their corresponding currencies
-INSTRUMENT_CURRENCY_MAP = {
-    # Special case for global view
-    "GLOBAL": MAJOR_CURRENCIES,
-    
-    # Forex
-    "EURUSD": ["EUR", "USD"],
-    "GBPUSD": ["GBP", "USD"],
-    "USDJPY": ["USD", "JPY"],
-    "USDCHF": ["USD", "CHF"],
-    "AUDUSD": ["AUD", "USD"],
-    "NZDUSD": ["NZD", "USD"],
-    "USDCAD": ["USD", "CAD"],
-    "EURGBP": ["EUR", "GBP"],
-    "EURJPY": ["EUR", "JPY"],
-    "GBPJPY": ["GBP", "JPY"],
-    
-    # Indices (mapped to their related currencies)
-    "US30": ["USD"],
-    "US100": ["USD"],
-    "US500": ["USD"],
-    "UK100": ["GBP"],
-    "GER40": ["EUR"],
-    "FRA40": ["EUR"],
-    "ESP35": ["EUR"],
-    "JP225": ["JPY"],
-    "AUS200": ["AUD"],
-    
-    # Commodities (mapped to USD primarily)
-    "XAUUSD": ["USD", "XAU"],  # Gold
-    "XAGUSD": ["USD", "XAG"],  # Silver
-    "USOIL": ["USD"],          # Oil (WTI)
-    "UKOIL": ["USD", "GBP"],   # Oil (Brent)
-    
-    # Crypto
-    "BTCUSD": ["USD", "BTC"],
-    "ETHUSD": ["USD", "ETH"],
-    "LTCUSD": ["USD", "LTC"],
-    "XRPUSD": ["USD", "XRP"]
-}
-
-# Callback data constants
-CALLBACK_ANALYSIS_TECHNICAL = "analysis_technical"
-CALLBACK_ANALYSIS_SENTIMENT = "analysis_sentiment"
-CALLBACK_ANALYSIS_CALENDAR = "analysis_calendar"
-CALLBACK_BACK_MENU = "back_menu"
-CALLBACK_BACK_ANALYSIS = "back_to_analysis"
-CALLBACK_BACK_MARKET = "back_market"
-CALLBACK_BACK_INSTRUMENT = "back_instrument"
-CALLBACK_BACK_SIGNALS = "back_signals"
-CALLBACK_SIGNALS_ADD = "signals_add"
-CALLBACK_SIGNALS_MANAGE = "signals_manage"
-CALLBACK_MENU_ANALYSE = "menu_analyse"
-CALLBACK_MENU_SIGNALS = "menu_signals"
-
-# States
-MENU = 0
-CHOOSE_ANALYSIS = 1
-CHOOSE_SIGNALS = 2
-CHOOSE_MARKET = 3
-CHOOSE_INSTRUMENT = 4
-CHOOSE_STYLE = 5
-SHOW_RESULT = 6
-CHOOSE_TIMEFRAME = 7
-SIGNAL_DETAILS = 8
-SIGNAL = 9
-SUBSCRIBE = 10
-BACK_TO_MENU = 11  # Add this line
-
-# Messages
-WELCOME_MESSAGE = r"""
-<b>Sigmapips AI - Main Menu</b>
-
-Choose an option to access advanced trading support:
-
-Services:
-- <b>Technical Analysis</b> - Real-time chart analysis and key levels
-
-- <b>Market Sentiment</b> - Understand market trends and sentiment
-
-- <b>Economic Calendar</b> - Stay updated on market-moving events
-
-- <b>Trading Signals</b> - Get precise entry/exit points for your favorite pairs
-
-Select your option to continue:
-"""
-
-# Abonnementsbericht voor nieuwe gebruikers
-SUBSCRIPTION_WELCOME_MESSAGE = r"""
-<b>Welcome to Sigmapips AI!</b>
-
-To access all features, you need a subscription:
-
-<b>Trading Signals Subscription - $29.99/month</b>
-- Access to all trading signals (Forex, Crypto, Commodities, Indices)
-- Advanced timeframe analysis
-- Detailed chart analysis for each signal
-
-Click the button below to subscribe:
-"""
-
-MENU_MESSAGE = r"""
-Welcome to Sigmapips AI!
-
-Choose a command:
-
-/start - Set up new trading pairs
-Add new market/instrument/timeframe combinations to receive signals
-
-/manage - Manage your preferences
-View, edit or delete your saved trading pairs
-
-Need help? Use /help to see all available commands.
-"""
-
-HELP_MESSAGE = r"""
-Available commands:
-/menu - Show main menu
-/start - Set up new trading pairs
-/help - Show this help message
-"""
-
-# Start menu keyboard
-START_KEYBOARD = [
-    [InlineKeyboardButton("Analyze Market", callback_data=CALLBACK_MENU_ANALYSE)],
-    [InlineKeyboardButton("Trading Signals", callback_data=CALLBACK_MENU_SIGNALS)]
-]
-
-# Analysis menu keyboard
-ANALYSIS_KEYBOARD = [
-    [InlineKeyboardButton("Technical Analysis", callback_data=CALLBACK_ANALYSIS_TECHNICAL)],
-    [InlineKeyboardButton("Market Sentiment", callback_data=CALLBACK_ANALYSIS_SENTIMENT)],
-    [InlineKeyboardButton("Economic Calendar", callback_data=CALLBACK_ANALYSIS_CALENDAR)],
-    [InlineKeyboardButton("Back", callback_data=CALLBACK_BACK_MENU)]
-]
-
-# Signals menu keyboard
-SIGNALS_KEYBOARD = [
-    [InlineKeyboardButton("Add New Pairs", callback_data=CALLBACK_SIGNALS_ADD)],
-    [InlineKeyboardButton("Manage Signals", callback_data=CALLBACK_SIGNALS_MANAGE)],
-    [InlineKeyboardButton("Back", callback_data=CALLBACK_BACK_MENU)]
-]
-
-# Market keyboard voor signals
-MARKET_KEYBOARD_SIGNALS = [
-    [InlineKeyboardButton("Forex", callback_data="market_forex_signals")],
-    [InlineKeyboardButton("Crypto", callback_data="market_crypto_signals")],
-    [InlineKeyboardButton("Commodities", callback_data="market_commodities_signals")],
-    [InlineKeyboardButton("Indices", callback_data="market_indices_signals")],
-    [InlineKeyboardButton("Back", callback_data="back_signals")]
-]
-
-# Market keyboard voor analyse
-MARKET_KEYBOARD = [
-    [InlineKeyboardButton("Forex", callback_data="market_forex")],
-    [InlineKeyboardButton("Crypto", callback_data="market_crypto")],
-    [InlineKeyboardButton("Commodities", callback_data="market_commodities")],
-    [InlineKeyboardButton("Indices", callback_data="market_indices")],
-    [InlineKeyboardButton("Back", callback_data="back_analysis")]
-]
-
-# Market keyboard specifiek voor sentiment analyse
-MARKET_SENTIMENT_KEYBOARD = [
-    [InlineKeyboardButton("Forex", callback_data="market_forex_sentiment")],
-    [InlineKeyboardButton("Crypto", callback_data="market_crypto_sentiment")],
-    [InlineKeyboardButton("Commodities", callback_data="market_commodities_sentiment")],
-    [InlineKeyboardButton("Indices", callback_data="market_indices_sentiment")],
-    [InlineKeyboardButton("Back", callback_data="back_analysis")]
-]
-
-# Forex keyboard voor technical analyse
-FOREX_KEYBOARD = [
-    [
-        InlineKeyboardButton("EURUSD", callback_data="instrument_EURUSD_chart"),
-        InlineKeyboardButton("GBPUSD", callback_data="instrument_GBPUSD_chart"),
-        InlineKeyboardButton("USDJPY", callback_data="instrument_USDJPY_chart")
-    ],
-    [
-        InlineKeyboardButton("AUDUSD", callback_data="instrument_AUDUSD_chart"),
-        InlineKeyboardButton("USDCAD", callback_data="instrument_USDCAD_chart"),
-        InlineKeyboardButton("EURGBP", callback_data="instrument_EURGBP_chart")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Forex keyboard voor sentiment analyse
-FOREX_SENTIMENT_KEYBOARD = [
-    [
-        InlineKeyboardButton("EURUSD", callback_data="instrument_EURUSD_sentiment"),
-        InlineKeyboardButton("GBPUSD", callback_data="instrument_GBPUSD_sentiment"),
-        InlineKeyboardButton("USDJPY", callback_data="instrument_USDJPY_sentiment")
-    ],
-    [
-        InlineKeyboardButton("AUDUSD", callback_data="instrument_AUDUSD_sentiment"),
-        InlineKeyboardButton("USDCAD", callback_data="instrument_USDCAD_sentiment"),
-        InlineKeyboardButton("EURGBP", callback_data="instrument_EURGBP_sentiment")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Forex keyboard voor kalender analyse
-FOREX_CALENDAR_KEYBOARD = [
-    [
-        InlineKeyboardButton("EURUSD", callback_data="instrument_EURUSD_calendar"),
-        InlineKeyboardButton("GBPUSD", callback_data="instrument_GBPUSD_calendar"),
-        InlineKeyboardButton("USDJPY", callback_data="instrument_USDJPY_calendar")
-    ],
-    [
-        InlineKeyboardButton("AUDUSD", callback_data="instrument_AUDUSD_calendar"),
-        InlineKeyboardButton("USDCAD", callback_data="instrument_USDCAD_calendar"),
-        InlineKeyboardButton("EURGBP", callback_data="instrument_EURGBP_calendar")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Crypto keyboard voor analyse
-CRYPTO_KEYBOARD = [
-    [
-        InlineKeyboardButton("BTCUSD", callback_data="instrument_BTCUSD_chart"),
-        InlineKeyboardButton("ETHUSD", callback_data="instrument_ETHUSD_chart"),
-        InlineKeyboardButton("XRPUSD", callback_data="instrument_XRPUSD_chart")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Signal analysis keyboard
-SIGNAL_ANALYSIS_KEYBOARD = [
-    [InlineKeyboardButton("Technical Analysis", callback_data="signal_technical")],
-    [InlineKeyboardButton("Market Sentiment", callback_data="signal_sentiment")],
-    [InlineKeyboardButton("Economic Calendar", callback_data="signal_calendar")],
-    [InlineKeyboardButton("Back", callback_data="back_to_signal")]
-]
-
-# Crypto keyboard voor sentiment analyse
-CRYPTO_SENTIMENT_KEYBOARD = [
-    [
-        InlineKeyboardButton("BTCUSD", callback_data="instrument_BTCUSD_sentiment"),
-        InlineKeyboardButton("ETHUSD", callback_data="instrument_ETHUSD_sentiment"),
-        InlineKeyboardButton("XRPUSD", callback_data="instrument_XRPUSD_sentiment")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Indices keyboard voor analyse
-INDICES_KEYBOARD = [
-    [
-        InlineKeyboardButton("US30", callback_data="instrument_US30_chart"),
-        InlineKeyboardButton("US500", callback_data="instrument_US500_chart"),
-        InlineKeyboardButton("US100", callback_data="instrument_US100_chart")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Indices keyboard voor signals - Fix de "Terug" knop naar "Back"
-INDICES_KEYBOARD_SIGNALS = [
-    [
-        InlineKeyboardButton("US30", callback_data="instrument_US30_signals"),
-        InlineKeyboardButton("US500", callback_data="instrument_US500_signals"),
-        InlineKeyboardButton("US100", callback_data="instrument_US100_signals")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Commodities keyboard voor analyse
-COMMODITIES_KEYBOARD = [
-    [
-        InlineKeyboardButton("GOLD", callback_data="instrument_XAUUSD_chart"),
-        InlineKeyboardButton("SILVER", callback_data="instrument_XAGUSD_chart"),
-        InlineKeyboardButton("OIL", callback_data="instrument_USOIL_chart")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Commodities keyboard voor signals - Fix de "Terug" knop naar "Back"
-COMMODITIES_KEYBOARD_SIGNALS = [
-    [
-        InlineKeyboardButton("XAUUSD", callback_data="instrument_XAUUSD_signals"),
-        InlineKeyboardButton("XAGUSD", callback_data="instrument_XAGUSD_signals"),
-        InlineKeyboardButton("USOIL", callback_data="instrument_USOIL_signals")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Forex keyboard for signals
-FOREX_KEYBOARD_SIGNALS = [
-    [
-        InlineKeyboardButton("EURUSD", callback_data="instrument_EURUSD_signals"),
-        InlineKeyboardButton("GBPUSD", callback_data="instrument_GBPUSD_signals"),
-        InlineKeyboardButton("USDJPY", callback_data="instrument_USDJPY_signals")
-    ],
-    [
-        InlineKeyboardButton("USDCAD", callback_data="instrument_USDCAD_signals"),
-        InlineKeyboardButton("EURGBP", callback_data="instrument_EURGBP_signals")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Crypto keyboard for signals
-CRYPTO_KEYBOARD_SIGNALS = [
-    [
-        InlineKeyboardButton("BTCUSD", callback_data="instrument_BTCUSD_signals"),
-        InlineKeyboardButton("ETHUSD", callback_data="instrument_ETHUSD_signals"),
-        InlineKeyboardButton("XRPUSD", callback_data="instrument_XRPUSD_signals")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Indices keyboard voor sentiment analyse
-INDICES_SENTIMENT_KEYBOARD = [
-    [
-        InlineKeyboardButton("US30", callback_data="instrument_US30_sentiment"),
-        InlineKeyboardButton("US500", callback_data="instrument_US500_sentiment"),
-        InlineKeyboardButton("US100", callback_data="instrument_US100_sentiment")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Commodities keyboard voor sentiment analyse
-COMMODITIES_SENTIMENT_KEYBOARD = [
-    [
-        InlineKeyboardButton("GOLD", callback_data="instrument_XAUUSD_sentiment"),
-        InlineKeyboardButton("SILVER", callback_data="instrument_XAGUSD_sentiment"),
-        InlineKeyboardButton("OIL", callback_data="instrument_USOIL_sentiment")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Style keyboard
-STYLE_KEYBOARD = [
-    [InlineKeyboardButton("‚ö° Test (one_min)", callback_data="style_test")],
-    [InlineKeyboardButton("üèÉ Scalp (fifteen_min)", callback_data="style_scalp")],
-    [InlineKeyboardButton(" Intraday (one_hour)", callback_data="style_intraday")],
-    [InlineKeyboardButton("üåä Swing (four_hour)", callback_data="style_swing")],
-    [InlineKeyboardButton("Back", callback_data="back_instrument")]
-]
-
-# Timeframe mapping
-STYLE_TIMEFRAME_MAP = {
-    "test": "one_min",
-    "scalp": "fifteen_min",
-    "intraday": "one_hour",
-    "swing": "four_hour"
-}
-
-# Mapping of instruments to their allowed timeframes - updated 2023-03-23
-INSTRUMENT_TIMEFRAME_MAP = {
-    # H1 timeframe only
-    "AUDJPY": "H1", 
-    "AUDCHF": "H1",
-    "EURCAD": "H1",
-    "EURGBP": "H1",
-    "GBPCHF": "H1",
-    "HK50": "H1",
-    "NZDJPY": "H1",
-    "USDCHF": "H1",
-    "USDJPY": "H1",  # USDJPY toegevoegd voor signaalabonnementen
-    "XRPUSD": "H1",
-    
-    # H4 timeframe only
-    "AUDCAD": "H4",
-    "AU200": "H4", 
-    "CADCHF": "H4",
-    "EURCHF": "H4",
-    "EURUSD": "H4",
-    "GBPCAD": "H4",
-    "LINKUSD": "H4",
-    "NZDCHF": "H4",
-    
-    # M15 timeframe only
-    "DOGEUSD": "M15",
-    "GBPNZD": "M15",
-    "NZDUSD": "M15",
-    "SOLUSD": "M15",
-    "UK100": "M15",
-    "XAUUSD": "M15",
-    
-    # M30 timeframe only
-    "BNBUSD": "M30",
-    "DOTUSD": "M30",
-    "ETHUSD": "M30",
-    "EURAUD": "M30",
-    "EURJPY": "M30",
-    "GBPAUD": "M30",
-    "GBPUSD": "M30",
-    "NZDCAD": "M30",
-    "US30": "M30",
-    "US500": "M30",
-    "USDCAD": "M30",
-    "XLMUSD": "M30",
-    "XTIUSD": "M30",
-    "DE40": "M30",
-    "BTCUSD": "M30",  # Added for consistency with CRYPTO_KEYBOARD_SIGNALS
-    "US100": "M30",   # Added for consistency with INDICES_KEYBOARD_SIGNALS
-    "XAGUSD": "M15",  # Added for consistency with COMMODITIES_KEYBOARD_SIGNALS
-    "USOIL": "M30"    # Added for consistency with COMMODITIES_KEYBOARD_SIGNALS
-    
-    # Removed as requested: EU50, FR40, LTCUSD
-}
-
-# Map common timeframe notations
-TIMEFRAME_DISPLAY_MAP = {
-    "M15": "15 Minutes",
-    "M30": "30 Minutes", 
-    "H1": "1 Hour",
-    "H4": "4 Hours"
-}
-
-# Voeg deze functie toe aan het begin van bot.py, na de imports
-def _detect_market(instrument: str) -> str:
-    """Detecteer market type gebaseerd op instrument"""
-    instrument = instrument.upper()
-    
-    # Commodities eerst checken
-    commodities = [
-        "XAUUSD",  # Gold
-        "XAGUSD",  # Silver
-        "WTIUSD",  # Oil WTI
-        "BCOUSD",  # Oil Brent
-        "USOIL",   # Oil WTI (alternative symbol)
-    ]
-    if instrument in commodities:
-        logger.info(f"Detected {instrument} as commodity")
-        return "commodities"
-    
-    # Crypto pairs
-    crypto_base = ["BTC", "ETH", "XRP", "SOL", "BNB", "ADA", "DOT", "LINK"]
-    if any(c in instrument for c in crypto_base):
-        logger.info(f"Detected {instrument} as crypto")
-        return "crypto"
-    
-    # Major indices
-    indices = [
-        "US30", "US500", "US100",  # US indices
-        "UK100", "DE40", "FR40",   # European indices
-        "JP225", "AU200", "HK50"   # Asian indices
-    ]
-    if instrument in indices:
-        logger.info(f"Detected {instrument} as index")
-        return "indices"
-    
-    # Forex pairs als default
-    logger.info(f"Detected {instrument} as forex")
-    return "forex"
-
-# Voeg dit toe als decorator functie bovenaan het bestand na de imports
-def require_subscription(func):
-    """Check if user has an active subscription"""
-    async def wrapper(self, update: Update, context: ContextTypes.DEFAULT_TYPE, *args, **kwargs):
-        user_id = update.effective_user.id
-        
-        # Check subscription status
-        is_subscribed = await self.db.is_user_subscribed(user_id)
-        
-        # Check if payment has failed
-        payment_failed = await self.db.has_payment_failed(user_id)
-        
-        if is_subscribed and not payment_failed:
-            # User has subscription, proceed with function
-            return await func(self, update, context, *args, **kwargs)
-        else:
-            if payment_failed:
-                # Show payment failure message
-                failed_payment_text = f"""
- <b>Subscription Payment Failed</b> 
-
-Your subscription payment could not be processed and your service has been deactivated.
-
-To continue using Sigmapips AI and receive trading signals, please reactivate your subscription by clicking the button below.
-                """
-                
-                # Use direct URL link for reactivation
-                reactivation_url = "https://buy.stripe.com/9AQcPf3j63HL5JS145"
-                
-                # Create button for reactivation
-                keyboard = [
-                    [InlineKeyboardButton("üîÑ Reactivate Subscription", url=reactivation_url)]
-                ]
-            else:
-                # Show subscription screen with the welcome message from the screenshot
-                failed_payment_text = f"""
- <b>Welcome to Sigmapips AI!</b> 
-
-<b>Discover powerful trading signals for various markets:</b>
-- <b>Forex</b> - Major and minor currency pairs
-- <b>Crypto</b> - Bitcoin, Ethereum and other top cryptocurrencies
-- <b>Indices</b> - Global market indices
-- <b>Commodities</b> - Gold, silver and oil
-
-<b>Features:</b>
- Real-time trading signals
-
- Multi-timeframe analysis (timeframes)
-
- Advanced chart analysis
-
- Sentiment indicators
-
- Economic calendar integration
-
-<b>Start today with a FREE 14-day trial!</b>
-                """
-                
-                # Use direct URL link instead of callback for the trial button
-                reactivation_url = "https://buy.stripe.com/3cs3eF9Hu9256NW9AA"
-                
-                # Create button for trial
-                keyboard = [
-                    [InlineKeyboardButton("üî• Start 14-day FREE Trial", url=reactivation_url)]
-                ]
-            
-            # Handle both message and callback query updates
-            if update.callback_query:
-                await update.callback_query.answer()
-                await update.callback_query.edit_message_text(
-                    text=failed_payment_text,
-                    reply_markup=InlineKeyboardMarkup(keyboard),
-                    parse_mode=ParseMode.HTML
-                )
-            else:
-                await update.message.reply_text(
-                    text=failed_payment_text,
-                    reply_markup=InlineKeyboardMarkup(keyboard),
-                    parse_mode=ParseMode.HTML
-                )
-            return MENU
-    
-    return wrapper
-
-# API keys with robust sanitization
-PERPLEXITY_API_KEY = os.getenv("PERPLEXITY_API_KEY", "").strip()
-OPENAI_API_KEY = os.getenv("OPENAI_API_KEY", "").strip()  # Changed from DeepSeek to OpenAI
-
-# Only using OpenAI's o4-mini now
-# No Tavily API key needed anymore
-logger.info("Using only OpenAI o4-mini for Market Sentiment service")
-
-# Log OpenAI API key (partially masked)
-if OPENAI_API_KEY:
-    # Better masking for privacy and security
-    masked_key = f"sk-p...{OPENAI_API_KEY[-4:]}" if len(OPENAI_API_KEY) > 8 else "sk-p..."
-    logger.info(f"Using OpenAI API key: {masked_key}")
-    
-    # Validate the key format
-    from trading_bot.config import validate_openai_key
-    if not validate_openai_key(OPENAI_API_KEY):
-        logger.warning("OpenAI API key format is invalid. AI services may not work correctly.")
-else:
-    logger.warning("No OpenAI API key configured. AI services will be disabled.")
-    
-# Set environment variables for the API keys with sanitization
-os.environ["PERPLEXITY_API_KEY"] = PERPLEXITY_API_KEY
-os.environ["OPENAI_API_KEY"] = OPENAI_API_KEY  # Changed from DeepSeek to OpenAI
-# No Tavily environment needed
-
-class TelegramService:
-    def __init__(self, db: Database, stripe_service=None, bot_token: Optional[str] = None, proxy_url: Optional[str] = None, lazy_init: bool = False):
-        """Initialize the bot with given database and config."""
-        # Database connection
-        self.db = db
-        
-        # Setup configuration 
-        self.stripe_service = stripe_service
-        self.user_signals = {}
-        self.signals_dir = "data/signals"
-        self.signals_enabled_val = True
-        self.polling_started = False
-        self.admin_users = [2004519703]  # Updated with correct Telegram ID from logs
-        self._signals_enabled = True  # Enable signals by default
-        
-        # Setup logger
-        self.logger = logging.getLogger(__name__)
-        
-        # GIF utilities for UI
-        self.gif_utils = gif_utils  # Initialize gif_utils as an attribute
-        
-        # Setup the bot and application
-        self.bot = None
-        self.application = None
-        
-        # Telegram Bot configuratie
-        self.bot_token = bot_token or os.getenv("TELEGRAM_BOT_TOKEN", "")
-        self.token = self.bot_token  # Aliased for backward compatibility
-        self.proxy_url = proxy_url or os.getenv("TELEGRAM_PROXY_URL", "")
-        
-        # Configure custom request handler with improved connection settings
-        request = HTTPXRequest(
-            connection_pool_size=50,  # Increase from 20 to 50
-            connect_timeout=15.0,     # Increase from 10.0 to 15.0
-            read_timeout=45.0,        # Increase from 30.0 to 45.0
-            write_timeout=30.0,       # Increase from 20.0 to 30.0
-            pool_timeout=60.0,        # Increase from 30.0 to 60.0
-        )
-        
-        # Initialize the bot directly with connection pool settings
-        self.bot = Bot(token=self.bot_token, request=request)
-        self.application = None  # Will be initialized in setup()
-        
-        # Webhook configuration
-        self.webhook_url = os.getenv("WEBHOOK_URL", "")
-        self.webhook_path = "/webhook"  # Always use this path
-        if self.webhook_url.endswith("/"):
-            self.webhook_url = self.webhook_url[:-1]  # Remove trailing slash
-            
-        logger.info(f"Bot initialized with webhook URL: {self.webhook_url} and path: {self.webhook_path}")
-        
-        # Initialize API services
-        self.chart_service = ChartService()  # Initialize chart service
-        # Lazy load services only when needed
-        self._calendar_service = None
-        self._sentiment_service = None
-        
-        # Don't use asyncio.create_task here - it requires a running event loop
-        # We'll initialize chart service later when the event loop is running
-        
-        # Bot application initialization
-        self.persistence = None
-        self.bot_started = False
-        
-        # Cache for sentiment analysis
-        self.sentiment_cache = {}
-        self.sentiment_cache_ttl = 60 * 60  # 1 hour in seconds
-        
-        # Start the bot
-    try:
-            # Check for bot token
-            if not self.bot_token:
-                raise ValueError("Missing Telegram bot token")
-            
-            # Initialize the bot
-            self.bot = Bot(token=self.bot_token)
-        
-            # Initialize the application
-            self.application = Application.builder().bot(self.bot).build()
-        
-            # Register the handlers
-            self._register_handlers(self.application)
-            
-            # Initialize signals dictionary but don't load them yet (will be done in initialize_services)
-            self.user_signals = {}
-        
-            logger.info("Telegram service initialized")
-            
-            # Keep track of processed updates
-            self.processed_updates = set()
-            
-    except Exception as e:
-        logger.error(f"Error initializing Telegram service: {str(e)}")
-        raise
-
-    async def initialize_services(self):
-        """Initialize services that require an asyncio event loop"""
-        try:
-            # Initialize chart service
-            await self.chart_service.initialize()
-            logger.info("Chart service initialized")
-            
-            # Load stored signals
-            await self._load_signals()
-            logger.info("Signals loaded")
-            
-            # Schedule periodic cleanup of old signals
-            if hasattr(self, 'db') and self.db and self.db.using_redis:
-                # Run initial cleanup
-                cleaned = await self._cleanup_old_signals(max_age_days=7)
-                logger.info(f"Initial signal cleanup completed, removed {cleaned} old signals")
-                
-                # Schedule periodic cleanup (every 24 hours)
-                async def periodic_cleanup():
-                    while True:
-                        try:
-                            # Wait for 24 hours
-                            await asyncio.sleep(24 * 60 * 60)
-                            # Run cleanup
-                            cleaned = await self._cleanup_old_signals(max_age_days=7)
-                            logger.info(f"Periodic signal cleanup completed, removed {cleaned} old signals")
-                        except Exception as e:
-                            logger.error(f"Error in periodic signal cleanup: {str(e)}")
-                
-                # Start the periodic cleanup task
-                asyncio.create_task(periodic_cleanup())
-                logger.info("Scheduled periodic signal cleanup")
-        except Exception as e:
-            logger.error(f"Error initializing services: {str(e)}")
-            raise
-            
-    # Calendar service helpers
-    @property
-    def calendar_service(self):
-        """Lazy loaded calendar service"""
-        if self._calendar_service is None:
-            # Only initialize the calendar service when it's first accessed
-            self.logger.info("Lazy loading calendar service")
-            self._calendar_service = EconomicCalendarService()
-        return self._calendar_service
-        
-    def _get_calendar_service(self):
-        """Get the calendar service instance"""
-        self.logger.info("Getting calendar service")
-        return self.calendar_service
-
-    async def _format_calendar_events(self, calendar_data):
-        """Format the calendar data into a readable HTML message"""
-        self.logger.info(f"Formatting calendar data with {len(calendar_data)} events")
-        if not calendar_data:
-            return "<b>Economic Calendar</b>\n\nNo economic events found for today."
-        
-        # Sort events by time
-        try:
-            # Try to parse time for sorting
-            def parse_time_for_sorting(event):
-                time_str = event.get('time', '')
-                try:
-                    # Extract hour and minute if in format like "08:30 EST"
-                    if ':' in time_str:
-                        parts = time_str.split(' ')[0].split(':')
-                        hour = int(parts[0])
-                        minute = int(parts[1])
-                        return hour * 60 + minute
-                    return 0
-                except:
-                    return 0
-            
-            # Sort the events by time
-            sorted_events = sorted(calendar_data, key=parse_time_for_sorting)
-        except Exception as e:
-            self.logger.error(f"Error sorting calendar events: {str(e)}")
-            sorted_events = calendar_data
-        
-        # Format the message
-        message = "<b>Economic Calendar</b>\n\n"
-        
-        # Get current date
-        current_date = datetime.now().strftime("%B %d, %Y")
-        message += f"<b>Date:</b> {current_date}\n\n"
-        
-        # Add impact legend
-        message += "<b>Impact:</b> üî¥ High   üü† Medium   üü¢ Low\n\n"
-        
-        # Group events by country
-        events_by_country = {}
-        for event in sorted_events:
-            country = event.get('country', 'Unknown')
-            if country not in events_by_country:
-                events_by_country[country] = []
-            events_by_country[country].append(event)
-        
-        # Format events by country
-        for country, events in events_by_country.items():
-            country_flag = CURRENCY_FLAG.get(country, '')
-            message += f"<b>{country_flag} {country}</b>\n"
-            
-            for event in events:
-                time = event.get('time', 'TBA')
-                title = event.get('title', 'Unknown Event')
-                impact = event.get('impact', 'Low')
-                impact_emoji = {'High': 'üî¥', 'Medium': 'üü†', 'Low': 'üü¢'}.get(impact, 'üü¢')
-                
-                message += f"{time} - {impact_emoji} {title}\n"
-            
-            message += "\n"  # Add extra newline between countries
-        
-        return message
-        
-    # Utility functions that might be missing
-    async def update_message(self, query, text, keyboard=None, parse_mode=ParseMode.HTML):
-        """Utility to update a message with error handling"""
-        try:
-            # Check if the message is too long for Telegram caption limits (1024 chars)
-            MAX_CAPTION_LENGTH = 1000  # Slightly under the 1024 limit for safety
-            MAX_MESSAGE_LENGTH = 4000  # Telegram message limit
-            
-            # Log message length for debugging
-            logger.info(f"Updating message (length: {len(text)} chars)")
-            
-            # If message is too long for a caption but ok for a text message
-            if len(text) > MAX_CAPTION_LENGTH and len(text) <= MAX_MESSAGE_LENGTH:
-                logger.info("Message too long for caption but ok for text message")
-                # Try to edit message text first
-                await query.edit_message_text(
-                    text=text,
-                    reply_markup=keyboard,
-                    parse_mode=parse_mode
-                )
-                return True
-            # If message is too long even for a text message
-            elif len(text) > MAX_MESSAGE_LENGTH:
-                logger.warning(f"Message too long ({len(text)} chars), truncating")
-                # Find a good breaking point
-                truncated = text[:MAX_MESSAGE_LENGTH-100]
-                
-                # Try to break at a paragraph
-                last_newline = truncated.rfind('\n\n')
-                if last_newline > MAX_MESSAGE_LENGTH * 0.8:  # If we can keep at least 80% of the text
-                    truncated = truncated[:last_newline]
-                    
-                # Add indicator that text was truncated
-                truncated += "\n\n<i>... (message truncated)</i>"
-                
-                # Try to edit message text with truncated content
-                await query.edit_message_text(
-                    text=truncated,
-                    reply_markup=keyboard,
-                    parse_mode=parse_mode
-                )
-                return True
-            else:
-                # Normal case - message is within limits
-                # Try to edit message text first
-                await query.edit_message_text(
-                    text=text,
-                    reply_markup=keyboard,
-                    parse_mode=parse_mode
-                )
-                return True
-        except Exception as e:
-            logger.warning(f"Could not update message text: {str(e)}")
-            
-            # If text update fails, try to edit caption
-            try:
-                # Check if caption is too long
-                MAX_CAPTION_LENGTH = 1000  # Slightly under the 1024 limit for safety
-                
-                if len(text) > MAX_CAPTION_LENGTH:
-                    logger.warning(f"Caption too long ({len(text)} chars), truncating")
-                    # Find a good breaking point
-                    truncated = text[:MAX_CAPTION_LENGTH-100]
-                    
-                    # Try to break at a paragraph
-                    last_newline = truncated.rfind('\n\n')
-                    if last_newline > MAX_CAPTION_LENGTH * 0.8:  # If we can keep at least 80% of the text
-                        truncated = truncated[:last_newline]
-                        
-                    # Add indicator that text was truncated
-                    truncated += "\n\n<i>... (message truncated)</i>"
-                    
-                    # Use truncated text for caption
-                    await query.edit_message_caption(
-                        caption=truncated,
-                        reply_markup=keyboard,
-                        parse_mode=parse_mode
-                    )
-                else:
-                    # Caption is within limits
-                    await query.edit_message_caption(
-                        caption=text,
-                        reply_markup=keyboard,
-                        parse_mode=parse_mode
-                    )
-                return True
-            except Exception as e2:
-                logger.error(f"Could not update caption either: {str(e2)}")
-                
-                # As a last resort, send a new message
-                try:
-                    chat_id = query.message.chat_id
-                    
-                    # Check if message is too long
-                    MAX_MESSAGE_LENGTH = 4000  # Telegram message limit
-                    
-                    if len(text) > MAX_MESSAGE_LENGTH:
-                        logger.warning(f"New message too long ({len(text)} chars), truncating")
-                        # Find a good breaking point
-                        truncated = text[:MAX_MESSAGE_LENGTH-100]
-                        
-                        # Try to break at a paragraph
-                        last_newline = truncated.rfind('\n\n')
-                        if last_newline > MAX_MESSAGE_LENGTH * 0.8:  # If we can keep at least 80% of the text
-                            truncated = truncated[:last_newline]
-                            
-                        # Add indicator that text was truncated
-                        truncated += "\n\n<i>... (message truncated)</i>"
-                        
-                        # Use truncated text for new message
-                        await query.bot.send_message(
-                            chat_id=chat_id,
-                            text=truncated,
-                            reply_markup=keyboard,
-                            parse_mode=parse_mode
-                        )
-                    else:
-                        # Message is within limits
-                        await query.bot.send_message(
-                            chat_id=chat_id,
-                            text=text,
-                            reply_markup=keyboard,
-                            parse_mode=parse_mode
-                        )
-                    return True
-                except Exception as e3:
-                    logger.error(f"Failed to send new message: {str(e3)}")
-                    return False
-    
-    # Missing handler implementations
-    async def back_signals_callback(self, update: Update, context=None) -> int:
-        """Handle back_signals button press"""
-        query = update.callback_query
-        await query.answer()
-        
-        logger.info("back_signals_callback called")
-        
-        # Make sure we're in the signals flow context
-        if context and hasattr(context, 'user_data'):
-            # Reset signal flow flags
-            context.user_data['from_signal'] = False
-            context.user_data['in_signal_flow'] = False
-            logger.info(f"Reset signal flow flags: from_signal=False, in_signal_flow=False")
-            # Keep is_signals_context flag but reset from_signal flag
-            context.user_data['is_signals_context'] = True
-            context.user_data['from_signal'] = False
-            
-            # Clear other specific analysis keys but maintain signals context
-            keys_to_remove = [
-                'instrument', 'market', 'analysis_type', 'timeframe', 
-                'signal_id', 'signal_instrument', 'signal_direction', 'signal_timeframe',
-                'loading_message'
-            ]
-
-            for key in keys_to_remove:
-                if key in context.user_data:
-                    del context.user_data[key]
-            logger.info(f"Updated context in back_signals_callback: {context.user_data}")
-        
-        # Create keyboard for signal menu
-        keyboard = [
-            [InlineKeyboardButton(" Add Signal", callback_data="signals_add")],
-            [InlineKeyboardButton("Manage Signals", callback_data="signals_manage")],
-            [InlineKeyboardButton("Back to Menu", callback_data="back_menu")]
-        ]
-        reply_markup = InlineKeyboardMarkup(keyboard)
-        
-        # Get the signals GIF URL for better UX
-        signals_gif_url = "https://media.giphy.com/media/gSzIKNrqtotEYrZv7i/giphy.gif"
-        
-        # Update the message
-        await self.update_message(
-            query=query,            text="<b> Signal Management</b>\n\nManage your trading signals",
-
-
-            keyboard=reply_markup
-        )
-        
-        return SIGNALS
-        
-    async def get_subscribers_for_instrument(self, instrument: str, timeframe: str = None) -> List[int]:
-        """
-        Get a list of subscribed user IDs for a specific instrument and timeframe
-        
-        Args:
-            instrument: The trading instrument (e.g., EURUSD)
-            timeframe: Optional timeframe filter
-            
-        Returns:
-            List of subscribed user IDs
-        """
-    try:
-            logger.info(f"Getting subscribers for {instrument} timeframe: {timeframe}")
-            
-            # Get all subscribers from the database
-            # Note: Using get_signal_subscriptions instead of find_all
-            subscribers = await self.db.get_signal_subscriptions(instrument, timeframe)
-            
-            if not subscribers:
-                logger.warning(f"No subscribers found for {instrument}")
-                return []
-                
-            # Filter out subscribers that don't have an active subscription
-            active_subscribers = []
-            for subscriber in subscribers:
-                user_id = subscriber['user_id']
-                
-                # Check if user is subscribed
-                is_subscribed = await self.db.is_user_subscribed(user_id)
-                
-                # Check if payment has failed
-                payment_failed = await self.db.has_payment_failed(user_id)
-                
-                if is_subscribed and not payment_failed:
-                    active_subscribers.append(user_id)
-                else:
-                    logger.info(f"User {user_id} doesn't have an active subscription, skipping signal")
-            
-            return active_subscribers
-            
-    except Exception as e:
-        logger.error(f"Error getting subscribers: {str(e)}")
-        logger.error(f"Error getting subscribers: {str(e)}")
-        # FOR TESTING: Add admin users if available
-        if hasattr(self, 'admin_users') and self.admin_users:
-            logger.info(f"Returning admin users for testing: {self.admin_users}")
-            return self.admin_users
-        return []
-    async def process_signal(self, signal_data: Dict[str, Any]) -> bool:
-        """
-        Process a trading signal from TradingView webhook or API
-        
-        Supports two formats:
-        1. TradingView format: instrument, signal, price, sl, tp1, tp2, tp3, interval
-        2. Custom format: instrument, direction, entry, stop_loss, take_profit, timeframe
-        
-        Returns:
-            bool: True if signal was processed successfully, False otherwise
-        """
-        try:
-            # Log the incoming signal data
-            logger.info(f"Processing signal: {signal_data}")
-            
-            # Check which format we're dealing with and normalize it
-            instrument = signal_data.get('instrument')
-            
-            # Handle TradingView format (price, sl, interval)
-            if 'price' in signal_data and 'sl' in signal_data:
-                price = signal_data.get('price')
-                sl = signal_data.get('sl')
-                tp1 = signal_data.get('tp1')
-                tp2 = signal_data.get('tp2')
-                tp3 = signal_data.get('tp3')
-                interval = signal_data.get('interval', 'one_hour')
-                
-                # Determine signal direction based on price and SL relationship
-                direction = "BUY" if float(sl) < float(price) else "SELL"
-                
-                # Create normalized signal data
-                normalized_data = {
-                    'instrument': instrument,
-                    'direction': direction,
-                    'entry': price,
-                    'stop_loss': sl,
-                    'take_profit': tp1,  # Use first take profit level
-                    'timeframe': interval
-                }
-                
-                # Add optional fields if present
-                normalized_data['tp1'] = tp1
-                normalized_data['tp2'] = tp2
-                normalized_data['tp3'] = tp3
-                
-            # Handle custom format (direction, entry, stop_loss, timeframe)
-            elif 'direction' in signal_data and 'entry' in signal_data:
-                direction = signal_data.get('direction')
-                entry = signal_data.get('entry')
-                stop_loss = signal_data.get('stop_loss')
-                take_profit = signal_data.get('take_profit')
-                timeframe = signal_data.get('timeframe', 'one_hour')
-                
-                # Create normalized signal data
-                normalized_data = {
-                    'instrument': instrument,
-                    'direction': direction,
-                    'entry': entry,
-                    'stop_loss': stop_loss,
-                    'take_profit': take_profit,
-                    'timeframe': timeframe
-                }
-            else:
-                logger.error(f"Missing required signal data")
-                return False
-            
-            # Basic validation
-            if not normalized_data.get('instrument') or not normalized_data.get('direction') or not normalized_data.get('entry'):
-                logger.error(f"Missing required fields in normalized signal data: {normalized_data}")
-                return False
-                
-            # Create signal ID for tracking
-            signal_id = f"{normalized_data['instrument']}_{normalized_data['direction']}_{normalized_data['timeframe']}_{int(time.time())}"
-            
-            # Format the signal message
-            message = self._format_signal_message(normalized_data)
-            
-            # Determine market type for the instrument
-            market_type = _detect_market(instrument)
-            
-            # Store the full signal data for reference
-            normalized_data['id'] = signal_id
-            normalized_data['timestamp'] = datetime.now().isoformat()
-            normalized_data['message'] = message
-            normalized_data['market'] = market_type
-            
-            # Save signal for history tracking
-            if not os.path.exists(self.signals_dir):
-                os.makedirs(self.signals_dir, exist_ok=True)
-                
-            # Save to signals directory
-            with open(f"{self.signals_dir}/{signal_id}.json", 'w') as f:
-                json.dump(normalized_data, f)
-            
-            # FOR TESTING: Always send to admin for testing
-            if hasattr(self, 'admin_users') and self.admin_users:
-                try:
-                    logger.info(f"Sending signal to admin users for testing: {self.admin_users}")
-                    for admin_id in self.admin_users:
-                        # Prepare keyboard with analysis options
-                        keyboard = [
-                            [InlineKeyboardButton("Analyze Market", callback_data=f"analyze_from_signal_{instrument}_{signal_id}")]
-                        ]
-                        
-                        # Send the signal
-                        await self.bot.send_message(
-                            chat_id=admin_id,
-                            text=message,
-                            parse_mode=ParseMode.HTML,
-                            reply_markup=InlineKeyboardMarkup(keyboard)
-                        )
-                        logger.info(f"Test signal sent to admin {admin_id}")
-                        
-                        # Store signal reference for quick access
-                        if not hasattr(self, 'user_signals'):
-                            self.user_signals = {}
-                            
-                        admin_str_id = str(admin_id)
-                        if admin_str_id not in self.user_signals:
-                            self.user_signals[admin_str_id] = {}
-                        
-                        self.user_signals[admin_str_id][signal_id] = normalized_data
-                except Exception as e:
-                    logger.error(f"Error sending test signal to admin: {str(e)}")
-            
-            # Get subscribers for this instrument
-            timeframe = normalized_data.get('timeframe', 'one_hour')
-            subscribers = await self.get_subscribers_for_instrument(instrument, timeframe)
-            
-            if not subscribers:
-                logger.warning(f"No subscribers found for {instrument}")
-                return True  # Successfully processed, just no subscribers
-            
-            # Send signal to all subscribers
-            logger.info(f"Sending signal {signal_id} to {len(subscribers)} subscribers")
-            
-            sent_count = 0
-            for user_id in subscribers:
-                try:
-                    # Prepare keyboard with analysis options
-                    keyboard = [
-                        [InlineKeyboardButton("Analyze Market", callback_data=f"analyze_from_signal_{instrument}_{signal_id}")]
-                    ]
-                    
-                    # Send the signal
-                    await self.bot.send_message(
-                        chat_id=user_id,
-                        text=message,
-                        parse_mode=ParseMode.HTML,
-                        reply_markup=InlineKeyboardMarkup(keyboard)
-                    )
-                    
-                    sent_count += 1
-                    
-                    # Store signal reference for quick access
-                    if not hasattr(self, 'user_signals'):
-                        self.user_signals = {}
-                        
-                    user_str_id = str(user_id)
-                    if user_str_id not in self.user_signals:
-                        self.user_signals[user_str_id] = {}
-                    
-                    self.user_signals[user_str_id][signal_id] = normalized_data
-                    
-                except Exception as e:
-                    logger.error(f"Error sending signal to user {user_id}: {str(e)}")
-            
-            logger.info(f"Successfully sent signal {signal_id} to {sent_count}/{len(subscribers)} subscribers")
-            return True
-            
-        except Exception as e:
-            logger.error(f"Error processing signal: {str(e)}")
-            logger.exception(e)
-            return False
-
-    def _format_signal_message(self, signal_data: Dict[str, Any]) -> str:
-        """Format signal data into a nice message for Telegram"""
-        try:
-            # Extract fields from signal data
-            instrument = signal_data.get('instrument', 'Unknown')
-            direction = signal_data.get('direction', 'Unknown')
-            entry = signal_data.get('entry', 'Unknown')
-            stop_loss = signal_data.get('stop_loss')
-            take_profit = signal_data.get('take_profit')
-            timeframe = signal_data.get('timeframe', 'one_hour')
-            
-            # Get take profit levels if available
-            tp1 = signal_data.get('tp1', take_profit)
-            tp2 = signal_data.get('tp2')
-            tp3 = signal_data.get('tp3')
-            
-            # Add emoji based on direction
-            direction_emoji = "üü¢" if direction.upper() == "BUY" else "üî¥"
-            
-            # Format the message with multiple take profits if available
-            message = "<b> New Trading Signal </b>\n"
-            message += f"<b>Instrument:</b> {instrument}\n"
-            message += f"<b>Action:</b> {direction.upper()} {direction_emoji}\n"
-            message += f"<b>Entry Price:</b> {entry}\n"
-            
-            if stop_loss:
-                message += f"<b>Stop Loss:</b> {stop_loss} üî¥\n"
-            
-            # Add take profit levels
-            if tp1:
-                message += f"<b>Take Profit 1:</b> {tp1} \n"
-            if tp2:
-                message += f"<b>Take Profit 2:</b> {tp2} \n"
-            if tp3:
-                message += f"<b>Take Profit 3:</b> {tp3} \n"
-            
-            message += f"\n<b>Timeframe:</b> {timeframe}\n"
-            message += "<b>Strategy:</b> TradingView Signal\n"
-            
-            message += "‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî\n"
-            message += "<b>Risk Management:</b>\n"
-            message += "- Position size: 1-2% max\n"
-            message += "- Use proper stop loss\n"
-            message += "- Follow your trading plan\n"
-            
-            message += "‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî\n"
-            
-            # Generate AI verdict
-            ai_verdict = f"The {instrument} {direction.lower()} signal shows a promising setup with defined entry at {entry} and stop loss at {stop_loss}. Multiple take profit levels provide opportunities for partial profit taking."
-            message += f"<b>ü§ñ SigmaPips AI Verdict:</b>\n{ai_verdict}"
-            
-            return message
-            
-        except Exception as e:
-            logger.error(f"Error formatting signal message: {str(e)}")
-            # Return simple message on error
-            return f"New {signal_data.get('instrument', 'Unknown')} {signal_data.get('direction', 'Unknown')} Signal"
-
-    def _register_handlers(self, application):
-        """Register event handlers for bot commands and callback queries"""
-    try:
-            logger.info("Registering command handlers")
-            
-            # Initialize the application without using run_until_complete
-            try:
-                # Instead of using loop.run_until_complete, directly call initialize 
-                # which will be properly awaited by the caller
-                self.init_task = application.initialize()
-                logger.info("Telegram application initialization ready to be awaited")
-            except Exception as init_e:
-                logger.error(f"Error during application initialization: {str(init_e)}")
-                logger.exception(init_e)
-                
-            # Set bot commands for menu
-            commands = [
-                BotCommand("start", "Start the bot and get the welcome message"),
-                BotCommand("menu", "Show the main menu"),
-                BotCommand("help", "Show available commands and how to use the bot")
-            ]
-            
-            # Store the set_commands_task to be awaited later
-            try:
-                # Instead of asyncio.create_task, we will await this in the startup event
-                self.set_commands_task = self.bot.set_my_commands(commands)
-                logger.info("Bot commands ready to be set")
-            except Exception as cmd_e:
-                logger.error(f"Error preparing bot commands: {str(cmd_e)}")
-            
-            # Register command handlers
-            application.add_handler(CommandHandler("start", self.start_command))
-            application.add_handler(CommandHandler("menu", self.menu_command))
-            application.add_handler(CommandHandler("help", self.help_command))
-            
-            # Register secret admin commands
-            application.add_handler(CommandHandler("set_subscription", self.set_subscription_command))
-            application.add_handler(CommandHandler("set_payment_failed", self.set_payment_failed_command))
-            logger.info("Registered secret admin commands")
-            
-            # Register callback handlers
-            application.add_handler(CallbackQueryHandler(self.menu_analyse_callback, pattern="^menu_analyse$"))
-            application.add_handler(CallbackQueryHandler(self.menu_signals_callback, pattern="^menu_signals$"))
-            application.add_handler(CallbackQueryHandler(self.signals_add_callback, pattern="^signals_add$"))
-            application.add_handler(CallbackQueryHandler(self.signals_manage_callback, pattern="^signals_manage$"))
-            application.add_handler(CallbackQueryHandler(self.market_callback, pattern="^market_"))
-            application.add_handler(CallbackQueryHandler(self.instrument_callback, pattern="^instrument_(?!.*_signals)"))
-            application.add_handler(CallbackQueryHandler(self.instrument_signals_callback, pattern="^instrument_.*_signals$"))
-            
-            # Add handler for back buttons
-            application.add_handler(CallbackQueryHandler(self.back_market_callback, pattern="^back_market$"))
-            application.add_handler(CallbackQueryHandler(self.back_instrument_callback, pattern="^back_instrument$"))
-            application.add_handler(CallbackQueryHandler(self.back_signals_callback, pattern="^back_signals$"))
-            application.add_handler(CallbackQueryHandler(self.back_menu_callback, pattern="^back_menu$"))
-            
-            # Analysis handlers for regular flow
-            application.add_handler(CallbackQueryHandler(self.analysis_technical_callback, pattern="^analysis_technical$"))
-            application.add_handler(CallbackQueryHandler(self.analysis_sentiment_callback, pattern="^analysis_sentiment$"))
-            application.add_handler(CallbackQueryHandler(self.analysis_calendar_callback, pattern="^analysis_calendar$"))
-            
-            # Analysis handlers for signal flow - with instrument embedded in callback
-            application.add_handler(CallbackQueryHandler(self.signal_technical_callback, pattern="^signal_flow_technical_.*$"))
-            application.add_handler(CallbackQueryHandler(self.signal_sentiment_callback, pattern="^signal_flow_sentiment_.*$"))
-            application.add_handler(CallbackQueryHandler(self.signal_calendar_callback, pattern="^signal_flow_calendar_.*$"))
-            
-            # Analysis handlers for signal flow - with instrument embedded in callback
-            application.add_handler(CallbackQueryHandler(self.signal_technical_callback, pattern="^signal_flow_technical_.*$"))
-            application.add_handler(CallbackQueryHandler(self.signal_sentiment_callback, pattern="^signal_flow_sentiment_.*$"))
-            application.add_handler(CallbackQueryHandler(self.analysis_calendar_callback, pattern="^signal_flow_calendar_.*$"))
-            
-            # Signal analysis flow handlers
-            application.add_handler(CallbackQueryHandler(self.signal_technical_callback, pattern="^signal_technical$"))
-            application.add_handler(CallbackQueryHandler(self.signal_sentiment_callback, pattern="^signal_sentiment$"))
-            application.add_handler(CallbackQueryHandler(self.signal_calendar_callback, pattern="^signal_calendar$"))
-            application.add_handler(CallbackQueryHandler(self.signal_calendar_callback, pattern="^signal_flow_calendar_.*$"))
-            application.add_handler(CallbackQueryHandler(self.back_to_signal_callback, pattern="^back_to_signal$"))
-            application.add_handler(CallbackQueryHandler(self.back_to_signal_analysis_callback, pattern="^back_to_signal_analysis$"))
-            
-            # Signal from analysis
-            application.add_handler(CallbackQueryHandler(self.analyze_from_signal_callback, pattern="^analyze_from_signal_.*$"))
-            
-            # Ensure back_instrument is properly handled
-            application.add_handler(CallbackQueryHandler(self.back_instrument_callback, pattern="^back_instrument$"))
-            
-            # Catch-all handler for any other callbacks
-            application.add_handler(CallbackQueryHandler(self.button_callback))
-            
-            # Don't load signals here - it will be done in initialize_services
-            # self._load_signals()
-            
-            logger.info("Bot setup completed successfully")
-            
-    except Exception as e:
-        logger.error(f"Error setting up bot handlers: {str(e)}")
-        logger.exception(e)
-
-    @property
-    def signals_enabled(self):
-        """Get whether signals processing is enabled"""
-        return self._signals_enabled
-    
-    @signals_enabled.setter
-    def signals_enabled(self, value):
-        """Set whether signals processing is enabled"""
-        self._signals_enabled = bool(value)
-        logger.info(f"Signal processing is now {'enabled' if value else 'disabled'}")
-
-    async def _get_signal_related_trades(self, signal_id):
-        """Retrieve related trades from the database"""
-        try:
-            # Fetch the related trades data from the database
-        trades_data = await self.db.get_related_trades(signal_id)
-            
-        if trades_data:
-            return trades_data
-        else:
-            logger.warning(f"No related trades data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related trades: {str(e)}")
-        logger.exception(e)
-        return None
-
-
-from telegram.error import TelegramError, BadRequest
-import httpx
-import telegram.error  # Add this import for BadRequest error handling
-
-from trading_bot.services.database.db import Database
-from trading_bot.services.chart_service.chart import ChartService
-from trading_bot.services.sentiment_service.sentiment import MarketSentimentService
-from trading_bot.services.calendar_service import EconomicCalendarService
-from trading_bot.services.payment_service.stripe_service import StripeService
-from trading_bot.services.payment_service.stripe_config import get_subscription_features
-from trading_bot.services.telegram_service.states import (
-    MENU, ANALYSIS, SIGNALS, CHOOSE_MARKET, CHOOSE_INSTRUMENT, CHOOSE_STYLE,
-    CHOOSE_ANALYSIS, SIGNAL_DETAILS,
-    CALLBACK_MENU_ANALYSE, CALLBACK_MENU_SIGNALS, CALLBACK_ANALYSIS_TECHNICAL,
-    CALLBACK_ANALYSIS_SENTIMENT, CALLBACK_ANALYSIS_CALENDAR, CALLBACK_SIGNALS_ADD,
-    CALLBACK_SIGNALS_MANAGE, CALLBACK_BACK_MENU
-)
-import trading_bot.services.telegram_service.gif_utils as gif_utils
-
-# Initialize logger
-logger = logging.getLogger(__name__)
-
-# Major currencies to focus on
-MAJOR_CURRENCIES = ["USD", "EUR", "GBP", "JPY", "CHF", "AUD", "NZD", "CAD"]
-
-# Currency to flag emoji mapping
-CURRENCY_FLAG = {
-    "USD": "üá∫üá∏",
-    "EUR": "üá™üá∫",
-    "GBP": "üá¨üáß",
-    "JPY": "üáØüáµ",
-    "CHF": "üá®üá≠",
-    "AUD": "üá¶üá∫",
-    "NZD": "üá≥üáø",
-    "CAD": "üá®üá¶"
-}
-
-# Map of instruments to their corresponding currencies
-INSTRUMENT_CURRENCY_MAP = {
-    # Special case for global view
-    "GLOBAL": MAJOR_CURRENCIES,
-    
-    # Forex
-    "EURUSD": ["EUR", "USD"],
-    "GBPUSD": ["GBP", "USD"],
-    "USDJPY": ["USD", "JPY"],
-    "USDCHF": ["USD", "CHF"],
-    "AUDUSD": ["AUD", "USD"],
-    "NZDUSD": ["NZD", "USD"],
-    "USDCAD": ["USD", "CAD"],
-    "EURGBP": ["EUR", "GBP"],
-    "EURJPY": ["EUR", "JPY"],
-    "GBPJPY": ["GBP", "JPY"],
-    
-    # Indices (mapped to their related currencies)
-    "US30": ["USD"],
-    "US100": ["USD"],
-    "US500": ["USD"],
-    "UK100": ["GBP"],
-    "GER40": ["EUR"],
-    "FRA40": ["EUR"],
-    "ESP35": ["EUR"],
-    "JP225": ["JPY"],
-    "AUS200": ["AUD"],
-    
-    # Commodities (mapped to USD primarily)
-    "XAUUSD": ["USD", "XAU"],  # Gold
-    "XAGUSD": ["USD", "XAG"],  # Silver
-    "USOIL": ["USD"],          # Oil (WTI)
-    "UKOIL": ["USD", "GBP"],   # Oil (Brent)
-    
-    # Crypto
-    "BTCUSD": ["USD", "BTC"],
-    "ETHUSD": ["USD", "ETH"],
-    "LTCUSD": ["USD", "LTC"],
-    "XRPUSD": ["USD", "XRP"]
-}
-
-# Callback data constants
-CALLBACK_ANALYSIS_TECHNICAL = "analysis_technical"
-CALLBACK_ANALYSIS_SENTIMENT = "analysis_sentiment"
-CALLBACK_ANALYSIS_CALENDAR = "analysis_calendar"
-CALLBACK_BACK_MENU = "back_menu"
-CALLBACK_BACK_ANALYSIS = "back_to_analysis"
-CALLBACK_BACK_MARKET = "back_market"
-CALLBACK_BACK_INSTRUMENT = "back_instrument"
-CALLBACK_BACK_SIGNALS = "back_signals"
-CALLBACK_SIGNALS_ADD = "signals_add"
-CALLBACK_SIGNALS_MANAGE = "signals_manage"
-CALLBACK_MENU_ANALYSE = "menu_analyse"
-CALLBACK_MENU_SIGNALS = "menu_signals"
-
-# States
-MENU = 0
-CHOOSE_ANALYSIS = 1
-CHOOSE_SIGNALS = 2
-CHOOSE_MARKET = 3
-CHOOSE_INSTRUMENT = 4
-CHOOSE_STYLE = 5
-SHOW_RESULT = 6
-CHOOSE_TIMEFRAME = 7
-SIGNAL_DETAILS = 8
-SIGNAL = 9
-SUBSCRIBE = 10
-BACK_TO_MENU = 11  # Add this line
-
-# Messages
-WELCOME_MESSAGE = r"""
-<b>Sigmapips AI - Main Menu</b>
-
-Choose an option to access advanced trading support:
-
-Services:
-- <b>Technical Analysis</b> - Real-time chart analysis and key levels
-
-- <b>Market Sentiment</b> - Understand market trends and sentiment
-
-- <b>Economic Calendar</b> - Stay updated on market-moving events
-
-- <b>Trading Signals</b> - Get precise entry/exit points for your favorite pairs
-
-Select your option to continue:
-"""
-
-# Abonnementsbericht voor nieuwe gebruikers
-SUBSCRIPTION_WELCOME_MESSAGE = r"""
-<b>Welcome to Sigmapips AI!</b>
-
-To access all features, you need a subscription:
-
-<b>Trading Signals Subscription - $29.99/month</b>
-- Access to all trading signals (Forex, Crypto, Commodities, Indices)
-- Advanced timeframe analysis
-- Detailed chart analysis for each signal
-
-Click the button below to subscribe:
-"""
-
-MENU_MESSAGE = r"""
-Welcome to Sigmapips AI!
-
-Choose a command:
-
-/start - Set up new trading pairs
-Add new market/instrument/timeframe combinations to receive signals
-
-/manage - Manage your preferences
-View, edit or delete your saved trading pairs
-
-Need help? Use /help to see all available commands.
-"""
-
-HELP_MESSAGE = r"""
-Available commands:
-/menu - Show main menu
-/start - Set up new trading pairs
-/help - Show this help message
-"""
-
-# Start menu keyboard
-START_KEYBOARD = [
-    [InlineKeyboardButton("Analyze Market", callback_data=CALLBACK_MENU_ANALYSE)],
-    [InlineKeyboardButton("Trading Signals", callback_data=CALLBACK_MENU_SIGNALS)]
-]
-
-# Analysis menu keyboard
-ANALYSIS_KEYBOARD = [
-    [InlineKeyboardButton("Technical Analysis", callback_data=CALLBACK_ANALYSIS_TECHNICAL)],
-    [InlineKeyboardButton("Market Sentiment", callback_data=CALLBACK_ANALYSIS_SENTIMENT)],
-    [InlineKeyboardButton("Economic Calendar", callback_data=CALLBACK_ANALYSIS_CALENDAR)],
-    [InlineKeyboardButton("Back", callback_data=CALLBACK_BACK_MENU)]
-]
-
-# Signals menu keyboard
-SIGNALS_KEYBOARD = [
-    [InlineKeyboardButton("Add New Pairs", callback_data=CALLBACK_SIGNALS_ADD)],
-    [InlineKeyboardButton("Manage Signals", callback_data=CALLBACK_SIGNALS_MANAGE)],
-    [InlineKeyboardButton("Back", callback_data=CALLBACK_BACK_MENU)]
-]
-
-# Market keyboard voor signals
-MARKET_KEYBOARD_SIGNALS = [
-    [InlineKeyboardButton("Forex", callback_data="market_forex_signals")],
-    [InlineKeyboardButton("Crypto", callback_data="market_crypto_signals")],
-    [InlineKeyboardButton("Commodities", callback_data="market_commodities_signals")],
-    [InlineKeyboardButton("Indices", callback_data="market_indices_signals")],
-    [InlineKeyboardButton("Back", callback_data="back_signals")]
-]
-
-# Market keyboard voor analyse
-MARKET_KEYBOARD = [
-    [InlineKeyboardButton("Forex", callback_data="market_forex")],
-    [InlineKeyboardButton("Crypto", callback_data="market_crypto")],
-    [InlineKeyboardButton("Commodities", callback_data="market_commodities")],
-    [InlineKeyboardButton("Indices", callback_data="market_indices")],
-    [InlineKeyboardButton("Back", callback_data="back_analysis")]
-]
-
-# Market keyboard specifiek voor sentiment analyse
-MARKET_SENTIMENT_KEYBOARD = [
-    [InlineKeyboardButton("Forex", callback_data="market_forex_sentiment")],
-    [InlineKeyboardButton("Crypto", callback_data="market_crypto_sentiment")],
-    [InlineKeyboardButton("Commodities", callback_data="market_commodities_sentiment")],
-    [InlineKeyboardButton("Indices", callback_data="market_indices_sentiment")],
-    [InlineKeyboardButton("Back", callback_data="back_analysis")]
-]
-
-# Forex keyboard voor technical analyse
-FOREX_KEYBOARD = [
-    [
-        InlineKeyboardButton("EURUSD", callback_data="instrument_EURUSD_chart"),
-        InlineKeyboardButton("GBPUSD", callback_data="instrument_GBPUSD_chart"),
-        InlineKeyboardButton("USDJPY", callback_data="instrument_USDJPY_chart")
-    ],
-    [
-        InlineKeyboardButton("AUDUSD", callback_data="instrument_AUDUSD_chart"),
-        InlineKeyboardButton("USDCAD", callback_data="instrument_USDCAD_chart"),
-        InlineKeyboardButton("EURGBP", callback_data="instrument_EURGBP_chart")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Forex keyboard voor sentiment analyse
-FOREX_SENTIMENT_KEYBOARD = [
-    [
-        InlineKeyboardButton("EURUSD", callback_data="instrument_EURUSD_sentiment"),
-        InlineKeyboardButton("GBPUSD", callback_data="instrument_GBPUSD_sentiment"),
-        InlineKeyboardButton("USDJPY", callback_data="instrument_USDJPY_sentiment")
-    ],
-    [
-        InlineKeyboardButton("AUDUSD", callback_data="instrument_AUDUSD_sentiment"),
-        InlineKeyboardButton("USDCAD", callback_data="instrument_USDCAD_sentiment"),
-        InlineKeyboardButton("EURGBP", callback_data="instrument_EURGBP_sentiment")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Forex keyboard voor kalender analyse
-FOREX_CALENDAR_KEYBOARD = [
-    [
-        InlineKeyboardButton("EURUSD", callback_data="instrument_EURUSD_calendar"),
-        InlineKeyboardButton("GBPUSD", callback_data="instrument_GBPUSD_calendar"),
-        InlineKeyboardButton("USDJPY", callback_data="instrument_USDJPY_calendar")
-    ],
-    [
-        InlineKeyboardButton("AUDUSD", callback_data="instrument_AUDUSD_calendar"),
-        InlineKeyboardButton("USDCAD", callback_data="instrument_USDCAD_calendar"),
-        InlineKeyboardButton("EURGBP", callback_data="instrument_EURGBP_calendar")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Crypto keyboard voor analyse
-CRYPTO_KEYBOARD = [
-    [
-        InlineKeyboardButton("BTCUSD", callback_data="instrument_BTCUSD_chart"),
-        InlineKeyboardButton("ETHUSD", callback_data="instrument_ETHUSD_chart"),
-        InlineKeyboardButton("XRPUSD", callback_data="instrument_XRPUSD_chart")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Signal analysis keyboard
-SIGNAL_ANALYSIS_KEYBOARD = [
-    [InlineKeyboardButton("Technical Analysis", callback_data="signal_technical")],
-    [InlineKeyboardButton("Market Sentiment", callback_data="signal_sentiment")],
-    [InlineKeyboardButton("Economic Calendar", callback_data="signal_calendar")],
-    [InlineKeyboardButton("Back", callback_data="back_to_signal")]
-]
-
-# Crypto keyboard voor sentiment analyse
-CRYPTO_SENTIMENT_KEYBOARD = [
-    [
-        InlineKeyboardButton("BTCUSD", callback_data="instrument_BTCUSD_sentiment"),
-        InlineKeyboardButton("ETHUSD", callback_data="instrument_ETHUSD_sentiment"),
-        InlineKeyboardButton("XRPUSD", callback_data="instrument_XRPUSD_sentiment")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Indices keyboard voor analyse
-INDICES_KEYBOARD = [
-    [
-        InlineKeyboardButton("US30", callback_data="instrument_US30_chart"),
-        InlineKeyboardButton("US500", callback_data="instrument_US500_chart"),
-        InlineKeyboardButton("US100", callback_data="instrument_US100_chart")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Indices keyboard voor signals - Fix de "Terug" knop naar "Back"
-INDICES_KEYBOARD_SIGNALS = [
-    [
-        InlineKeyboardButton("US30", callback_data="instrument_US30_signals"),
-        InlineKeyboardButton("US500", callback_data="instrument_US500_signals"),
-        InlineKeyboardButton("US100", callback_data="instrument_US100_signals")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Commodities keyboard voor analyse
-COMMODITIES_KEYBOARD = [
-    [
-        InlineKeyboardButton("GOLD", callback_data="instrument_XAUUSD_chart"),
-        InlineKeyboardButton("SILVER", callback_data="instrument_XAGUSD_chart"),
-        InlineKeyboardButton("OIL", callback_data="instrument_USOIL_chart")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Commodities keyboard voor signals - Fix de "Terug" knop naar "Back"
-COMMODITIES_KEYBOARD_SIGNALS = [
-    [
-        InlineKeyboardButton("XAUUSD", callback_data="instrument_XAUUSD_signals"),
-        InlineKeyboardButton("XAGUSD", callback_data="instrument_XAGUSD_signals"),
-        InlineKeyboardButton("USOIL", callback_data="instrument_USOIL_signals")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Forex keyboard for signals
-FOREX_KEYBOARD_SIGNALS = [
-    [
-        InlineKeyboardButton("EURUSD", callback_data="instrument_EURUSD_signals"),
-        InlineKeyboardButton("GBPUSD", callback_data="instrument_GBPUSD_signals"),
-        InlineKeyboardButton("USDJPY", callback_data="instrument_USDJPY_signals")
-    ],
-    [
-        InlineKeyboardButton("USDCAD", callback_data="instrument_USDCAD_signals"),
-        InlineKeyboardButton("EURGBP", callback_data="instrument_EURGBP_signals")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Crypto keyboard for signals
-CRYPTO_KEYBOARD_SIGNALS = [
-    [
-        InlineKeyboardButton("BTCUSD", callback_data="instrument_BTCUSD_signals"),
-        InlineKeyboardButton("ETHUSD", callback_data="instrument_ETHUSD_signals"),
-        InlineKeyboardButton("XRPUSD", callback_data="instrument_XRPUSD_signals")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Indices keyboard voor sentiment analyse
-INDICES_SENTIMENT_KEYBOARD = [
-    [
-        InlineKeyboardButton("US30", callback_data="instrument_US30_sentiment"),
-        InlineKeyboardButton("US500", callback_data="instrument_US500_sentiment"),
-        InlineKeyboardButton("US100", callback_data="instrument_US100_sentiment")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Commodities keyboard voor sentiment analyse
-COMMODITIES_SENTIMENT_KEYBOARD = [
-    [
-        InlineKeyboardButton("GOLD", callback_data="instrument_XAUUSD_sentiment"),
-        InlineKeyboardButton("SILVER", callback_data="instrument_XAGUSD_sentiment"),
-        InlineKeyboardButton("OIL", callback_data="instrument_USOIL_sentiment")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Style keyboard
-STYLE_KEYBOARD = [
-    [InlineKeyboardButton("‚ö° Test (one_min)", callback_data="style_test")],
-    [InlineKeyboardButton("üèÉ Scalp (fifteen_min)", callback_data="style_scalp")],
-    [InlineKeyboardButton(" Intraday (one_hour)", callback_data="style_intraday")],
-    [InlineKeyboardButton("üåä Swing (four_hour)", callback_data="style_swing")],
-    [InlineKeyboardButton("Back", callback_data="back_instrument")]
-]
-
-# Timeframe mapping
-STYLE_TIMEFRAME_MAP = {
-    "test": "one_min",
-    "scalp": "fifteen_min",
-    "intraday": "one_hour",
-    "swing": "four_hour"
-}
-
-# Mapping of instruments to their allowed timeframes - updated 2023-03-23
-INSTRUMENT_TIMEFRAME_MAP = {
-    # H1 timeframe only
-    "AUDJPY": "H1", 
-    "AUDCHF": "H1",
-    "EURCAD": "H1",
-    "EURGBP": "H1",
-    "GBPCHF": "H1",
-    "HK50": "H1",
-    "NZDJPY": "H1",
-    "USDCHF": "H1",
-    "USDJPY": "H1",  # USDJPY toegevoegd voor signaalabonnementen
-    "XRPUSD": "H1",
-    
-    # H4 timeframe only
-    "AUDCAD": "H4",
-    "AU200": "H4", 
-    "CADCHF": "H4",
-    "EURCHF": "H4",
-    "EURUSD": "H4",
-    "GBPCAD": "H4",
-    "LINKUSD": "H4",
-    "NZDCHF": "H4",
-    
-    # M15 timeframe only
-    "DOGEUSD": "M15",
-    "GBPNZD": "M15",
-    "NZDUSD": "M15",
-    "SOLUSD": "M15",
-    "UK100": "M15",
-    "XAUUSD": "M15",
-    
-    # M30 timeframe only
-    "BNBUSD": "M30",
-    "DOTUSD": "M30",
-    "ETHUSD": "M30",
-    "EURAUD": "M30",
-    "EURJPY": "M30",
-    "GBPAUD": "M30",
-    "GBPUSD": "M30",
-    "NZDCAD": "M30",
-    "US30": "M30",
-    "US500": "M30",
-    "USDCAD": "M30",
-    "XLMUSD": "M30",
-    "XTIUSD": "M30",
-    "DE40": "M30",
-    "BTCUSD": "M30",  # Added for consistency with CRYPTO_KEYBOARD_SIGNALS
-    "US100": "M30",   # Added for consistency with INDICES_KEYBOARD_SIGNALS
-    "XAGUSD": "M15",  # Added for consistency with COMMODITIES_KEYBOARD_SIGNALS
-    "USOIL": "M30"    # Added for consistency with COMMODITIES_KEYBOARD_SIGNALS
-    
-    # Removed as requested: EU50, FR40, LTCUSD
-}
-
-# Map common timeframe notations
-TIMEFRAME_DISPLAY_MAP = {
-    "M15": "15 Minutes",
-    "M30": "30 Minutes", 
-    "H1": "1 Hour",
-    "H4": "4 Hours"
-}
-
-# Voeg deze functie toe aan het begin van bot.py, na de imports
-    def _detect_market(instrument: str) -> str:
-    """Detecteer market type gebaseerd op instrument"""
-    instrument = instrument.upper()
-    
-    # Commodities eerst checken
-    commodities = [
-        "XAUUSD",  # Gold
-        "XAGUSD",  # Silver
-        "WTIUSD",  # Oil WTI
-        "BCOUSD",  # Oil Brent
-        "USOIL",   # Oil WTI (alternative symbol)
-    ]
-    if instrument in commodities:
-        logger.info(f"Detected {instrument} as commodity")
-        return "commodities"
-    
-    # Crypto pairs
-    crypto_base = ["BTC", "ETH", "XRP", "SOL", "BNB", "ADA", "DOT", "LINK"]
-    if any(c in instrument for c in crypto_base):
-        logger.info(f"Detected {instrument} as crypto")
-        return "crypto"
-    
-    # Major indices
-    indices = [
-        "US30", "US500", "US100",  # US indices
-        "UK100", "DE40", "FR40",   # European indices
-        "JP225", "AU200", "HK50"   # Asian indices
-    ]
-    if instrument in indices:
-        logger.info(f"Detected {instrument} as index")
-        return "indices"
-    
-    # Forex pairs als default
-    logger.info(f"Detected {instrument} as forex")
-    return "forex"
-
-# Voeg dit toe als decorator functie bovenaan het bestand na de imports
-    def require_subscription(func):
-    """Check if user has an active subscription"""
-    async def wrapper(self, update: Update, context: ContextTypes.DEFAULT_TYPE, *args, **kwargs):
-        user_id = update.effective_user.id
-        
-        # Check subscription status
-        is_subscribed = await self.db.is_user_subscribed(user_id)
-        
-        # Check if payment has failed
-        payment_failed = await self.db.has_payment_failed(user_id)
-        
-        if is_subscribed and not payment_failed:
-            # User has subscription, proceed with function
-            return await func(self, update, context, *args, **kwargs)
-        else:
-            if payment_failed:
-                # Show payment failure message
-                failed_payment_text = f"""
- <b>Subscription Payment Failed</b> 
-
-Your subscription payment could not be processed and your service has been deactivated.
-
-To continue using Sigmapips AI and receive trading signals, please reactivate your subscription by clicking the button below.
-                """
-                
-                # Use direct URL link for reactivation
-                reactivation_url = "https://buy.stripe.com/9AQcPf3j63HL5JS145"
-                
-                # Create button for reactivation
-                keyboard = [
-                    [InlineKeyboardButton("üîÑ Reactivate Subscription", url=reactivation_url)]
-                ]
-            else:
-                # Show subscription screen with the welcome message from the screenshot
-                failed_payment_text = f"""
- <b>Welcome to Sigmapips AI!</b> 
-
-<b>Discover powerful trading signals for various markets:</b>
-- <b>Forex</b> - Major and minor currency pairs
-- <b>Crypto</b> - Bitcoin, Ethereum and other top cryptocurrencies
-- <b>Indices</b> - Global market indices
-- <b>Commodities</b> - Gold, silver and oil
-
-<b>Features:</b>
- Real-time trading signals
-
- Multi-timeframe analysis (timeframes)
-
- Advanced chart analysis
-
- Sentiment indicators
-
- Economic calendar integration
-
-<b>Start today with a FREE 14-day trial!</b>
-                """
-                
-                # Use direct URL link instead of callback for the trial button
-                reactivation_url = "https://buy.stripe.com/3cs3eF9Hu9256NW9AA"
-                
-                # Create button for trial
-                keyboard = [
-                    [InlineKeyboardButton("üî• Start 14-day FREE Trial", url=reactivation_url)]
-                ]
-            
-            # Handle both message and callback query updates
-            if update.callback_query:
-                await update.callback_query.answer()
-                await update.callback_query.edit_message_text(
-                    text=failed_payment_text,
-                    reply_markup=InlineKeyboardMarkup(keyboard),
-                    parse_mode=ParseMode.HTML
-                )
-            else:
-                await update.message.reply_text(
-                    text=failed_payment_text,
-                    reply_markup=InlineKeyboardMarkup(keyboard),
-                    parse_mode=ParseMode.HTML
-                )
-            return MENU
-    
-    return wrapper
-
-# API keys with robust sanitization
-PERPLEXITY_API_KEY = os.getenv("PERPLEXITY_API_KEY", "").strip()
-OPENAI_API_KEY = os.getenv("OPENAI_API_KEY", "").strip()  # Changed from DeepSeek to OpenAI
-
-# Only using OpenAI's o4-mini now
-# No Tavily API key needed anymore
-logger.info("Using only OpenAI o4-mini for Market Sentiment service")
-
-# Log OpenAI API key (partially masked)
-if OPENAI_API_KEY:
-    # Better masking for privacy and security
-    masked_key = f"sk-p...{OPENAI_API_KEY[-4:]}" if len(OPENAI_API_KEY) > 8 else "sk-p..."
-    logger.info(f"Using OpenAI API key: {masked_key}")
-    
-    # Validate the key format
-    from trading_bot.config import validate_openai_key
-    if not validate_openai_key(OPENAI_API_KEY):
-        logger.warning("OpenAI API key format is invalid. AI services may not work correctly.")
-else:
-    logger.warning("No OpenAI API key configured. AI services will be disabled.")
-    
-# Set environment variables for the API keys with sanitization
-os.environ["PERPLEXITY_API_KEY"] = PERPLEXITY_API_KEY
-os.environ["OPENAI_API_KEY"] = OPENAI_API_KEY  # Changed from DeepSeek to OpenAI
-# No Tavily environment needed
-
-class TelegramService:
-    def __init__(self, db: Database, stripe_service=None, bot_token: Optional[str] = None, proxy_url: Optional[str] = None, lazy_init: bool = False):
-        """Initialize the bot with given database and config."""
-        # Database connection
-        self.db = db
-        
-        # Setup configuration 
-        self.stripe_service = stripe_service
-        self.user_signals = {}
-        self.signals_dir = "data/signals"
-        self.signals_enabled_val = True
-        self.polling_started = False
-        self.admin_users = [2004519703]  # Updated with correct Telegram ID from logs
-        self._signals_enabled = True  # Enable signals by default
-        
-        # Setup logger
-        self.logger = logging.getLogger(__name__)
-        
-        # GIF utilities for UI
-        self.gif_utils = gif_utils  # Initialize gif_utils as an attribute
-        
-        # Setup the bot and application
-        self.bot = None
-        self.application = None
-        
-        # Telegram Bot configuratie
-        self.bot_token = bot_token or os.getenv("TELEGRAM_BOT_TOKEN", "")
-        self.token = self.bot_token  # Aliased for backward compatibility
-        self.proxy_url = proxy_url or os.getenv("TELEGRAM_PROXY_URL", "")
-        
-        # Configure custom request handler with improved connection settings
-        request = HTTPXRequest(
-            connection_pool_size=50,  # Increase from 20 to 50
-            connect_timeout=15.0,     # Increase from 10.0 to 15.0
-            read_timeout=45.0,        # Increase from 30.0 to 45.0
-            write_timeout=30.0,       # Increase from 20.0 to 30.0
-            pool_timeout=60.0,        # Increase from 30.0 to 60.0
-        )
-        
-        # Initialize the bot directly with connection pool settings
-        self.bot = Bot(token=self.bot_token, request=request)
-        self.application = None  # Will be initialized in setup()
-        
-        # Webhook configuration
-        self.webhook_url = os.getenv("WEBHOOK_URL", "")
-        self.webhook_path = "/webhook"  # Always use this path
-        if self.webhook_url.endswith("/"):
-            self.webhook_url = self.webhook_url[:-1]  # Remove trailing slash
-            
-        logger.info(f"Bot initialized with webhook URL: {self.webhook_url} and path: {self.webhook_path}")
-        
-        # Initialize API services
-        self.chart_service = ChartService()  # Initialize chart service
-        # Lazy load services only when needed
-        self._calendar_service = None
-        self._sentiment_service = None
-        
-        # Don't use asyncio.create_task here - it requires a running event loop
-        # We'll initialize chart service later when the event loop is running
-        
-        # Bot application initialization
-        self.persistence = None
-        self.bot_started = False
-        
-        # Cache for sentiment analysis
-        self.sentiment_cache = {}
-        self.sentiment_cache_ttl = 60 * 60  # 1 hour in seconds
-        
-        # Start the bot
-    try:
-            # Check for bot token
-            if not self.bot_token:
-                raise ValueError("Missing Telegram bot token")
-            
-            # Initialize the bot
-            self.bot = Bot(token=self.bot_token)
-        
-            # Initialize the application
-            self.application = Application.builder().bot(self.bot).build()
-        
-            # Register the handlers
-            self._register_handlers(self.application)
-            
-            # Initialize signals dictionary but don't load them yet (will be done in initialize_services)
-            self.user_signals = {}
-        
-            logger.info("Telegram service initialized")
-            
-            # Keep track of processed updates
-            self.processed_updates = set()
-            
-    except Exception as e:
-        logger.error(f"Error initializing Telegram service: {str(e)}")
-        raise
-
-    async def initialize_services(self):
-        """Initialize services that require an asyncio event loop"""
-        try:
-            # Initialize chart service
-            await self.chart_service.initialize()
-            logger.info("Chart service initialized")
-            
-            # Load stored signals
-            await self._load_signals()
-            logger.info("Signals loaded")
-            
-            # Schedule periodic cleanup of old signals
-            if hasattr(self, 'db') and self.db and self.db.using_redis:
-                # Run initial cleanup
-                cleaned = await self._cleanup_old_signals(max_age_days=7)
-                logger.info(f"Initial signal cleanup completed, removed {cleaned} old signals")
-                
-                # Schedule periodic cleanup (every 24 hours)
-                async def periodic_cleanup():
-                    while True:
-                        try:
-                            # Wait for 24 hours
-                            await asyncio.sleep(24 * 60 * 60)
-                            # Run cleanup
-                            cleaned = await self._cleanup_old_signals(max_age_days=7)
-                            logger.info(f"Periodic signal cleanup completed, removed {cleaned} old signals")
-                        except Exception as e:
-                            logger.error(f"Error in periodic signal cleanup: {str(e)}")
-                
-                # Start the periodic cleanup task
-                asyncio.create_task(periodic_cleanup())
-                logger.info("Scheduled periodic signal cleanup")
-        except Exception as e:
-            logger.error(f"Error initializing services: {str(e)}")
-            raise
-            
-    # Calendar service helpers
-    @property
-    def calendar_service(self):
-        """Lazy loaded calendar service"""
-        if self._calendar_service is None:
-            # Only initialize the calendar service when it's first accessed
-            self.logger.info("Lazy loading calendar service")
-            self._calendar_service = EconomicCalendarService()
-        return self._calendar_service
-        
-    def _get_calendar_service(self):
-        """Get the calendar service instance"""
-        self.logger.info("Getting calendar service")
-        return self.calendar_service
-
-    async def _format_calendar_events(self, calendar_data):
-        """Format the calendar data into a readable HTML message"""
-        self.logger.info(f"Formatting calendar data with {len(calendar_data)} events")
-        if not calendar_data:
-            return "<b>Economic Calendar</b>\n\nNo economic events found for today."
-        
-        # Sort events by time
-        try:
-            # Try to parse time for sorting
-            def parse_time_for_sorting(event):
-                time_str = event.get('time', '')
-                try:
-                    # Extract hour and minute if in format like "08:30 EST"
-                    if ':' in time_str:
-                        parts = time_str.split(' ')[0].split(':')
-                        hour = int(parts[0])
-                        minute = int(parts[1])
-                        return hour * 60 + minute
-                    return 0
-                except:
-                    return 0
-            
-            # Sort the events by time
-            sorted_events = sorted(calendar_data, key=parse_time_for_sorting)
-        except Exception as e:
-            self.logger.error(f"Error sorting calendar events: {str(e)}")
-            sorted_events = calendar_data
-        
-        # Format the message
-        message = "<b>Economic Calendar</b>\n\n"
-        
-        # Get current date
-        current_date = datetime.now().strftime("%B %d, %Y")
-        message += f"<b>Date:</b> {current_date}\n\n"
-        
-        # Add impact legend
-        message += "<b>Impact:</b> üî¥ High   üü† Medium   üü¢ Low\n\n"
-        
-        # Group events by country
-        events_by_country = {}
-        for event in sorted_events:
-            country = event.get('country', 'Unknown')
-            if country not in events_by_country:
-                events_by_country[country] = []
-            events_by_country[country].append(event)
-        
-        # Format events by country
-        for country, events in events_by_country.items():
-            country_flag = CURRENCY_FLAG.get(country, '')
-            message += f"<b>{country_flag} {country}</b>\n"
-            
-            for event in events:
-                time = event.get('time', 'TBA')
-                title = event.get('title', 'Unknown Event')
-                impact = event.get('impact', 'Low')
-                impact_emoji = {'High': 'üî¥', 'Medium': 'üü†', 'Low': 'üü¢'}.get(impact, 'üü¢')
-                
-                message += f"{time} - {impact_emoji} {title}\n"
-            
-            message += "\n"  # Add extra newline between countries
-        
-        return message
-        
-    # Utility functions that might be missing
-    async def update_message(self, query, text, keyboard=None, parse_mode=ParseMode.HTML):
-        """Utility to update a message with error handling"""
-        try:
-            # Check if the message is too long for Telegram caption limits (1024 chars)
-            MAX_CAPTION_LENGTH = 1000  # Slightly under the 1024 limit for safety
-            MAX_MESSAGE_LENGTH = 4000  # Telegram message limit
-            
-            # Log message length for debugging
-            logger.info(f"Updating message (length: {len(text)} chars)")
-            
-            # If message is too long for a caption but ok for a text message
-            if len(text) > MAX_CAPTION_LENGTH and len(text) <= MAX_MESSAGE_LENGTH:
-                logger.info("Message too long for caption but ok for text message")
-                # Try to edit message text first
-                await query.edit_message_text(
-                    text=text,
-                    reply_markup=keyboard,
-                    parse_mode=parse_mode
-                )
-                return True
-            # If message is too long even for a text message
-            elif len(text) > MAX_MESSAGE_LENGTH:
-                logger.warning(f"Message too long ({len(text)} chars), truncating")
-                # Find a good breaking point
-                truncated = text[:MAX_MESSAGE_LENGTH-100]
-                
-                # Try to break at a paragraph
-                last_newline = truncated.rfind('\n\n')
-                if last_newline > MAX_MESSAGE_LENGTH * 0.8:  # If we can keep at least 80% of the text
-                    truncated = truncated[:last_newline]
-                    
-                # Add indicator that text was truncated
-                truncated += "\n\n<i>... (message truncated)</i>"
-                
-                # Try to edit message text with truncated content
-                await query.edit_message_text(
-                    text=truncated,
-                    reply_markup=keyboard,
-                    parse_mode=parse_mode
-                )
-                return True
-            else:
-                # Normal case - message is within limits
-                # Try to edit message text first
-                await query.edit_message_text(
-                    text=text,
-                    reply_markup=keyboard,
-                    parse_mode=parse_mode
-                )
-                return True
-        except Exception as e:
-            logger.warning(f"Could not update message text: {str(e)}")
-            
-            # If text update fails, try to edit caption
-            try:
-                # Check if caption is too long
-                MAX_CAPTION_LENGTH = 1000  # Slightly under the 1024 limit for safety
-                
-                if len(text) > MAX_CAPTION_LENGTH:
-                    logger.warning(f"Caption too long ({len(text)} chars), truncating")
-                    # Find a good breaking point
-                    truncated = text[:MAX_CAPTION_LENGTH-100]
-                    
-                    # Try to break at a paragraph
-                    last_newline = truncated.rfind('\n\n')
-                    if last_newline > MAX_CAPTION_LENGTH * 0.8:  # If we can keep at least 80% of the text
-                        truncated = truncated[:last_newline]
-                        
-                    # Add indicator that text was truncated
-                    truncated += "\n\n<i>... (message truncated)</i>"
-                    
-                    # Use truncated text for caption
-                    await query.edit_message_caption(
-                        caption=truncated,
-                        reply_markup=keyboard,
-                        parse_mode=parse_mode
-                    )
-                else:
-                    # Caption is within limits
-                    await query.edit_message_caption(
-                        caption=text,
-                        reply_markup=keyboard,
-                        parse_mode=parse_mode
-                    )
-                return True
-            except Exception as e2:
-                logger.error(f"Could not update caption either: {str(e2)}")
-                
-                # As a last resort, send a new message
-                try:
-                    chat_id = query.message.chat_id
-                    
-                    # Check if message is too long
-                    MAX_MESSAGE_LENGTH = 4000  # Telegram message limit
-                    
-                    if len(text) > MAX_MESSAGE_LENGTH:
-                        logger.warning(f"New message too long ({len(text)} chars), truncating")
-                        # Find a good breaking point
-                        truncated = text[:MAX_MESSAGE_LENGTH-100]
-                        
-                        # Try to break at a paragraph
-                        last_newline = truncated.rfind('\n\n')
-                        if last_newline > MAX_MESSAGE_LENGTH * 0.8:  # If we can keep at least 80% of the text
-                            truncated = truncated[:last_newline]
-                            
-                        # Add indicator that text was truncated
-                        truncated += "\n\n<i>... (message truncated)</i>"
-                        
-                        # Use truncated text for new message
-                        await query.bot.send_message(
-                            chat_id=chat_id,
-                            text=truncated,
-                            reply_markup=keyboard,
-                            parse_mode=parse_mode
-                        )
-                    else:
-                        # Message is within limits
-                        await query.bot.send_message(
-                            chat_id=chat_id,
-                            text=text,
-                            reply_markup=keyboard,
-                            parse_mode=parse_mode
-                        )
-                    return True
-                except Exception as e3:
-                    logger.error(f"Failed to send new message: {str(e3)}")
-                    return False
-    
-    # Missing handler implementations
-    async def back_signals_callback(self, update: Update, context=None) -> int:
-        """Handle back_signals button press"""
-        query = update.callback_query
-        await query.answer()
-        
-        logger.info("back_signals_callback called")
-        
-        # Make sure we're in the signals flow context
-        if context and hasattr(context, 'user_data'):
-            # Reset signal flow flags
-            context.user_data['from_signal'] = False
-            context.user_data['in_signal_flow'] = False
-            logger.info(f"Reset signal flow flags: from_signal=False, in_signal_flow=False")
-            # Keep is_signals_context flag but reset from_signal flag
-            context.user_data['is_signals_context'] = True
-            context.user_data['from_signal'] = False
-            
-            # Clear other specific analysis keys but maintain signals context
-            keys_to_remove = [
-                'instrument', 'market', 'analysis_type', 'timeframe', 
-                'signal_id', 'signal_instrument', 'signal_direction', 'signal_timeframe',
-                'loading_message'
-            ]
-
-            for key in keys_to_remove:
-                if key in context.user_data:
-                    del context.user_data[key]
-            logger.info(f"Updated context in back_signals_callback: {context.user_data}")
-        
-        # Create keyboard for signal menu
-        keyboard = [
-            [InlineKeyboardButton(" Add Signal", callback_data="signals_add")],
-            [InlineKeyboardButton("Manage Signals", callback_data="signals_manage")],
-            [InlineKeyboardButton("Back to Menu", callback_data="back_menu")]
-        ]
-        reply_markup = InlineKeyboardMarkup(keyboard)
-        
-        # Get the signals GIF URL for better UX
-        signals_gif_url = "https://media.giphy.com/media/gSzIKNrqtotEYrZv7i/giphy.gif"
-        
-        # Update the message
-        await self.update_message(
-            query=query,\n            text="<b> Signal Management</b>\n\nManage your trading signals",
-            keyboard=reply_markup
-        )
-        
-        return SIGNALS
-        
-    async def get_subscribers_for_instrument(self, instrument: str, timeframe: str = None) -> List[int]:
-        """
-        Get a list of subscribed user IDs for a specific instrument and timeframe
-        
-        Args:
-            instrument: The trading instrument (e.g., EURUSD)
-            timeframe: Optional timeframe filter
-            
-        Returns:
-            List of subscribed user IDs
-        """
-    try:
-            logger.info(f"Getting subscribers for {instrument} timeframe: {timeframe}")
-            
-            # Get all subscribers from the database
-            # Note: Using get_signal_subscriptions instead of find_all
-            subscribers = await self.db.get_signal_subscriptions(instrument, timeframe)
-            
-            if not subscribers:
-                logger.warning(f"No subscribers found for {instrument}")
-                return []
-                
-            # Filter out subscribers that don't have an active subscription
-            active_subscribers = []
-            for subscriber in subscribers:
-                user_id = subscriber['user_id']
-                
-                # Check if user is subscribed
-                is_subscribed = await self.db.is_user_subscribed(user_id)
-                
-                # Check if payment has failed
-                payment_failed = await self.db.has_payment_failed(user_id)
-                
-                if is_subscribed and not payment_failed:
-                    active_subscribers.append(user_id)
-                else:
-                    logger.info(f"User {user_id} doesn't have an active subscription, skipping signal")
-            
-            return active_subscribers
-            
-    except Exception as e:
-        logger.error(f"Error getting subscribers: {str(e)}")
-            # FOR TESTING: Add admin users if available
-            if hasattr(self, 'admin_users') and self.admin_users:
-                logger.info(f"Returning admin users for testing: {self.admin_users}")
-                return self.admin_users
-            return []
-
-    async def process_signal(self, signal_data: Dict[str, Any]) -> bool:
-        """
-        Process a trading signal from TradingView webhook or API
-        
-        Supports two formats:
-        1. TradingView format: instrument, signal, price, sl, tp1, tp2, tp3, interval
-        2. Custom format: instrument, direction, entry, stop_loss, take_profit, timeframe
-        
-        Returns:
-            bool: True if signal was processed successfully, False otherwise
-        """
-        try:
-            # Log the incoming signal data
-            logger.info(f"Processing signal: {signal_data}")
-            
-            # Check which format we're dealing with and normalize it
-            instrument = signal_data.get('instrument')
-            
-            # Handle TradingView format (price, sl, interval)
-            if 'price' in signal_data and 'sl' in signal_data:
-                price = signal_data.get('price')
-                sl = signal_data.get('sl')
-                tp1 = signal_data.get('tp1')
-                tp2 = signal_data.get('tp2')
-                tp3 = signal_data.get('tp3')
-                interval = signal_data.get('interval', 'one_hour')
-                
-                # Determine signal direction based on price and SL relationship
-                direction = "BUY" if float(sl) < float(price) else "SELL"
-                
-                # Create normalized signal data
-                normalized_data = {
-                    'instrument': instrument,
-                    'direction': direction,
-                    'entry': price,
-                    'stop_loss': sl,
-                    'take_profit': tp1,  # Use first take profit level
-                    'timeframe': interval
-                }
-                
-                # Add optional fields if present
-                normalized_data['tp1'] = tp1
-                normalized_data['tp2'] = tp2
-                normalized_data['tp3'] = tp3
-                
-            # Handle custom format (direction, entry, stop_loss, timeframe)
-            elif 'direction' in signal_data and 'entry' in signal_data:
-                direction = signal_data.get('direction')
-                entry = signal_data.get('entry')
-                stop_loss = signal_data.get('stop_loss')
-                take_profit = signal_data.get('take_profit')
-                timeframe = signal_data.get('timeframe', 'one_hour')
-                
-                # Create normalized signal data
-                normalized_data = {
-                    'instrument': instrument,
-                    'direction': direction,
-                    'entry': entry,
-                    'stop_loss': stop_loss,
-                    'take_profit': take_profit,
-                    'timeframe': timeframe
-                }
-            else:
-                logger.error(f"Missing required signal data")
-                return False
-            
-            # Basic validation
-            if not normalized_data.get('instrument') or not normalized_data.get('direction') or not normalized_data.get('entry'):
-                logger.error(f"Missing required fields in normalized signal data: {normalized_data}")
-                return False
-                
-            # Create signal ID for tracking
-            signal_id = f"{normalized_data['instrument']}_{normalized_data['direction']}_{normalized_data['timeframe']}_{int(time.time())}"
-            
-            # Format the signal message
-            message = self._format_signal_message(normalized_data)
-            
-            # Determine market type for the instrument
-            market_type = _detect_market(instrument)
-            
-            # Store the full signal data for reference
-            normalized_data['id'] = signal_id
-            normalized_data['timestamp'] = datetime.now().isoformat()
-            normalized_data['message'] = message
-            normalized_data['market'] = market_type
-            
-            # Save signal for history tracking
-            if not os.path.exists(self.signals_dir):
-                os.makedirs(self.signals_dir, exist_ok=True)
-                
-            # Save to signals directory
-            with open(f"{self.signals_dir}/{signal_id}.json", 'w') as f:
-                json.dump(normalized_data, f)
-            
-            # FOR TESTING: Always send to admin for testing
-            if hasattr(self, 'admin_users') and self.admin_users:
-                try:
-                    logger.info(f"Sending signal to admin users for testing: {self.admin_users}")
-                    for admin_id in self.admin_users:
-                        # Prepare keyboard with analysis options
-                        keyboard = [
-                            [InlineKeyboardButton("Analyze Market", callback_data=f"analyze_from_signal_{instrument}_{signal_id}")]
-                        ]
-                        
-                        # Send the signal
-                        await self.bot.send_message(
-                            chat_id=admin_id,
-                            text=message,
-                            parse_mode=ParseMode.HTML,
-                            reply_markup=InlineKeyboardMarkup(keyboard)
-                        )
-                        logger.info(f"Test signal sent to admin {admin_id}")
-                        
-                        # Store signal reference for quick access
-                        if not hasattr(self, 'user_signals'):
-                            self.user_signals = {}
-                            
-                        admin_str_id = str(admin_id)
-                        if admin_str_id not in self.user_signals:
-                            self.user_signals[admin_str_id] = {}
-                        
-                        self.user_signals[admin_str_id][signal_id] = normalized_data
-            except Exception as e:
-                logger.error(f"Error sending test signal to admin: {str(e)}")
-            
-            # Get subscribers for this instrument
-            timeframe = normalized_data.get('timeframe', 'one_hour')
-            subscribers = await self.get_subscribers_for_instrument(instrument, timeframe)
-            
-            if not subscribers:
-                logger.warning(f"No subscribers found for {instrument}")
-                return True  # Successfully processed, just no subscribers
-            
-            # Send signal to all subscribers
-            logger.info(f"Sending signal {signal_id} to {len(subscribers)} subscribers")
-            
-            sent_count = 0
-            for user_id in subscribers:
-                try:
-                    # Prepare keyboard with analysis options
-                    keyboard = [
-                        [InlineKeyboardButton("Analyze Market", callback_data=f"analyze_from_signal_{instrument}_{signal_id}")]
-                    ]
-                    
-                    # Send the signal
-                    await self.bot.send_message(
-                        chat_id=user_id,
-                        text=message,
-                        parse_mode=ParseMode.HTML,
-                        reply_markup=InlineKeyboardMarkup(keyboard)
-                    )
-                    
-                    sent_count += 1
-                    
-                    # Store signal reference for quick access
-                    if not hasattr(self, 'user_signals'):
-                        self.user_signals = {}
-                        
-                    user_str_id = str(user_id)
-                    if user_str_id not in self.user_signals:
-                        self.user_signals[user_str_id] = {}
-                    
-                    self.user_signals[user_str_id][signal_id] = normalized_data
-                    
-            except Exception as e:
-                logger.error(f"Error sending signal to user {user_id}: {str(e)}")
-            
-            logger.info(f"Successfully sent signal {signal_id} to {sent_count}/{len(subscribers)} subscribers")
-            return True
-            
-    except Exception as e:
-        logger.error(f"Error processing signal: {str(e)}")
-        logger.exception(e)
-            return False
-
-    def _format_signal_message(self, signal_data: Dict[str, Any]) -> str:
-        """Format signal data into a nice message for Telegram"""
-    try:
-            # Extract fields from signal data
-            instrument = signal_data.get('instrument', 'Unknown')
-            direction = signal_data.get('direction', 'Unknown')
-            entry = signal_data.get('entry', 'Unknown')
-            stop_loss = signal_data.get('stop_loss')
-            take_profit = signal_data.get('take_profit')
-            timeframe = signal_data.get('timeframe', 'one_hour')
-            
-            # Get multiple take profit levels if available
-            tp1 = signal_data.get('tp1', take_profit)
-            tp2 = signal_data.get('tp2')
-            tp3 = signal_data.get('tp3')
-            
-            # Add emoji based on direction
-            direction_emoji = "üü¢" if direction.upper() == "BUY" else "üî¥"
-            
-            # Format the message with multiple take profits if available
-            message = "<b> New Trading Signal </b>\n"\n\n"
-            message += f"<b>Instrument:</b> {instrument}\n"
-            message += f"<b>Action:</b> {direction.upper()} {direction_emoji}\n\n"
-            message += f"<b>Entry Price:</b> {entry}\n"
-            
-            if stop_loss:
-                message += f"<b>Stop Loss:</b> {stop_loss} üî¥\n"
-            
-            # Add take profit levels
-            if tp1:
-                message += f"<b>Take Profit 1:</b> {tp1} \n"
-            if tp2:
-                message += f"<b>Take Profit 2:</b> {tp2} \n"
-            if tp3:
-                message += f"<b>Take Profit 3:</b> {tp3} \n"
-            
-            message += f"\n<b>Timeframe:</b> {timeframe}\n"
-            message += f"<b>Strategy:</b> TradingView Signal\n\n"
-            
-            message += "‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî\n\n"
-            message += "<b>Risk Management:</b>\n"
-            message += "- Position size: 1-2% max\n"
-            message += "- Use proper stop loss\n"
-            message += "- Follow your trading plan\n\n"
-            
-            message += "‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî\n\n"
-            
-            # Generate AI verdict
-            ai_verdict = f"The {instrument} {direction.lower()} signal shows a promising setup with defined entry at {entry} and stop loss at {stop_loss}. Multiple take profit levels provide opportunities for partial profit taking."
-            message += f"<b>ü§ñ SigmaPips AI Verdict:</b>\n{ai_verdict}"
-            
-            return message
-            
-    except Exception as e:
-        logger.error(f"Error formatting signal message: {str(e)}")
-            # Return simple message on error
-            return f"New {signal_data.get('instrument', 'Unknown')} {signal_data.get('direction', 'Unknown')} Signal"
-
-    def _register_handlers(self, application):
-        """Register event handlers for bot commands and callback queries"""
-    try:
-            logger.info("Registering command handlers")
-            
-            # Initialize the application without using run_until_complete
-        try:
-                # Instead of using loop.run_until_complete, directly call initialize 
-                # which will be properly awaited by the caller
-                self.init_task = application.initialize()
-                logger.info("Telegram application initialization ready to be awaited")
-            except Exception as init_e:
-            logger.error(f"Error during application initialization: {str(init_e)}")
-            logger.exception(init_e)
-                
-            # Set bot commands for menu
-            commands = [
-                BotCommand("start", "Start the bot and get the welcome message"),
-                BotCommand("menu", "Show the main menu"),
-                BotCommand("help", "Show available commands and how to use the bot")
-            ]
-            
-            # Store the set_commands_task to be awaited later
-        try:
-                # Instead of asyncio.create_task, we will await this in the startup event
-                self.set_commands_task = self.bot.set_my_commands(commands)
-                logger.info("Bot commands ready to be set")
-            except Exception as cmd_e:
-            logger.error(f"Error preparing bot commands: {str(cmd_e)}")
-            
-            # Register command handlers
-            application.add_handler(CommandHandler("start", self.start_command))
-            application.add_handler(CommandHandler("menu", self.menu_command))
-            application.add_handler(CommandHandler("help", self.help_command))
-            
-            # Register secret admin commands
-            application.add_handler(CommandHandler("set_subscription", self.set_subscription_command))
-            application.add_handler(CommandHandler("set_payment_failed", self.set_payment_failed_command))
-            logger.info("Registered secret admin commands")
-            
-            # Register callback handlers
-            application.add_handler(CallbackQueryHandler(self.menu_analyse_callback, pattern="^menu_analyse$"))
-            application.add_handler(CallbackQueryHandler(self.menu_signals_callback, pattern="^menu_signals$"))
-            application.add_handler(CallbackQueryHandler(self.signals_add_callback, pattern="^signals_add$"))
-            application.add_handler(CallbackQueryHandler(self.signals_manage_callback, pattern="^signals_manage$"))
-            application.add_handler(CallbackQueryHandler(self.market_callback, pattern="^market_"))
-            application.add_handler(CallbackQueryHandler(self.instrument_callback, pattern="^instrument_(?!.*_signals)"))
-            application.add_handler(CallbackQueryHandler(self.instrument_signals_callback, pattern="^instrument_.*_signals$"))
-            
-            # Add handler for back buttons
-            application.add_handler(CallbackQueryHandler(self.back_market_callback, pattern="^back_market$"))
-            application.add_handler(CallbackQueryHandler(self.back_instrument_callback, pattern="^back_instrument$"))
-            application.add_handler(CallbackQueryHandler(self.back_signals_callback, pattern="^back_signals$"))
-            application.add_handler(CallbackQueryHandler(self.back_menu_callback, pattern="^back_menu$"))
-            
-            # Analysis handlers for regular flow
-            application.add_handler(CallbackQueryHandler(self.analysis_technical_callback, pattern="^analysis_technical$"))
-            application.add_handler(CallbackQueryHandler(self.analysis_sentiment_callback, pattern="^analysis_sentiment$"))
-            application.add_handler(CallbackQueryHandler(self.analysis_calendar_callback, pattern="^analysis_calendar$"))
-            
-            # Analysis handlers for signal flow - with instrument embedded in callback
-            application.add_handler(CallbackQueryHandler(self.signal_technical_callback, pattern="^signal_flow_technical_.*$"))
-            application.add_handler(CallbackQueryHandler(self.signal_sentiment_callback, pattern="^signal_flow_sentiment_.*$"))
-            application.add_handler(CallbackQueryHandler(self.signal_calendar_callback, pattern="^signal_flow_calendar_.*$"))
-            
-            # Analysis handlers for signal flow - with instrument embedded in callback
-            application.add_handler(CallbackQueryHandler(self.signal_technical_callback, pattern="^signal_flow_technical_.*$"))
-            application.add_handler(CallbackQueryHandler(self.signal_sentiment_callback, pattern="^signal_flow_sentiment_.*$"))
-            application.add_handler(CallbackQueryHandler(self.analysis_calendar_callback, pattern="^signal_flow_calendar_.*$"))
-            
-            # Signal analysis flow handlers
-            application.add_handler(CallbackQueryHandler(self.signal_technical_callback, pattern="^signal_technical$"))
-            application.add_handler(CallbackQueryHandler(self.signal_sentiment_callback, pattern="^signal_sentiment$"))
-            application.add_handler(CallbackQueryHandler(self.signal_calendar_callback, pattern="^signal_calendar$"))
-            application.add_handler(CallbackQueryHandler(self.signal_calendar_callback, pattern="^signal_flow_calendar_.*$"))
-            application.add_handler(CallbackQueryHandler(self.back_to_signal_callback, pattern="^back_to_signal$"))
-            application.add_handler(CallbackQueryHandler(self.back_to_signal_analysis_callback, pattern="^back_to_signal_analysis$"))
-            
-            # Signal from analysis
-            application.add_handler(CallbackQueryHandler(self.analyze_from_signal_callback, pattern="^analyze_from_signal_.*$"))
-            
-            # Ensure back_instrument is properly handled
-            application.add_handler(CallbackQueryHandler(self.back_instrument_callback, pattern="^back_instrument$"))
-            
-            # Catch-all handler for any other callbacks
-            application.add_handler(CallbackQueryHandler(self.button_callback))
-            
-            # Don't load signals here - it will be done in initialize_services
-            # self._load_signals()
-            
-            logger.info("Bot setup completed successfully")
-            
-    except Exception as e:
-        logger.error(f"Error setting up bot handlers: {str(e)}")
-        logger.exception(e)
-
-    @property
-    def signals_enabled(self):
-        """Get whether signals processing is enabled"""
-        return self._signals_enabled
-    
-    @signals_enabled.setter
-    def signals_enabled(self, value):
-        """Set whether signals processing is enabled"""
-        self._signals_enabled = bool(value)
-        logger.info(f"Signal processing is now {'enabled' if value else 'disabled'}")
-
-        async def start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE = None) -> None:
-        """Send a welcome message when the bot is started."""
-        user = update.effective_user
-        user_id = user.id
-        first_name = user.first_name
-        
-        # Try to add the user to the database if they don't exist yet
-    try:
-            # Get user subscription since we can't check if user exists directly
-            existing_subscription = await self.db.get_user_subscription(user_id)
-            
-            if not existing_subscription:
-                # Add new user
-                logger.info(f"New user started: {user_id}, {first_name}")
-                await self.db.save_user(user_id, first_name, None, user.username)
-        else:
-                logger.info(f"Existing user started: {user_id}, {first_name}")
-                
-# Import necessary modules for improved logging
-import os
-import sys
-import json
-import logging
-import logging.config
-from datetime import datetime
-
-
-    async def _get_signal_related_trades(self, signal_id):
-    """Retrieve related trades from the database"""
-    try:
-        # Fetch the related trades data from the database
-        trades_data = await self.db.get_related_trades(signal_id)
-        
-        if trades_data:
-            return trades_data
-        else:
-            logger.warning(f"No related trades data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related trades: {str(e)}")
-        logger.exception(e)
-        return None
-
-
-from telegram.error import TelegramError, BadRequest
-import httpx
-import telegram.error  # Add this import for BadRequest error handling
-
-from trading_bot.services.database.db import Database
-from trading_bot.services.chart_service.chart import ChartService
-from trading_bot.services.sentiment_service.sentiment import MarketSentimentService
-from trading_bot.services.calendar_service import EconomicCalendarService
-from trading_bot.services.payment_service.stripe_service import StripeService
-from trading_bot.services.payment_service.stripe_config import get_subscription_features
-from trading_bot.services.telegram_service.states import (
-    MENU, ANALYSIS, SIGNALS, CHOOSE_MARKET, CHOOSE_INSTRUMENT, CHOOSE_STYLE,
-    CHOOSE_ANALYSIS, SIGNAL_DETAILS,
-    CALLBACK_MENU_ANALYSE, CALLBACK_MENU_SIGNALS, CALLBACK_ANALYSIS_TECHNICAL,
-    CALLBACK_ANALYSIS_SENTIMENT, CALLBACK_ANALYSIS_CALENDAR, CALLBACK_SIGNALS_ADD,
-    CALLBACK_SIGNALS_MANAGE, CALLBACK_BACK_MENU
-)
-import trading_bot.services.telegram_service.gif_utils as gif_utils
-
-# Initialize logger
-logger = logging.getLogger(__name__)
-
-# Major currencies to focus on
-MAJOR_CURRENCIES = ["USD", "EUR", "GBP", "JPY", "CHF", "AUD", "NZD", "CAD"]
-
-# Currency to flag emoji mapping
-CURRENCY_FLAG = {
-    "USD": "üá∫üá∏",
-    "EUR": "üá™üá∫",
-    "GBP": "üá¨üáß",
-    "JPY": "üáØüáµ",
-    "CHF": "üá®üá≠",
-    "AUD": "üá¶üá∫",
-    "NZD": "üá≥üáø",
-    "CAD": "üá®üá¶"
-}
-
-# Map of instruments to their corresponding currencies
-INSTRUMENT_CURRENCY_MAP = {
-    # Special case for global view
-    "GLOBAL": MAJOR_CURRENCIES,
-    
-    # Forex
-    "EURUSD": ["EUR", "USD"],
-    "GBPUSD": ["GBP", "USD"],
-    "USDJPY": ["USD", "JPY"],
-    "USDCHF": ["USD", "CHF"],
-    "AUDUSD": ["AUD", "USD"],
-    "NZDUSD": ["NZD", "USD"],
-    "USDCAD": ["USD", "CAD"],
-    "EURGBP": ["EUR", "GBP"],
-    "EURJPY": ["EUR", "JPY"],
-    "GBPJPY": ["GBP", "JPY"],
-    
-    # Indices (mapped to their related currencies)
-    "US30": ["USD"],
-    "US100": ["USD"],
-    "US500": ["USD"],
-    "UK100": ["GBP"],
-    "GER40": ["EUR"],
-    "FRA40": ["EUR"],
-    "ESP35": ["EUR"],
-    "JP225": ["JPY"],
-    "AUS200": ["AUD"],
-    
-    # Commodities (mapped to USD primarily)
-    "XAUUSD": ["USD", "XAU"],  # Gold
-    "XAGUSD": ["USD", "XAG"],  # Silver
-    "USOIL": ["USD"],          # Oil (WTI)
-    "UKOIL": ["USD", "GBP"],   # Oil (Brent)
-    
-    # Crypto
-    "BTCUSD": ["USD", "BTC"],
-    "ETHUSD": ["USD", "ETH"],
-    "LTCUSD": ["USD", "LTC"],
-    "XRPUSD": ["USD", "XRP"]
-}
-
-# Callback data constants
-CALLBACK_ANALYSIS_TECHNICAL = "analysis_technical"
-CALLBACK_ANALYSIS_SENTIMENT = "analysis_sentiment"
-CALLBACK_ANALYSIS_CALENDAR = "analysis_calendar"
-CALLBACK_BACK_MENU = "back_menu"
-CALLBACK_BACK_ANALYSIS = "back_to_analysis"
-CALLBACK_BACK_MARKET = "back_market"
-CALLBACK_BACK_INSTRUMENT = "back_instrument"
-CALLBACK_BACK_SIGNALS = "back_signals"
-CALLBACK_SIGNALS_ADD = "signals_add"
-CALLBACK_SIGNALS_MANAGE = "signals_manage"
-CALLBACK_MENU_ANALYSE = "menu_analyse"
-CALLBACK_MENU_SIGNALS = "menu_signals"
-
-# States
-MENU = 0
-CHOOSE_ANALYSIS = 1
-CHOOSE_SIGNALS = 2
-CHOOSE_MARKET = 3
-CHOOSE_INSTRUMENT = 4
-CHOOSE_STYLE = 5
-SHOW_RESULT = 6
-CHOOSE_TIMEFRAME = 7
-SIGNAL_DETAILS = 8
-SIGNAL = 9
-SUBSCRIBE = 10
-BACK_TO_MENU = 11  # Add this line
-
-# Messages
-WELCOME_MESSAGE = r"""
-<b>Sigmapips AI - Main Menu</b>
-
-Choose an option to access advanced trading support:
-
-Services:
-- <b>Technical Analysis</b> - Real-time chart analysis and key levels
-
-- <b>Market Sentiment</b> - Understand market trends and sentiment
-
-- <b>Economic Calendar</b> - Stay updated on market-moving events
-
-- <b>Trading Signals</b> - Get precise entry/exit points for your favorite pairs
-
-Select your option to continue:
-"""
-
-# Abonnementsbericht voor nieuwe gebruikers
-SUBSCRIPTION_WELCOME_MESSAGE = r"""
-<b>Welcome to Sigmapips AI!</b>
-
-To access all features, you need a subscription:
-
-<b>Trading Signals Subscription - $29.99/month</b>
-- Access to all trading signals (Forex, Crypto, Commodities, Indices)
-- Advanced timeframe analysis
-- Detailed chart analysis for each signal
-
-Click the button below to subscribe:
-"""
-
-MENU_MESSAGE = r"""
-Welcome to Sigmapips AI!
-
-Choose a command:
-
-/start - Set up new trading pairs
-Add new market/instrument/timeframe combinations to receive signals
-
-/manage - Manage your preferences
-View, edit or delete your saved trading pairs
-
-Need help? Use /help to see all available commands.
-"""
-
-HELP_MESSAGE = r"""
-Available commands:
-/menu - Show main menu
-/start - Set up new trading pairs
-/help - Show this help message
-"""
-
-# Start menu keyboard
-START_KEYBOARD = [
-    [InlineKeyboardButton("Analyze Market", callback_data=CALLBACK_MENU_ANALYSE)],
-    [InlineKeyboardButton("Trading Signals", callback_data=CALLBACK_MENU_SIGNALS)]
-]
-
-# Analysis menu keyboard
-ANALYSIS_KEYBOARD = [
-    [InlineKeyboardButton("Technical Analysis", callback_data=CALLBACK_ANALYSIS_TECHNICAL)],
-    [InlineKeyboardButton("Market Sentiment", callback_data=CALLBACK_ANALYSIS_SENTIMENT)],
-    [InlineKeyboardButton("Economic Calendar", callback_data=CALLBACK_ANALYSIS_CALENDAR)],
-    [InlineKeyboardButton("Back", callback_data=CALLBACK_BACK_MENU)]
-]
-
-# Signals menu keyboard
-SIGNALS_KEYBOARD = [
-    [InlineKeyboardButton("Add New Pairs", callback_data=CALLBACK_SIGNALS_ADD)],
-    [InlineKeyboardButton("Manage Signals", callback_data=CALLBACK_SIGNALS_MANAGE)],
-    [InlineKeyboardButton("Back", callback_data=CALLBACK_BACK_MENU)]
-]
-
-# Market keyboard voor signals
-MARKET_KEYBOARD_SIGNALS = [
-    [InlineKeyboardButton("Forex", callback_data="market_forex_signals")],
-    [InlineKeyboardButton("Crypto", callback_data="market_crypto_signals")],
-    [InlineKeyboardButton("Commodities", callback_data="market_commodities_signals")],
-    [InlineKeyboardButton("Indices", callback_data="market_indices_signals")],
-    [InlineKeyboardButton("Back", callback_data="back_signals")]
-]
-
-# Market keyboard voor analyse
-MARKET_KEYBOARD = [
-    [InlineKeyboardButton("Forex", callback_data="market_forex")],
-    [InlineKeyboardButton("Crypto", callback_data="market_crypto")],
-    [InlineKeyboardButton("Commodities", callback_data="market_commodities")],
-    [InlineKeyboardButton("Indices", callback_data="market_indices")],
-    [InlineKeyboardButton("Back", callback_data="back_analysis")]
-]
-
-# Market keyboard specifiek voor sentiment analyse
-MARKET_SENTIMENT_KEYBOARD = [
-    [InlineKeyboardButton("Forex", callback_data="market_forex_sentiment")],
-    [InlineKeyboardButton("Crypto", callback_data="market_crypto_sentiment")],
-    [InlineKeyboardButton("Commodities", callback_data="market_commodities_sentiment")],
-    [InlineKeyboardButton("Indices", callback_data="market_indices_sentiment")],
-    [InlineKeyboardButton("Back", callback_data="back_analysis")]
-]
-
-# Forex keyboard voor technical analyse
-FOREX_KEYBOARD = [
-    [
-        InlineKeyboardButton("EURUSD", callback_data="instrument_EURUSD_chart"),
-        InlineKeyboardButton("GBPUSD", callback_data="instrument_GBPUSD_chart"),
-        InlineKeyboardButton("USDJPY", callback_data="instrument_USDJPY_chart")
-    ],
-    [
-        InlineKeyboardButton("AUDUSD", callback_data="instrument_AUDUSD_chart"),
-        InlineKeyboardButton("USDCAD", callback_data="instrument_USDCAD_chart"),
-        InlineKeyboardButton("EURGBP", callback_data="instrument_EURGBP_chart")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Forex keyboard voor sentiment analyse
-FOREX_SENTIMENT_KEYBOARD = [
-    [
-        InlineKeyboardButton("EURUSD", callback_data="instrument_EURUSD_sentiment"),
-        InlineKeyboardButton("GBPUSD", callback_data="instrument_GBPUSD_sentiment"),
-        InlineKeyboardButton("USDJPY", callback_data="instrument_USDJPY_sentiment")
-    ],
-    [
-        InlineKeyboardButton("AUDUSD", callback_data="instrument_AUDUSD_sentiment"),
-        InlineKeyboardButton("USDCAD", callback_data="instrument_USDCAD_sentiment"),
-        InlineKeyboardButton("EURGBP", callback_data="instrument_EURGBP_sentiment")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Forex keyboard voor kalender analyse
-FOREX_CALENDAR_KEYBOARD = [
-    [
-        InlineKeyboardButton("EURUSD", callback_data="instrument_EURUSD_calendar"),
-        InlineKeyboardButton("GBPUSD", callback_data="instrument_GBPUSD_calendar"),
-        InlineKeyboardButton("USDJPY", callback_data="instrument_USDJPY_calendar")
-    ],
-    [
-        InlineKeyboardButton("AUDUSD", callback_data="instrument_AUDUSD_calendar"),
-        InlineKeyboardButton("USDCAD", callback_data="instrument_USDCAD_calendar"),
-        InlineKeyboardButton("EURGBP", callback_data="instrument_EURGBP_calendar")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Crypto keyboard voor analyse
-CRYPTO_KEYBOARD = [
-    [
-        InlineKeyboardButton("BTCUSD", callback_data="instrument_BTCUSD_chart"),
-        InlineKeyboardButton("ETHUSD", callback_data="instrument_ETHUSD_chart"),
-        InlineKeyboardButton("XRPUSD", callback_data="instrument_XRPUSD_chart")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Signal analysis keyboard
-SIGNAL_ANALYSIS_KEYBOARD = [
-    [InlineKeyboardButton("Technical Analysis", callback_data="signal_technical")],
-    [InlineKeyboardButton("Market Sentiment", callback_data="signal_sentiment")],
-    [InlineKeyboardButton("Economic Calendar", callback_data="signal_calendar")],
-    [InlineKeyboardButton("Back", callback_data="back_to_signal")]
-]
-
-# Crypto keyboard voor sentiment analyse
-CRYPTO_SENTIMENT_KEYBOARD = [
-    [
-        InlineKeyboardButton("BTCUSD", callback_data="instrument_BTCUSD_sentiment"),
-        InlineKeyboardButton("ETHUSD", callback_data="instrument_ETHUSD_sentiment"),
-        InlineKeyboardButton("XRPUSD", callback_data="instrument_XRPUSD_sentiment")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Indices keyboard voor analyse
-INDICES_KEYBOARD = [
-    [
-        InlineKeyboardButton("US30", callback_data="instrument_US30_chart"),
-        InlineKeyboardButton("US500", callback_data="instrument_US500_chart"),
-        InlineKeyboardButton("US100", callback_data="instrument_US100_chart")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Indices keyboard voor signals - Fix de "Terug" knop naar "Back"
-INDICES_KEYBOARD_SIGNALS = [
-    [
-        InlineKeyboardButton("US30", callback_data="instrument_US30_signals"),
-        InlineKeyboardButton("US500", callback_data="instrument_US500_signals"),
-        InlineKeyboardButton("US100", callback_data="instrument_US100_signals")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Commodities keyboard voor analyse
-COMMODITIES_KEYBOARD = [
-    [
-        InlineKeyboardButton("GOLD", callback_data="instrument_XAUUSD_chart"),
-        InlineKeyboardButton("SILVER", callback_data="instrument_XAGUSD_chart"),
-        InlineKeyboardButton("OIL", callback_data="instrument_USOIL_chart")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Commodities keyboard voor signals - Fix de "Terug" knop naar "Back"
-COMMODITIES_KEYBOARD_SIGNALS = [
-    [
-        InlineKeyboardButton("XAUUSD", callback_data="instrument_XAUUSD_signals"),
-        InlineKeyboardButton("XAGUSD", callback_data="instrument_XAGUSD_signals"),
-        InlineKeyboardButton("USOIL", callback_data="instrument_USOIL_signals")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Forex keyboard for signals
-FOREX_KEYBOARD_SIGNALS = [
-    [
-        InlineKeyboardButton("EURUSD", callback_data="instrument_EURUSD_signals"),
-        InlineKeyboardButton("GBPUSD", callback_data="instrument_GBPUSD_signals"),
-        InlineKeyboardButton("USDJPY", callback_data="instrument_USDJPY_signals")
-    ],
-    [
-        InlineKeyboardButton("USDCAD", callback_data="instrument_USDCAD_signals"),
-        InlineKeyboardButton("EURGBP", callback_data="instrument_EURGBP_signals")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Crypto keyboard for signals
-CRYPTO_KEYBOARD_SIGNALS = [
-    [
-        InlineKeyboardButton("BTCUSD", callback_data="instrument_BTCUSD_signals"),
-        InlineKeyboardButton("ETHUSD", callback_data="instrument_ETHUSD_signals"),
-        InlineKeyboardButton("XRPUSD", callback_data="instrument_XRPUSD_signals")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Indices keyboard voor sentiment analyse
-INDICES_SENTIMENT_KEYBOARD = [
-    [
-        InlineKeyboardButton("US30", callback_data="instrument_US30_sentiment"),
-        InlineKeyboardButton("US500", callback_data="instrument_US500_sentiment"),
-        InlineKeyboardButton("US100", callback_data="instrument_US100_sentiment")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Commodities keyboard voor sentiment analyse
-COMMODITIES_SENTIMENT_KEYBOARD = [
-    [
-        InlineKeyboardButton("GOLD", callback_data="instrument_XAUUSD_sentiment"),
-        InlineKeyboardButton("SILVER", callback_data="instrument_XAGUSD_sentiment"),
-        InlineKeyboardButton("OIL", callback_data="instrument_USOIL_sentiment")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Style keyboard
-STYLE_KEYBOARD = [
-    [InlineKeyboardButton("‚ö° Test (one_min)", callback_data="style_test")],
-    [InlineKeyboardButton("üèÉ Scalp (fifteen_min)", callback_data="style_scalp")],
-    [InlineKeyboardButton(" Intraday (one_hour)", callback_data="style_intraday")],
-    [InlineKeyboardButton("üåä Swing (four_hour)", callback_data="style_swing")],
-    [InlineKeyboardButton("Back", callback_data="back_instrument")]
-]
-
-# Timeframe mapping
-STYLE_TIMEFRAME_MAP = {
-    "test": "one_min",
-    "scalp": "fifteen_min",
-    "intraday": "one_hour",
-    "swing": "four_hour"
-}
-
-# Mapping of instruments to their allowed timeframes - updated 2023-03-23
-INSTRUMENT_TIMEFRAME_MAP = {
-    # H1 timeframe only
-    "AUDJPY": "H1", 
-    "AUDCHF": "H1",
-    "EURCAD": "H1",
-    "EURGBP": "H1",
-    "GBPCHF": "H1",
-    "HK50": "H1",
-    "NZDJPY": "H1",
-    "USDCHF": "H1",
-    "USDJPY": "H1",  # USDJPY toegevoegd voor signaalabonnementen
-    "XRPUSD": "H1",
-    
-    # H4 timeframe only
-    "AUDCAD": "H4",
-    "AU200": "H4", 
-    "CADCHF": "H4",
-    "EURCHF": "H4",
-    "EURUSD": "H4",
-    "GBPCAD": "H4",
-    "LINKUSD": "H4",
-    "NZDCHF": "H4",
-    
-    # M15 timeframe only
-    "DOGEUSD": "M15",
-    "GBPNZD": "M15",
-    "NZDUSD": "M15",
-    "SOLUSD": "M15",
-    "UK100": "M15",
-    "XAUUSD": "M15",
-    
-    # M30 timeframe only
-    "BNBUSD": "M30",
-    "DOTUSD": "M30",
-    "ETHUSD": "M30",
-    "EURAUD": "M30",
-    "EURJPY": "M30",
-    "GBPAUD": "M30",
-    "GBPUSD": "M30",
-    "NZDCAD": "M30",
-    "US30": "M30",
-    "US500": "M30",
-    "USDCAD": "M30",
-    "XLMUSD": "M30",
-    "XTIUSD": "M30",
-    "DE40": "M30",
-    "BTCUSD": "M30",  # Added for consistency with CRYPTO_KEYBOARD_SIGNALS
-    "US100": "M30",   # Added for consistency with INDICES_KEYBOARD_SIGNALS
-    "XAGUSD": "M15",  # Added for consistency with COMMODITIES_KEYBOARD_SIGNALS
-    "USOIL": "M30"    # Added for consistency with COMMODITIES_KEYBOARD_SIGNALS
-    
-    # Removed as requested: EU50, FR40, LTCUSD
-}
-
-# Map common timeframe notations
-TIMEFRAME_DISPLAY_MAP = {
-    "M15": "15 Minutes",
-    "M30": "30 Minutes", 
-    "H1": "1 Hour",
-    "H4": "4 Hours"
-}
-
-# Voeg deze functie toe aan het begin van bot.py, na de imports
-    def _detect_market(instrument: str) -> str:
-    """Detecteer market type gebaseerd op instrument"""
-    instrument = instrument.upper()
-    
-    # Commodities eerst checken
-    commodities = [
-        "XAUUSD",  # Gold
-        "XAGUSD",  # Silver
-        "WTIUSD",  # Oil WTI
-        "BCOUSD",  # Oil Brent
-        "USOIL",   # Oil WTI (alternative symbol)
-    ]
-    if instrument in commodities:
-        logger.info(f"Detected {instrument} as commodity")
-        return "commodities"
-    
-    # Crypto pairs
-    crypto_base = ["BTC", "ETH", "XRP", "SOL", "BNB", "ADA", "DOT", "LINK"]
-    if any(c in instrument for c in crypto_base):
-        logger.info(f"Detected {instrument} as crypto")
-        return "crypto"
-    
-    # Major indices
-    indices = [
-        "US30", "US500", "US100",  # US indices
-        "UK100", "DE40", "FR40",   # European indices
-        "JP225", "AU200", "HK50"   # Asian indices
-    ]
-    if instrument in indices:
-        logger.info(f"Detected {instrument} as index")
-        return "indices"
-    
-    # Forex pairs als default
-    logger.info(f"Detected {instrument} as forex")
-    return "forex"
-
-# Voeg dit toe als decorator functie bovenaan het bestand na de imports
-    def require_subscription(func):
-    """Check if user has an active subscription"""
-    async def wrapper(self, update: Update, context: ContextTypes.DEFAULT_TYPE, *args, **kwargs):
-        user_id = update.effective_user.id
-        
-        # Check subscription status
-        is_subscribed = await self.db.is_user_subscribed(user_id)
-        
-        # Check if payment has failed
-        payment_failed = await self.db.has_payment_failed(user_id)
-        
-        if is_subscribed and not payment_failed:
-            # User has subscription, proceed with function
-            return await func(self, update, context, *args, **kwargs)
-        else:
-            if payment_failed:
-                # Show payment failure message
-                failed_payment_text = f"""
- <b>Subscription Payment Failed</b> 
-
-Your subscription payment could not be processed and your service has been deactivated.
-
-To continue using Sigmapips AI and receive trading signals, please reactivate your subscription by clicking the button below.
-                """
-                
-                # Use direct URL link for reactivation
-                reactivation_url = "https://buy.stripe.com/9AQcPf3j63HL5JS145"
-                
-                # Create button for reactivation
-                keyboard = [
-                    [InlineKeyboardButton("üîÑ Reactivate Subscription", url=reactivation_url)]
-                ]
-            else:
-                # Show subscription screen with the welcome message from the screenshot
-                failed_payment_text = f"""
- <b>Welcome to Sigmapips AI!</b> 
-
-<b>Discover powerful trading signals for various markets:</b>
-- <b>Forex</b> - Major and minor currency pairs
-- <b>Crypto</b> - Bitcoin, Ethereum and other top cryptocurrencies
-- <b>Indices</b> - Global market indices
-- <b>Commodities</b> - Gold, silver and oil
-
-<b>Features:</b>
- Real-time trading signals
-
- Multi-timeframe analysis (timeframes)
-
- Advanced chart analysis
-
- Sentiment indicators
-
- Economic calendar integration
-
-<b>Start today with a FREE 14-day trial!</b>
-                """
-                
-                # Use direct URL link instead of callback for the trial button
-                reactivation_url = "https://buy.stripe.com/3cs3eF9Hu9256NW9AA"
-                
-                # Create button for trial
-                keyboard = [
-                    [InlineKeyboardButton("üî• Start 14-day FREE Trial", url=reactivation_url)]
-                ]
-            
-            # Handle both message and callback query updates
-            if update.callback_query:
-                await update.callback_query.answer()
-                await update.callback_query.edit_message_text(
-                    text=failed_payment_text,
-                    reply_markup=InlineKeyboardMarkup(keyboard),
-                    parse_mode=ParseMode.HTML
-                )
-            else:
-                await update.message.reply_text(
-                    text=failed_payment_text,
-                    reply_markup=InlineKeyboardMarkup(keyboard),
-                    parse_mode=ParseMode.HTML
-                )
-            return MENU
-    
-    return wrapper
-
-# API keys with robust sanitization
-PERPLEXITY_API_KEY = os.getenv("PERPLEXITY_API_KEY", "").strip()
-OPENAI_API_KEY = os.getenv("OPENAI_API_KEY", "").strip()  # Changed from DeepSeek to OpenAI
-
-# Only using OpenAI's o4-mini now
-# No Tavily API key needed anymore
-logger.info("Using only OpenAI o4-mini for Market Sentiment service")
-
-# Log OpenAI API key (partially masked)
-if OPENAI_API_KEY:
-    # Better masking for privacy and security
-    masked_key = f"sk-p...{OPENAI_API_KEY[-4:]}" if len(OPENAI_API_KEY) > 8 else "sk-p..."
-    logger.info(f"Using OpenAI API key: {masked_key}")
-    
-    # Validate the key format
-    from trading_bot.config import validate_openai_key
-    if not validate_openai_key(OPENAI_API_KEY):
-        logger.warning("OpenAI API key format is invalid. AI services may not work correctly.")
-else:
-    logger.warning("No OpenAI API key configured. AI services will be disabled.")
-    
-# Set environment variables for the API keys with sanitization
-os.environ["PERPLEXITY_API_KEY"] = PERPLEXITY_API_KEY
-os.environ["OPENAI_API_KEY"] = OPENAI_API_KEY  # Changed from DeepSeek to OpenAI
-# No Tavily environment needed
-
-class TelegramService:
-    def __init__(self, db: Database, stripe_service=None, bot_token: Optional[str] = None, proxy_url: Optional[str] = None, lazy_init: bool = False):
-        """Initialize the bot with given database and config."""
-        # Database connection
-        self.db = db
-        
-        # Setup configuration 
-        self.stripe_service = stripe_service
-        self.user_signals = {}
-        self.signals_dir = "data/signals"
-        self.signals_enabled_val = True
-        self.polling_started = False
-        self.admin_users = [2004519703]  # Updated with correct Telegram ID from logs
-        self._signals_enabled = True  # Enable signals by default
-        
-        # Setup logger
-        self.logger = logging.getLogger(__name__)
-        
-        # GIF utilities for UI
-        self.gif_utils = gif_utils  # Initialize gif_utils as an attribute
-        
-        # Setup the bot and application
-        self.bot = None
-        self.application = None
-        
-        # Telegram Bot configuratie
-        self.bot_token = bot_token or os.getenv("TELEGRAM_BOT_TOKEN", "")
-        self.token = self.bot_token  # Aliased for backward compatibility
-        self.proxy_url = proxy_url or os.getenv("TELEGRAM_PROXY_URL", "")
-        
-        # Configure custom request handler with improved connection settings
-        request = HTTPXRequest(
-            connection_pool_size=50,  # Increase from 20 to 50
-            connect_timeout=15.0,     # Increase from 10.0 to 15.0
-            read_timeout=45.0,        # Increase from 30.0 to 45.0
-            write_timeout=30.0,       # Increase from 20.0 to 30.0
-            pool_timeout=60.0,        # Increase from 30.0 to 60.0
-        )
-        
-        # Initialize the bot directly with connection pool settings
-        self.bot = Bot(token=self.bot_token, request=request)
-        self.application = None  # Will be initialized in setup()
-        
-        # Webhook configuration
-        self.webhook_url = os.getenv("WEBHOOK_URL", "")
-        self.webhook_path = "/webhook"  # Always use this path
-        if self.webhook_url.endswith("/"):
-            self.webhook_url = self.webhook_url[:-1]  # Remove trailing slash
-            
-        logger.info(f"Bot initialized with webhook URL: {self.webhook_url} and path: {self.webhook_path}")
-        
-        # Initialize API services
-        self.chart_service = ChartService()  # Initialize chart service
-        # Lazy load services only when needed
-        self._calendar_service = None
-        self._sentiment_service = None
-        
-        # Don't use asyncio.create_task here - it requires a running event loop
-        # We'll initialize chart service later when the event loop is running
-        
-        # Bot application initialization
-        self.persistence = None
-        self.bot_started = False
-        
-        # Cache for sentiment analysis
-        self.sentiment_cache = {}
-        self.sentiment_cache_ttl = 60 * 60  # 1 hour in seconds
-        
-        # Start the bot
-    try:
-            # Check for bot token
-            if not self.bot_token:
-                raise ValueError("Missing Telegram bot token")
-            
-            # Initialize the bot
-            self.bot = Bot(token=self.bot_token)
-        
-            # Initialize the application
-            self.application = Application.builder().bot(self.bot).build()
-        
-            # Register the handlers
-            self._register_handlers(self.application)
-            
-            # Initialize signals dictionary but don't load them yet (will be done in initialize_services)
-            self.user_signals = {}
-        
-            logger.info("Telegram service initialized")
-            
-            # Keep track of processed updates
-            self.processed_updates = set()
-            
-    except Exception as e:
-        logger.error(f"Error initializing Telegram service: {str(e)}")
-        raise
-
-    async def initialize_services(self):
-        """Initialize services that require an asyncio event loop"""
-        try:
-            # Initialize chart service
-            await self.chart_service.initialize()
-            logger.info("Chart service initialized")
-            
-            # Load stored signals
-            await self._load_signals()
-            logger.info("Signals loaded")
-            
-            # Schedule periodic cleanup of old signals
-            if hasattr(self, 'db') and self.db and self.db.using_redis:
-                # Run initial cleanup
-                cleaned = await self._cleanup_old_signals(max_age_days=7)
-                logger.info(f"Initial signal cleanup completed, removed {cleaned} old signals")
-                
-                # Schedule periodic cleanup (every 24 hours)
-                async def periodic_cleanup():
-                    while True:
-                        try:
-                            # Wait for 24 hours
-                            await asyncio.sleep(24 * 60 * 60)
-                            # Run cleanup
-                            cleaned = await self._cleanup_old_signals(max_age_days=7)
-                            logger.info(f"Periodic signal cleanup completed, removed {cleaned} old signals")
-                        except Exception as e:
-                            logger.error(f"Error in periodic signal cleanup: {str(e)}")
-                
-                # Start the periodic cleanup task
-                asyncio.create_task(periodic_cleanup())
-                logger.info("Scheduled periodic signal cleanup")
-        except Exception as e:
-            logger.error(f"Error initializing services: {str(e)}")
-            raise
-
-# Calendar service helpers
-    @property
-    def signals_enabled(self):
-        """Get whether signals processing is enabled"""
-        return self._signals_enabled
-    
-    @signals_enabled.setter
-    def signals_enabled(self, value):
-        """Set whether signals processing is enabled"""
-        self._signals_enabled = bool(value)
-        logger.info(f"Signal processing is now {'enabled' if value else 'disabled'}")
-
-    async def start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE = None) -> None:
-        """Handle the /start command"""
-        user = update.effective_user
-        logger.info(f"User {user.id} ({user.username}) started the bot")
-        
-        # Check if user is subscribed
-        is_subscribed = await self.db.is_user_subscribed(user.id)
-        
-        # Create welcome message
-        welcome_text = (
-            f"üëã Welcome to SigmaPips Trading Bot, {user.first_name}!\n\n"
-            "I'm your AI-powered trading assistant. Here's what I can do for you:\n\n"
-            " <b>Market Analysis</b> - Technical and sentiment analysis for major markets\n"
-            " <b>Signal Management</b> - Receive and manage trading signals\n"
-            " <b>Economic Calendar</b> - Stay updated with important economic events\n\n"
-        )
-        
-        # Add subscription status
-        if is_subscribed:
-            welcome_text += " <b>Subscription Status:</b> Active\n\n"
-        else:
-            welcome_text += " <b>Subscription Status:</b> Inactive\n\n"
-        
-        welcome_text += "Use the /menu command to access all features."
-        
-        # Create keyboard for main menu
-        keyboard = [
-            [InlineKeyboardButton(" Analyze Markets", callback_data="menu_analyse")],
-            [InlineKeyboardButton(" Signal Management", callback_data="menu_signals")],
-            [InlineKeyboardButton("‚ùì Help", callback_data="menu_help")]
-        ]
-        reply_markup = InlineKeyboardMarkup(keyboard)
-        
-        # Send welcome message with keyboard
-        await update.message.reply_html(
-            welcome_text,
-            reply_markup=reply_markup
-        )
-        
-        # Log the user interaction
-        logger.info(f"Sent welcome message to user {user.id}")
-        
-        # Store user data if needed
-        if context:
-            context.user_data['is_signals_context'] = False
-            context.user_data['from_signal'] = False
-            context.user_data['in_signal_flow'] = False
-        
-        return MAIN_MENU
-
-# Initialize logging early in the application startup
-logger = setup_logging()
-
-import os
-import json
-import asyncio
-import traceback
-from typing import Dict, Any, List, Optional, Union, Set
-from datetime import datetime, timedelta
-import logging
-import copy
-import re
-import time
-import random
-
-from fastapi import FastAPI, Request, HTTPException, status
-from telegram import Bot, Update, BotCommand, InlineKeyboardButton, InlineKeyboardMarkup, CallbackQuery, InputMediaPhoto, InputMediaAnimation, InputMediaDocument, ReplyKeyboardMarkup, ReplyKeyboardRemove, InputFile
-from telegram.constants import ParseMode
-from telegram.request import HTTPXRequest
-from telegram.ext import (
-    Application,
-    CommandHandler,
-    CallbackQueryHandler,
-    ConversationHandler,
-    ContextTypes,
-    CallbackContext,
-    MessageHandler,
-    filters,
-    PicklePersistence
-)
-from telegram.error import TelegramError, BadRequest
-import httpx
-import telegram.error  # Add this import for BadRequest error handling
-
-from trading_bot.services.database.db import Database
-from trading_bot.services.chart_service.chart import ChartService
-from trading_bot.services.sentiment_service.sentiment import MarketSentimentService
-from trading_bot.services.calendar_service import EconomicCalendarService
-from trading_bot.services.payment_service.stripe_service import StripeService
-from trading_bot.services.payment_service.stripe_config import get_subscription_features
-from trading_bot.services.telegram_service.states import (
-    MENU, ANALYSIS, SIGNALS, CHOOSE_MARKET, CHOOSE_INSTRUMENT, CHOOSE_STYLE,
-    CHOOSE_ANALYSIS, SIGNAL_DETAILS,
-    CALLBACK_MENU_ANALYSE, CALLBACK_MENU_SIGNALS, CALLBACK_ANALYSIS_TECHNICAL,
-    CALLBACK_ANALYSIS_SENTIMENT, CALLBACK_ANALYSIS_CALENDAR, CALLBACK_SIGNALS_ADD,
-    CALLBACK_SIGNALS_MANAGE, CALLBACK_BACK_MENU
-)
-import trading_bot.services.telegram_service.gif_utils as gif_utils
-
-# Initialize logger
-logger = logging.getLogger(__name__)
-
-# Major currencies to focus on
-MAJOR_CURRENCIES = ["USD", "EUR", "GBP", "JPY", "CHF", "AUD", "NZD", "CAD"]
-
-# Currency to flag emoji mapping
-CURRENCY_FLAG = {
-    "USD": "üá∫üá∏",
-    "EUR": "üá™üá∫",
-    "GBP": "üá¨üáß",
-    "JPY": "üáØüáµ",
-    "CHF": "üá®üá≠",
-    "AUD": "üá¶üá∫",
-    "NZD": "üá≥üáø",
-    "CAD": "üá®üá¶"
-}
-
-# Map of instruments to their corresponding currencies
-INSTRUMENT_CURRENCY_MAP = {
-    # Special case for global view
-    "GLOBAL": MAJOR_CURRENCIES,
-    
-    # Forex
-    "EURUSD": ["EUR", "USD"],
-    "GBPUSD": ["GBP", "USD"],
-    "USDJPY": ["USD", "JPY"],
-    "USDCHF": ["USD", "CHF"],
-    "AUDUSD": ["AUD", "USD"],
-    "NZDUSD": ["NZD", "USD"],
-    "USDCAD": ["USD", "CAD"],
-    "EURGBP": ["EUR", "GBP"],
-    "EURJPY": ["EUR", "JPY"],
-    "GBPJPY": ["GBP", "JPY"],
-    
-    # Indices (mapped to their related currencies)
-    "US30": ["USD"],
-    "US100": ["USD"],
-    "US500": ["USD"],
-    "UK100": ["GBP"],
-    "GER40": ["EUR"],
-    "FRA40": ["EUR"],
-    "ESP35": ["EUR"],
-    "JP225": ["JPY"],
-    "AUS200": ["AUD"],
-    
-    # Commodities (mapped to USD primarily)
-    "XAUUSD": ["USD", "XAU"],  # Gold
-    "XAGUSD": ["USD", "XAG"],  # Silver
-    "USOIL": ["USD"],          # Oil (WTI)
-    "UKOIL": ["USD", "GBP"],   # Oil (Brent)
-    
-    # Crypto
-    "BTCUSD": ["USD", "BTC"],
-    "ETHUSD": ["USD", "ETH"],
-    "LTCUSD": ["USD", "LTC"],
-    "XRPUSD": ["USD", "XRP"]
-}
-
-# Callback data constants
-CALLBACK_ANALYSIS_TECHNICAL = "analysis_technical"
-CALLBACK_ANALYSIS_SENTIMENT = "analysis_sentiment"
-CALLBACK_ANALYSIS_CALENDAR = "analysis_calendar"
-CALLBACK_BACK_MENU = "back_menu"
-CALLBACK_BACK_ANALYSIS = "back_to_analysis"
-CALLBACK_BACK_MARKET = "back_market"
-CALLBACK_BACK_INSTRUMENT = "back_instrument"
-CALLBACK_BACK_SIGNALS = "back_signals"
-CALLBACK_SIGNALS_ADD = "signals_add"
-CALLBACK_SIGNALS_MANAGE = "signals_manage"
-CALLBACK_MENU_ANALYSE = "menu_analyse"
-CALLBACK_MENU_SIGNALS = "menu_signals"
-
-# States
-MENU = 0
-CHOOSE_ANALYSIS = 1
-CHOOSE_SIGNALS = 2
-CHOOSE_MARKET = 3
-CHOOSE_INSTRUMENT = 4
-CHOOSE_STYLE = 5
-SHOW_RESULT = 6
-CHOOSE_TIMEFRAME = 7
-SIGNAL_DETAILS = 8
-SIGNAL = 9
-SUBSCRIBE = 10
-BACK_TO_MENU = 11  # Add this line
-
-# Messages
-WELCOME_MESSAGE = r"""
-<b>Sigmapips AI - Main Menu</b>
-
-Choose an option to access advanced trading support:
-
-Services:
-- <b>Technical Analysis</b> - Real-time chart analysis and key levels
-
-- <b>Market Sentiment</b> - Understand market trends and sentiment
-
-- <b>Economic Calendar</b> - Stay updated on market-moving events
-
-- <b>Trading Signals</b> - Get precise entry/exit points for your favorite pairs
-
-Select your option to continue:
-"""
-
-# Abonnementsbericht voor nieuwe gebruikers
-SUBSCRIPTION_WELCOME_MESSAGE = r"""
-<b>Welcome to Sigmapips AI!</b>
-
-To access all features, you need a subscription:
-
-<b>Trading Signals Subscription - $29.99/month</b>
-- Access to all trading signals (Forex, Crypto, Commodities, Indices)
-- Advanced timeframe analysis
-- Detailed chart analysis for each signal
-
-Click the button below to subscribe:
-"""
-
-MENU_MESSAGE = r"""
-Welcome to Sigmapips AI!
-
-Choose a command:
-
-/start - Set up new trading pairs
-Add new market/instrument/timeframe combinations to receive signals
-
-/manage - Manage your preferences
-View, edit or delete your saved trading pairs
-
-Need help? Use /help to see all available commands.
-"""
-
-HELP_MESSAGE = r"""
-Available commands:
-/menu - Show main menu
-/start - Set up new trading pairs
-/help - Show this help message
-"""
-
-# Start menu keyboard
-START_KEYBOARD = [
-    [InlineKeyboardButton("Analyze Market", callback_data=CALLBACK_MENU_ANALYSE)],
-    [InlineKeyboardButton("Trading Signals", callback_data=CALLBACK_MENU_SIGNALS)]
-]
-
-# Analysis menu keyboard
-ANALYSIS_KEYBOARD = [
-    [InlineKeyboardButton("Technical Analysis", callback_data=CALLBACK_ANALYSIS_TECHNICAL)],
-    [InlineKeyboardButton("Market Sentiment", callback_data=CALLBACK_ANALYSIS_SENTIMENT)],
-    [InlineKeyboardButton("Economic Calendar", callback_data=CALLBACK_ANALYSIS_CALENDAR)],
-    [InlineKeyboardButton("Back", callback_data=CALLBACK_BACK_MENU)]
-]
-
-# Signals menu keyboard
-SIGNALS_KEYBOARD = [
-    [InlineKeyboardButton("Add New Pairs", callback_data=CALLBACK_SIGNALS_ADD)],
-    [InlineKeyboardButton("Manage Signals", callback_data=CALLBACK_SIGNALS_MANAGE)],
-    [InlineKeyboardButton("Back", callback_data=CALLBACK_BACK_MENU)]
-]
-
-# Market keyboard voor signals
-MARKET_KEYBOARD_SIGNALS = [
-    [InlineKeyboardButton("Forex", callback_data="market_forex_signals")],
-    [InlineKeyboardButton("Crypto", callback_data="market_crypto_signals")],
-    [InlineKeyboardButton("Commodities", callback_data="market_commodities_signals")],
-    [InlineKeyboardButton("Indices", callback_data="market_indices_signals")],
-    [InlineKeyboardButton("Back", callback_data="back_signals")]
-]
-
-# Market keyboard voor analyse
-MARKET_KEYBOARD = [
-    [InlineKeyboardButton("Forex", callback_data="market_forex")],
-    [InlineKeyboardButton("Crypto", callback_data="market_crypto")],
-    [InlineKeyboardButton("Commodities", callback_data="market_commodities")],
-    [InlineKeyboardButton("Indices", callback_data="market_indices")],
-    [InlineKeyboardButton("Back", callback_data="back_analysis")]
-]
-
-# Market keyboard specifiek voor sentiment analyse
-MARKET_SENTIMENT_KEYBOARD = [
-    [InlineKeyboardButton("Forex", callback_data="market_forex_sentiment")],
-    [InlineKeyboardButton("Crypto", callback_data="market_crypto_sentiment")],
-    [InlineKeyboardButton("Commodities", callback_data="market_commodities_sentiment")],
-    [InlineKeyboardButton("Indices", callback_data="market_indices_sentiment")],
-    [InlineKeyboardButton("Back", callback_data="back_analysis")]
-]
-
-# Forex keyboard voor technical analyse
-FOREX_KEYBOARD = [
-    [
-        InlineKeyboardButton("EURUSD", callback_data="instrument_EURUSD_chart"),
-        InlineKeyboardButton("GBPUSD", callback_data="instrument_GBPUSD_chart"),
-        InlineKeyboardButton("USDJPY", callback_data="instrument_USDJPY_chart")
-    ],
-    [
-        InlineKeyboardButton("AUDUSD", callback_data="instrument_AUDUSD_chart"),
-        InlineKeyboardButton("USDCAD", callback_data="instrument_USDCAD_chart"),
-        InlineKeyboardButton("EURGBP", callback_data="instrument_EURGBP_chart")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Forex keyboard voor sentiment analyse
-FOREX_SENTIMENT_KEYBOARD = [
-    [
-        InlineKeyboardButton("EURUSD", callback_data="instrument_EURUSD_sentiment"),
-        InlineKeyboardButton("GBPUSD", callback_data="instrument_GBPUSD_sentiment"),
-        InlineKeyboardButton("USDJPY", callback_data="instrument_USDJPY_sentiment")
-    ],
-    [
-        InlineKeyboardButton("AUDUSD", callback_data="instrument_AUDUSD_sentiment"),
-        InlineKeyboardButton("USDCAD", callback_data="instrument_USDCAD_sentiment"),
-        InlineKeyboardButton("EURGBP", callback_data="instrument_EURGBP_sentiment")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Forex keyboard voor kalender analyse
-FOREX_CALENDAR_KEYBOARD = [
-    [
-        InlineKeyboardButton("EURUSD", callback_data="instrument_EURUSD_calendar"),
-        InlineKeyboardButton("GBPUSD", callback_data="instrument_GBPUSD_calendar"),
-        InlineKeyboardButton("USDJPY", callback_data="instrument_USDJPY_calendar")
-    ],
-    [
-        InlineKeyboardButton("AUDUSD", callback_data="instrument_AUDUSD_calendar"),
-        InlineKeyboardButton("USDCAD", callback_data="instrument_USDCAD_calendar"),
-        InlineKeyboardButton("EURGBP", callback_data="instrument_EURGBP_calendar")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Crypto keyboard voor analyse
-CRYPTO_KEYBOARD = [
-    [
-        InlineKeyboardButton("BTCUSD", callback_data="instrument_BTCUSD_chart"),
-        InlineKeyboardButton("ETHUSD", callback_data="instrument_ETHUSD_chart"),
-        InlineKeyboardButton("XRPUSD", callback_data="instrument_XRPUSD_chart")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Signal analysis keyboard
-SIGNAL_ANALYSIS_KEYBOARD = [
-    [InlineKeyboardButton("Technical Analysis", callback_data="signal_technical")],
-    [InlineKeyboardButton("Market Sentiment", callback_data="signal_sentiment")],
-    [InlineKeyboardButton("Economic Calendar", callback_data="signal_calendar")],
-    [InlineKeyboardButton("Back", callback_data="back_to_signal")]
-]
-
-# Crypto keyboard voor sentiment analyse
-CRYPTO_SENTIMENT_KEYBOARD = [
-    [
-        InlineKeyboardButton("BTCUSD", callback_data="instrument_BTCUSD_sentiment"),
-        InlineKeyboardButton("ETHUSD", callback_data="instrument_ETHUSD_sentiment"),
-        InlineKeyboardButton("XRPUSD", callback_data="instrument_XRPUSD_sentiment")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Indices keyboard voor analyse
-INDICES_KEYBOARD = [
-    [
-        InlineKeyboardButton("US30", callback_data="instrument_US30_chart"),
-        InlineKeyboardButton("US500", callback_data="instrument_US500_chart"),
-        InlineKeyboardButton("US100", callback_data="instrument_US100_chart")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Indices keyboard voor signals - Fix de "Terug" knop naar "Back"
-INDICES_KEYBOARD_SIGNALS = [
-    [
-        InlineKeyboardButton("US30", callback_data="instrument_US30_signals"),
-        InlineKeyboardButton("US500", callback_data="instrument_US500_signals"),
-        InlineKeyboardButton("US100", callback_data="instrument_US100_signals")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Commodities keyboard voor analyse
-COMMODITIES_KEYBOARD = [
-    [
-        InlineKeyboardButton("GOLD", callback_data="instrument_XAUUSD_chart"),
-        InlineKeyboardButton("SILVER", callback_data="instrument_XAGUSD_chart"),
-        InlineKeyboardButton("OIL", callback_data="instrument_USOIL_chart")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Commodities keyboard voor signals - Fix de "Terug" knop naar "Back"
-COMMODITIES_KEYBOARD_SIGNALS = [
-    [
-        InlineKeyboardButton("XAUUSD", callback_data="instrument_XAUUSD_signals"),
-        InlineKeyboardButton("XAGUSD", callback_data="instrument_XAGUSD_signals"),
-        InlineKeyboardButton("USOIL", callback_data="instrument_USOIL_signals")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Forex keyboard for signals
-FOREX_KEYBOARD_SIGNALS = [
-    [
-        InlineKeyboardButton("EURUSD", callback_data="instrument_EURUSD_signals"),
-        InlineKeyboardButton("GBPUSD", callback_data="instrument_GBPUSD_signals"),
-        InlineKeyboardButton("USDJPY", callback_data="instrument_USDJPY_signals")
-    ],
-    [
-        InlineKeyboardButton("USDCAD", callback_data="instrument_USDCAD_signals"),
-        InlineKeyboardButton("EURGBP", callback_data="instrument_EURGBP_signals")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Crypto keyboard for signals
-CRYPTO_KEYBOARD_SIGNALS = [
-    [
-        InlineKeyboardButton("BTCUSD", callback_data="instrument_BTCUSD_signals"),
-        InlineKeyboardButton("ETHUSD", callback_data="instrument_ETHUSD_signals"),
-        InlineKeyboardButton("XRPUSD", callback_data="instrument_XRPUSD_signals")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Indices keyboard voor sentiment analyse
-INDICES_SENTIMENT_KEYBOARD = [
-    [
-        InlineKeyboardButton("US30", callback_data="instrument_US30_sentiment"),
-        InlineKeyboardButton("US500", callback_data="instrument_US500_sentiment"),
-        InlineKeyboardButton("US100", callback_data="instrument_US100_sentiment")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Commodities keyboard voor sentiment analyse
-COMMODITIES_SENTIMENT_KEYBOARD = [
-    [
-        InlineKeyboardButton("GOLD", callback_data="instrument_XAUUSD_sentiment"),
-        InlineKeyboardButton("SILVER", callback_data="instrument_XAGUSD_sentiment"),
-        InlineKeyboardButton("OIL", callback_data="instrument_USOIL_sentiment")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Style keyboard
-STYLE_KEYBOARD = [
-    [InlineKeyboardButton("‚ö° Test (one_min)", callback_data="style_test")],
-    [InlineKeyboardButton("üèÉ Scalp (fifteen_min)", callback_data="style_scalp")],
-    [InlineKeyboardButton(" Intraday (one_hour)", callback_data="style_intraday")],
-    [InlineKeyboardButton("üåä Swing (four_hour)", callback_data="style_swing")],
-    [InlineKeyboardButton("Back", callback_data="back_instrument")]
-]
-
-# Timeframe mapping
-STYLE_TIMEFRAME_MAP = {
-    "test": "one_min",
-    "scalp": "fifteen_min",
-    "intraday": "one_hour",
-    "swing": "four_hour"
-}
-
-# Mapping of instruments to their allowed timeframes - updated 2023-03-23
-INSTRUMENT_TIMEFRAME_MAP = {
-    # H1 timeframe only
-    "AUDJPY": "H1", 
-    "AUDCHF": "H1",
-    "EURCAD": "H1",
-    "EURGBP": "H1",
-    "GBPCHF": "H1",
-    "HK50": "H1",
-    "NZDJPY": "H1",
-    "USDCHF": "H1",
-    "USDJPY": "H1",  # USDJPY toegevoegd voor signaalabonnementen
-    "XRPUSD": "H1",
-    
-    # H4 timeframe only
-    "AUDCAD": "H4",
-    "AU200": "H4", 
-    "CADCHF": "H4",
-    "EURCHF": "H4",
-    "EURUSD": "H4",
-    "GBPCAD": "H4",
-    "LINKUSD": "H4",
-    "NZDCHF": "H4",
-    
-    # M15 timeframe only
-    "DOGEUSD": "M15",
-    "GBPNZD": "M15",
-    "NZDUSD": "M15",
-    "SOLUSD": "M15",
-    "UK100": "M15",
-    "XAUUSD": "M15",
-    
-    # M30 timeframe only
-    "BNBUSD": "M30",
-    "DOTUSD": "M30",
-    "ETHUSD": "M30",
-    "EURAUD": "M30",
-    "EURJPY": "M30",
-    "GBPAUD": "M30",
-    "GBPUSD": "M30",
-    "NZDCAD": "M30",
-    "US30": "M30",
-    "US500": "M30",
-    "USDCAD": "M30",
-    "XLMUSD": "M30",
-    "XTIUSD": "M30",
-    "DE40": "M30",
-    "BTCUSD": "M30",  # Added for consistency with CRYPTO_KEYBOARD_SIGNALS
-    "US100": "M30",   # Added for consistency with INDICES_KEYBOARD_SIGNALS
-    "XAGUSD": "M15",  # Added for consistency with COMMODITIES_KEYBOARD_SIGNALS
-    "USOIL": "M30"    # Added for consistency with COMMODITIES_KEYBOARD_SIGNALS
-    
-    # Removed as requested: EU50, FR40, LTCUSD
-}
-
-# Map common timeframe notations
-TIMEFRAME_DISPLAY_MAP = {
-    "M15": "15 Minutes",
-    "M30": "30 Minutes", 
-    "H1": "1 Hour",
-    "H4": "4 Hours"
-}
-
-# Voeg deze functie toe aan het begin van bot.py, na de imports
-def _detect_market(instrument: str) -> str:
-    """Detecteer market type gebaseerd op instrument"""
-    instrument = instrument.upper()
-    
-    # Commodities eerst checken
-    commodities = [
-        "XAUUSD",  # Gold
-        "XAGUSD",  # Silver
-        "WTIUSD",  # Oil WTI
-        "BCOUSD",  # Oil Brent
-        "USOIL",   # Oil WTI (alternative symbol)
-    ]
-    if instrument in commodities:
-        logger.info(f"Detected {instrument} as commodity")
-        return "commodities"
-    
-    # Crypto pairs
-    crypto_base = ["BTC", "ETH", "XRP", "SOL", "BNB", "ADA", "DOT", "LINK"]
-    if any(c in instrument for c in crypto_base):
-        logger.info(f"Detected {instrument} as crypto")
-        return "crypto"
-    
-    # Major indices
-    indices = [
-        "US30", "US500", "US100",  # US indices
-        "UK100", "DE40", "FR40",   # European indices
-        "JP225", "AU200", "HK50"   # Asian indices
-    ]
-    if instrument in indices:
-        logger.info(f"Detected {instrument} as index")
-        return "indices"
-    
-    # Forex pairs als default
-    logger.info(f"Detected {instrument} as forex")
-    return "forex"
-
-# Voeg dit toe als decorator functie bovenaan het bestand na de imports
-def require_subscription(func):
-    """Check if user has an active subscription"""
-    async def wrapper(self, update: Update, context: ContextTypes.DEFAULT_TYPE, *args, **kwargs):
-        user_id = update.effective_user.id
-        
-        # Check subscription status
-        is_subscribed = await self.db.is_user_subscribed(user_id)
-        
-        # Check if payment has failed
-        payment_failed = await self.db.has_payment_failed(user_id)
-        
-        if is_subscribed and not payment_failed:
-            # User has subscription, proceed with function
-            return await func(self, update, context, *args, **kwargs)
-        else:
-            if payment_failed:
-                # Show payment failure message
-                failed_payment_text = f"""
- <b>Subscription Payment Failed</b> 
-
-Your subscription payment could not be processed and your service has been deactivated.
-
-To continue using Sigmapips AI and receive trading signals, please reactivate your subscription by clicking the button below.
-                """
-                
-                # Use direct URL link for reactivation
-                reactivation_url = "https://buy.stripe.com/9AQcPf3j63HL5JS145"
-                
-                # Create button for reactivation
-                keyboard = [
-                    [InlineKeyboardButton("üîÑ Reactivate Subscription", url=reactivation_url)]
-                ]
-            else:
-                # Show subscription screen with the welcome message from the screenshot
-                failed_payment_text = f"""
- <b>Welcome to Sigmapips AI!</b> 
-
-<b>Discover powerful trading signals for various markets:</b>
-- <b>Forex</b> - Major and minor currency pairs
-- <b>Crypto</b> - Bitcoin, Ethereum and other top cryptocurrencies
-- <b>Indices</b> - Global market indices
-- <b>Commodities</b> - Gold, silver and oil
-
-<b>Features:</b>
- Real-time trading signals
-
- Multi-timeframe analysis (timeframes)
-
- Advanced chart analysis
-
- Sentiment indicators
-
- Economic calendar integration
-
-<b>Start today with a FREE 14-day trial!</b>
-                """
-                
-                # Use direct URL link instead of callback for the trial button
-                reactivation_url = "https://buy.stripe.com/3cs3eF9Hu9256NW9AA"
-                
-                # Create button for trial
-                keyboard = [
-                    [InlineKeyboardButton("üî• Start 14-day FREE Trial", url=reactivation_url)]
-                ]
-            
-            # Handle both message and callback query updates
-            if update.callback_query:
-                await update.callback_query.answer()
-                await update.callback_query.edit_message_text(
-                    text=failed_payment_text,
-                    reply_markup=InlineKeyboardMarkup(keyboard),
-                    parse_mode=ParseMode.HTML
-                )
-            else:
-                await update.message.reply_text(
-                    text=failed_payment_text,
-                    reply_markup=InlineKeyboardMarkup(keyboard),
-                    parse_mode=ParseMode.HTML
-                )
-            return MENU
-    
-    return wrapper
-
-# API keys with robust sanitization
-PERPLEXITY_API_KEY = os.getenv("PERPLEXITY_API_KEY", "").strip()
-OPENAI_API_KEY = os.getenv("OPENAI_API_KEY", "").strip()  # Changed from DeepSeek to OpenAI
-
-# Only using OpenAI's o4-mini now
-# No Tavily API key needed anymore
-logger.info("Using only OpenAI o4-mini for Market Sentiment service")
-
-# Log OpenAI API key (partially masked)
-if OPENAI_API_KEY:
-    # Better masking for privacy and security
-    masked_key = f"sk-p...{OPENAI_API_KEY[-4:]}" if len(OPENAI_API_KEY) > 8 else "sk-p..."
-    logger.info(f"Using OpenAI API key: {masked_key}")
-    
-    # Validate the key format
-    from trading_bot.config import validate_openai_key
-    if not validate_openai_key(OPENAI_API_KEY):
-        logger.warning("OpenAI API key format is invalid. AI services may not work correctly.")
-else:
-    logger.warning("No OpenAI API key configured. AI services will be disabled.")
-    
-# Set environment variables for the API keys with sanitization
-os.environ["PERPLEXITY_API_KEY"] = PERPLEXITY_API_KEY
-os.environ["OPENAI_API_KEY"] = OPENAI_API_KEY  # Changed from DeepSeek to OpenAI
-# No Tavily environment needed
-
-class TelegramService:
-    def __init__(self, db: Database, stripe_service=None, bot_token: Optional[str] = None, proxy_url: Optional[str] = None, lazy_init: bool = False):
-        """Initialize the bot with given database and config."""
-        # Database connection
-        self.db = db
-        
-        # Setup configuration 
-        self.stripe_service = stripe_service
-        self.user_signals = {}
-        self.signals_dir = "data/signals"
-        self.signals_enabled_val = True
-        self.polling_started = False
-        self.admin_users = [2004519703]  # Updated with correct Telegram ID from logs
-        self._signals_enabled = True  # Enable signals by default
-        
-        # Setup logger
-        self.logger = logging.getLogger(__name__)
-        
-        # GIF utilities for UI
-        self.gif_utils = gif_utils  # Initialize gif_utils as an attribute
-        
-        # Setup the bot and application
-        self.bot = None
-        self.application = None
-        
-        # Telegram Bot configuratie
-        self.bot_token = bot_token or os.getenv("TELEGRAM_BOT_TOKEN", "")
-        self.token = self.bot_token  # Aliased for backward compatibility
-        self.proxy_url = proxy_url or os.getenv("TELEGRAM_PROXY_URL", "")
-        
-        # Configure custom request handler with improved connection settings
-        request = HTTPXRequest(
-            connection_pool_size=50,  # Increase from 20 to 50
-            connect_timeout=15.0,     # Increase from 10.0 to 15.0
-            read_timeout=45.0,        # Increase from 30.0 to 45.0
-            write_timeout=30.0,       # Increase from 20.0 to 30.0
-            pool_timeout=60.0,        # Increase from 30.0 to 60.0
-        )
-        
-        # Initialize the bot directly with connection pool settings
-        self.bot = Bot(token=self.bot_token, request=request)
-        self.application = None  # Will be initialized in setup()
-        
-        # Webhook configuration
-        self.webhook_url = os.getenv("WEBHOOK_URL", "")
-        self.webhook_path = "/webhook"  # Always use this path
-        if self.webhook_url.endswith("/"):
-            self.webhook_url = self.webhook_url[:-1]  # Remove trailing slash
-            
-        logger.info(f"Bot initialized with webhook URL: {self.webhook_url} and path: {self.webhook_path}")
-        
-        # Initialize API services
-        self.chart_service = ChartService()  # Initialize chart service
-        # Lazy load services only when needed
-        self._calendar_service = None
-        self._sentiment_service = None
-        
-        # Don't use asyncio.create_task here - it requires a running event loop
-        # We'll initialize chart service later when the event loop is running
-        
-        # Bot application initialization
-        self.persistence = None
-        self.bot_started = False
-        
-        # Cache for sentiment analysis
-        self.sentiment_cache = {}
-        self.sentiment_cache_ttl = 60 * 60  # 1 hour in seconds
-        
-        # Start the bot
-    try:
-            # Check for bot token
-            if not self.bot_token:
-                raise ValueError("Missing Telegram bot token")
-            
-            # Initialize the bot
-            self.bot = Bot(token=self.bot_token)
-        
-            # Initialize the application
-            self.application = Application.builder().bot(self.bot).build()
-        
-            # Register the handlers
-            self._register_handlers(self.application)
-            
-            # Initialize signals dictionary but don't load them yet (will be done in initialize_services)
-            self.user_signals = {}
-        
-            logger.info("Telegram service initialized")
-            
-            # Keep track of processed updates
-            self.processed_updates = set()
-            
-    except Exception as e:
-        logger.error(f"Error initializing Telegram service: {str(e)}")
-        raise
-
-    async def initialize_services(self):
-        """Initialize services that require an asyncio event loop"""
-        try:
-            # Initialize chart service
-            await self.chart_service.initialize()
-            logger.info("Chart service initialized")
-            
-            # Load stored signals
-            await self._load_signals()
-            logger.info("Signals loaded")
-            
-            # Schedule periodic cleanup of old signals
-            if hasattr(self, 'db') and self.db and self.db.using_redis:
-                # Run initial cleanup
-                cleaned = await self._cleanup_old_signals(max_age_days=7)
-                logger.info(f"Initial signal cleanup completed, removed {cleaned} old signals")
-                
-                # Schedule periodic cleanup (every 24 hours)
-                async def periodic_cleanup():
-                    while True:
-                        try:
-                            # Wait for 24 hours
-                            await asyncio.sleep(24 * 60 * 60)
-                            # Run cleanup
-                            cleaned = await self._cleanup_old_signals(max_age_days=7)
-                            logger.info(f"Periodic signal cleanup completed, removed {cleaned} old signals")
-                        except Exception as e:
-                            logger.error(f"Error in periodic signal cleanup: {str(e)}")
-                
-                # Start the periodic cleanup task
-                asyncio.create_task(periodic_cleanup())
-                logger.info("Scheduled periodic signal cleanup")
-        except Exception as e:
-            logger.error(f"Error initializing services: {str(e)}")
-            raise
-            
-    # Calendar service helpers
-    @property
-    def calendar_service(self):
-        """Lazy loaded calendar service"""
-        if self._calendar_service is None:
-            # Only initialize the calendar service when it's first accessed
-            self.logger.info("Lazy loading calendar service")
-            self._calendar_service = EconomicCalendarService()
-        return self._calendar_service
-        
-    def _get_calendar_service(self):
-        """Get the calendar service instance"""
-        self.logger.info("Getting calendar service")
-        return self.calendar_service
-
-    async def _format_calendar_events(self, calendar_data):
-        """Format the calendar data into a readable HTML message"""
-        self.logger.info(f"Formatting calendar data with {len(calendar_data)} events")
-        if not calendar_data:
-            return "<b>Economic Calendar</b>\n\nNo economic events found for today."
-        
-        # Sort events by time
-        try:
-            # Try to parse time for sorting
-            def parse_time_for_sorting(event):
-                time_str = event.get('time', '')
-                try:
-                    # Extract hour and minute if in format like "08:30 EST"
-                    if ':' in time_str:
-                        parts = time_str.split(' ')[0].split(':')
-                        hour = int(parts[0])
-                        minute = int(parts[1])
-                        return hour * 60 + minute
-                    return 0
-                except:
-                    return 0
-            
-            # Sort the events by time
-            sorted_events = sorted(calendar_data, key=parse_time_for_sorting)
-        except Exception as e:
-            self.logger.error(f"Error sorting calendar events: {str(e)}")
-            sorted_events = calendar_data
-        
-        # Format the message
-        message = "<b>Economic Calendar</b>\n\n"
-        
-        # Get current date
-        current_date = datetime.now().strftime("%B %d, %Y")
-        message += f"<b>Date:</b> {current_date}\n\n"
-        
-        # Add impact legend
-        message += "<b>Impact:</b> üî¥ High   üü† Medium   üü¢ Low\n\n"
-        
-        # Group events by country
-        events_by_country = {}
-        for event in sorted_events:
-            country = event.get('country', 'Unknown')
-            if country not in events_by_country:
-                events_by_country[country] = []
-            events_by_country[country].append(event)
-        
-        # Format events by country
-        for country, events in events_by_country.items():
-            country_flag = CURRENCY_FLAG.get(country, '')
-            message += f"<b>{country_flag} {country}</b>\n"
-            
-            for event in events:
-                time = event.get('time', 'TBA')
-                title = event.get('title', 'Unknown Event')
-                impact = event.get('impact', 'Low')
-                impact_emoji = {'High': 'üî¥', 'Medium': 'üü†', 'Low': 'üü¢'}.get(impact, 'üü¢')
-                
-                message += f"{time} - {impact_emoji} {title}\n"
-            
-            message += "\n"  # Add extra newline between countries
-        
-        return message
-        
-    # Utility functions that might be missing
-    async def update_message(self, query, text, keyboard=None, parse_mode=ParseMode.HTML):
-        """Utility to update a message with error handling"""
-        try:
-            # Check if the message is too long for Telegram caption limits (1024 chars)
-            MAX_CAPTION_LENGTH = 1000  # Slightly under the 1024 limit for safety
-            MAX_MESSAGE_LENGTH = 4000  # Telegram message limit
-            
-            # Log message length for debugging
-            logger.info(f"Updating message (length: {len(text)} chars)")
-            
-            # If message is too long for a caption but ok for a text message
-            if len(text) > MAX_CAPTION_LENGTH and len(text) <= MAX_MESSAGE_LENGTH:
-                logger.info("Message too long for caption but ok for text message")
-                # Try to edit message text first
-                await query.edit_message_text(
-                    text=text,
-                    reply_markup=keyboard,
-                    parse_mode=parse_mode
-                )
-                return True
-            # If message is too long even for a text message
-            elif len(text) > MAX_MESSAGE_LENGTH:
-                logger.warning(f"Message too long ({len(text)} chars), truncating")
-                # Find a good breaking point
-                truncated = text[:MAX_MESSAGE_LENGTH-100]
-                
-                # Try to break at a paragraph
-                last_newline = truncated.rfind('\n\n')
-                if last_newline > MAX_MESSAGE_LENGTH * 0.8:  # If we can keep at least 80% of the text
-                    truncated = truncated[:last_newline]
-                    
-                # Add indicator that text was truncated
-                truncated += "\n\n<i>... (message truncated)</i>"
-                
-                # Try to edit message text with truncated content
-                await query.edit_message_text(
-                    text=truncated,
-                    reply_markup=keyboard,
-                    parse_mode=parse_mode
-                )
-                return True
-            else:
-                # Normal case - message is within limits
-                # Try to edit message text first
-                await query.edit_message_text(
-                    text=text,
-                    reply_markup=keyboard,
-                    parse_mode=parse_mode
-                )
-                return True
-        except Exception as e:
-            logger.warning(f"Could not update message text: {str(e)}")
-            
-            # If text update fails, try to edit caption
-            try:
-                # Check if caption is too long
-                MAX_CAPTION_LENGTH = 1000  # Slightly under the 1024 limit for safety
-                
-                if len(text) > MAX_CAPTION_LENGTH:
-                    logger.warning(f"Caption too long ({len(text)} chars), truncating")
-                    # Find a good breaking point
-                    truncated = text[:MAX_CAPTION_LENGTH-100]
-                    
-                    # Try to break at a paragraph
-                    last_newline = truncated.rfind('\n\n')
-                    if last_newline > MAX_CAPTION_LENGTH * 0.8:  # If we can keep at least 80% of the text
-                        truncated = truncated[:last_newline]
-                        
-                    # Add indicator that text was truncated
-                    truncated += "\n\n<i>... (message truncated)</i>"
-                    
-                    # Use truncated text for caption
-                    await query.edit_message_caption(
-                        caption=truncated,
-                        reply_markup=keyboard,
-                        parse_mode=parse_mode
-                    )
-                else:
-                    # Caption is within limits
-                    await query.edit_message_caption(
-                        caption=text,
-                        reply_markup=keyboard,
-                        parse_mode=parse_mode
-                    )
-                return True
-            except Exception as e2:
-                logger.error(f"Could not update caption either: {str(e2)}")
-                
-                # As a last resort, send a new message
-                try:
-                    chat_id = query.message.chat_id
-                    
-                    # Check if message is too long
-                    MAX_MESSAGE_LENGTH = 4000  # Telegram message limit
-                    
-                    if len(text) > MAX_MESSAGE_LENGTH:
-                        logger.warning(f"New message too long ({len(text)} chars), truncating")
-                        # Find a good breaking point
-                        truncated = text[:MAX_MESSAGE_LENGTH-100]
-                        
-                        # Try to break at a paragraph
-                        last_newline = truncated.rfind('\n\n')
-                        if last_newline > MAX_MESSAGE_LENGTH * 0.8:  # If we can keep at least 80% of the text
-                            truncated = truncated[:last_newline]
-                            
-                        # Add indicator that text was truncated
-                        truncated += "\n\n<i>... (message truncated)</i>"
-                        
-                        # Use truncated text for new message
-                        await query.bot.send_message(
-                            chat_id=chat_id,
-                            text=truncated,
-                            reply_markup=keyboard,
-                            parse_mode=parse_mode
-                        )
-                    else:
-                        # Message is within limits
-                        await query.bot.send_message(
-                            chat_id=chat_id,
-                            text=text,
-                            reply_markup=keyboard,
-                            parse_mode=parse_mode
-                        )
-                    return True
-                except Exception as e3:
-                    logger.error(f"Failed to send new message: {str(e3)}")
-                    return False
-    
-    # Missing handler implementations
-    async def back_signals_callback(self, update: Update, context=None) -> int:
-        """Handle back_signals button press"""
-        query = update.callback_query
-        await query.answer()
-        
-        logger.info("back_signals_callback called")
-        
-        # Make sure we're in the signals flow context
-        if context and hasattr(context, 'user_data'):
-            # Reset signal flow flags
-            context.user_data['from_signal'] = False
-            context.user_data['in_signal_flow'] = False
-            logger.info(f"Reset signal flow flags: from_signal=False, in_signal_flow=False")
-            # Keep is_signals_context flag but reset from_signal flag
-            context.user_data['is_signals_context'] = True
-            context.user_data['from_signal'] = False
-            
-            # Clear other specific analysis keys but maintain signals context
-            keys_to_remove = [
-                'instrument', 'market', 'analysis_type', 'timeframe', 
-                'signal_id', 'signal_instrument', 'signal_direction', 'signal_timeframe',
-                'loading_message'
-            ]
-
-            for key in keys_to_remove:
-                if key in context.user_data:
-                    del context.user_data[key]
-            logger.info(f"Updated context in back_signals_callback: {context.user_data}")
-        
-        # Create keyboard for signal menu
-        keyboard = [
-            [InlineKeyboardButton(" Add Signal", callback_data="signals_add")],
-            [InlineKeyboardButton("Manage Signals", callback_data="signals_manage")],
-            [InlineKeyboardButton("Back to Menu", callback_data="back_menu")]
-        ]
-        reply_markup = InlineKeyboardMarkup(keyboard)
-        
-        # Get the signals GIF URL for better UX
-        signals_gif_url = "https://media.giphy.com/media/gSzIKNrqtotEYrZv7i/giphy.gif"
-        
-        # Update the message
-        await self.update_message(
-            query=query,            text="<b> Signal Management</b>\n\nManage your trading signals",
-
-
-            keyboard=reply_markup
-        )
-        
-        return SIGNALS
-        
-    async def get_subscribers_for_instrument(self, instrument: str, timeframe: str = None) -> List[int]:
-        """
-        Get a list of subscribed user IDs for a specific instrument and timeframe
-        
-        Args:
-            instrument: The trading instrument (e.g., EURUSD)
-            timeframe: Optional timeframe filter
-            
-        Returns:
-            List of subscribed user IDs
-        """
-    try:
-            logger.info(f"Getting subscribers for {instrument} timeframe: {timeframe}")
-            
-            # Get all subscribers from the database
-            # Note: Using get_signal_subscriptions instead of find_all
-            subscribers = await self.db.get_signal_subscriptions(instrument, timeframe)
-            
-            if not subscribers:
-                logger.warning(f"No subscribers found for {instrument}")
-                return []
-                
-            # Filter out subscribers that don't have an active subscription
-            active_subscribers = []
-            for subscriber in subscribers:
-                user_id = subscriber['user_id']
-                
-                # Check if user is subscribed
-                is_subscribed = await self.db.is_user_subscribed(user_id)
-                
-                # Check if payment has failed
-                payment_failed = await self.db.has_payment_failed(user_id)
-                
-                if is_subscribed and not payment_failed:
-                    active_subscribers.append(user_id)
-                else:
-                    logger.info(f"User {user_id} doesn't have an active subscription, skipping signal")
-            
-            return active_subscribers
-            
-    except Exception as e:
-        logger.error(f"Error getting subscribers: {str(e)}")
-        # FOR TESTING: Add admin users if available
-        if hasattr(self, 'admin_users') and self.admin_users:
-            logger.info(f"Returning admin users for testing: {self.admin_users}")
-            return self.admin_users
-        return []
-
-    async def process_signal(self, signal_data: Dict[str, Any]) -> bool:
-        """
-        Process a trading signal from TradingView webhook or API
-        
-        Supports two formats:
-        1. TradingView format: instrument, signal, price, sl, tp1, tp2, tp3, interval
-        2. Custom format: instrument, direction, entry, stop_loss, take_profit, timeframe
-        
-        Returns:
-            bool: True if signal was processed successfully, False otherwise
-        """
-        try:
-            # Log the incoming signal data
-            logger.info(f"Processing signal: {signal_data}")
-            
-            # Check which format we're dealing with and normalize it
-            instrument = signal_data.get('instrument')
-            
-            # Handle TradingView format (price, sl, interval)
-            if 'price' in signal_data and 'sl' in signal_data:
-                price = signal_data.get('price')
-                sl = signal_data.get('sl')
-                tp1 = signal_data.get('tp1')
-                tp2 = signal_data.get('tp2')
-                tp3 = signal_data.get('tp3')
-                interval = signal_data.get('interval', 'one_hour')
-                
-                # Determine signal direction based on price and SL relationship
-                direction = "BUY" if float(sl) < float(price) else "SELL"
-                
-                # Create normalized signal data
-                normalized_data = {
-                    'instrument': instrument,
-                    'direction': direction,
-                    'entry': price,
-                    'stop_loss': sl,
-                    'take_profit': tp1,  # Use first take profit level
-                    'timeframe': interval
-                }
-                
-                # Add optional fields if present
-                normalized_data['tp1'] = tp1
-                normalized_data['tp2'] = tp2
-                normalized_data['tp3'] = tp3
-                
-            # Handle custom format (direction, entry, stop_loss, timeframe)
-            elif 'direction' in signal_data and 'entry' in signal_data:
-                direction = signal_data.get('direction')
-                entry = signal_data.get('entry')
-                stop_loss = signal_data.get('stop_loss')
-                take_profit = signal_data.get('take_profit')
-                timeframe = signal_data.get('timeframe', 'one_hour')
-                
-                # Create normalized signal data
-                normalized_data = {
-                    'instrument': instrument,
-                    'direction': direction,
-                    'entry': entry,
-                    'stop_loss': stop_loss,
-                    'take_profit': take_profit,
-                    'timeframe': timeframe
-                }
-            else:
-                logger.error(f"Missing required signal data")
-                return False
-            
-            # Basic validation
-            if not normalized_data.get('instrument') or not normalized_data.get('direction') or not normalized_data.get('entry'):
-                logger.error(f"Missing required fields in normalized signal data: {normalized_data}")
-                return False
-                
-            # Create signal ID for tracking
-            signal_id = f"{normalized_data['instrument']}_{normalized_data['direction']}_{normalized_data['timeframe']}_{int(time.time())}"
-            
-            # Format the signal message
-            message = self._format_signal_message(normalized_data)
-            
-            # Determine market type for the instrument
-            market_type = _detect_market(instrument)
-            
-            # Store the full signal data for reference
-            normalized_data['id'] = signal_id
-            normalized_data['timestamp'] = datetime.now().isoformat()
-            normalized_data['message'] = message
-            normalized_data['market'] = market_type
-            
-            # Save signal for history tracking
-            if not os.path.exists(self.signals_dir):
-                os.makedirs(self.signals_dir, exist_ok=True)
-                
-            # Save to signals directory
-            with open(f"{self.signals_dir}/{signal_id}.json", 'w') as f:
-                json.dump(normalized_data, f)
-            
-            # FOR TESTING: Always send to admin for testing
-            if hasattr(self, 'admin_users') and self.admin_users:
-                try:
-                    logger.info(f"Sending signal to admin users for testing: {self.admin_users}")
-                    for admin_id in self.admin_users:
-                        # Prepare keyboard with analysis options
-                        keyboard = [
-                            [InlineKeyboardButton("Analyze Market", callback_data=f"analyze_from_signal_{instrument}_{signal_id}")]
-                        ]
-                        
-                        # Send the signal
-                        await self.bot.send_message(
-                            chat_id=admin_id,
-                            text=message,
-                            parse_mode=ParseMode.HTML,
-                            reply_markup=InlineKeyboardMarkup(keyboard)
-                        )
-                        logger.info(f"Test signal sent to admin {admin_id}")
-                        
-                        # Store signal reference for quick access
-                        if not hasattr(self, 'user_signals'):
-                            self.user_signals = {}
-                            
-                        admin_str_id = str(admin_id)
-                        if admin_str_id not in self.user_signals:
-                            self.user_signals[admin_str_id] = {}
-                        
-                        self.user_signals[admin_str_id][signal_id] = normalized_data
-            except Exception as e:
-                logger.error(f"Error sending test signal to admin: {str(e)}")
-            
-            # Get subscribers for this instrument
-            timeframe = normalized_data.get('timeframe', 'one_hour')
-            subscribers = await self.get_subscribers_for_instrument(instrument, timeframe)
-            
-            if not subscribers:
-                logger.warning(f"No subscribers found for {instrument}")
-                return True  # Successfully processed, just no subscribers
-            
-            # Send signal to all subscribers
-            logger.info(f"Sending signal {signal_id} to {len(subscribers)} subscribers")
-            
-            sent_count = 0
-            for user_id in subscribers:
-                try:
-                    # Prepare keyboard with analysis options
-                    keyboard = [
-                        [InlineKeyboardButton("Analyze Market", callback_data=f"analyze_from_signal_{instrument}_{signal_id}")]
-                    ]
-                    
-                    # Send the signal
-                    await self.bot.send_message(
-                        chat_id=user_id,
-                        text=message,
-                        parse_mode=ParseMode.HTML,
-                        reply_markup=InlineKeyboardMarkup(keyboard)
-                    )
-                    
-                    sent_count += 1
-                    
-                    # Store signal reference for quick access
-                    if not hasattr(self, 'user_signals'):
-                        self.user_signals = {}
-                        
-                    user_str_id = str(user_id)
-                    if user_str_id not in self.user_signals:
-                        self.user_signals[user_str_id] = {}
-                    
-                    self.user_signals[user_str_id][signal_id] = normalized_data
-                    
-            except Exception as e:
-                logger.error(f"Error sending signal to user {user_id}: {str(e)}")
-            
-            logger.info(f"Successfully sent signal {signal_id} to {sent_count}/{len(subscribers)} subscribers")
-            return True
-            
-    except Exception as e:
-        logger.error(f"Error processing signal: {str(e)}")
-        logger.exception(e)
-            return False
-
-    def _format_signal_message(self, signal_data: Dict[str, Any]) -> str:
-        """Format signal data into a nice message for Telegram"""
-    try:
-            # Extract fields from signal data
-            instrument = signal_data.get('instrument', 'Unknown')
-            direction = signal_data.get('direction', 'Unknown')
-            entry = signal_data.get('entry', 'Unknown')
-            stop_loss = signal_data.get('stop_loss')
-            take_profit = signal_data.get('take_profit')
-            timeframe = signal_data.get('timeframe', 'one_hour')
-            
-            # Get multiple take profit levels if available
-            tp1 = signal_data.get('tp1', take_profit)
-            tp2 = signal_data.get('tp2')
-            tp3 = signal_data.get('tp3')
-            
-            # Add emoji based on direction
-            direction_emoji = "üü¢" if direction.upper() == "BUY" else "üî¥"
-            
-            # Format the message with multiple take profits if available
-            message = "<b> New Trading Signal </b>\n"
-\n"
-            message += f"<b>Instrument:</b> {instrument}\n"
-            message += f"<b>Action:</b> {direction.upper()} {direction_emoji}
-\n"
-            message += f"<b>Entry Price:</b> {entry}\n"
-            
-            if stop_loss:
-                message += f"<b>Stop Loss:</b> {stop_loss} üî¥\n"
-            
-            # Add take profit levels
-            if tp1:
-                message += f"<b>Take Profit 1:</b> {tp1} \n"
-            if tp2:
-                message += f"<b>Take Profit 2:</b> {tp2} \n"
-            if tp3:
-                message += f"<b>Take Profit 3:</b> {tp3} \n"
-            
-            message += f"
-<b>Timeframe:</b> {timeframe}\n"
-            message += f"<b>Strategy:</b> TradingView Signal
-\n"
-            
-            message += "‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
-
-"
-            message += "<b>Risk Management:</b>\n"
-            message += "- Position size: 1-2% max\n"
-            message += "- Use proper stop loss\n"
-            message += "- Follow your trading plan
-
-"
-            
-            message += "‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
-
-"
-            
-            # Generate AI verdict
-            ai_verdict = f"The {instrument} {direction.lower()} signal shows a promising setup with defined entry at {entry} and stop loss at {stop_loss}. Multiple take profit levels provide opportunities for partial profit taking."
-            message += f"<b>ü§ñ SigmaPips AI Verdict:</b>\n{ai_verdict}"
-            
-            return message
-            
-    except Exception as e:
-        logger.error(f"Error formatting signal message: {str(e)}")
-            # Return simple message on error
-            return f"New {signal_data.get('instrument', 'Unknown')} {signal_data.get('direction', 'Unknown')} Signal"
-
-    def _register_handlers(self, application):
-        """Register event handlers for bot commands and callback queries"""
-    try:
-            logger.info("Registering command handlers")
-            
-            # Initialize the application without using run_until_complete
-        try:
-                # Instead of using loop.run_until_complete, directly call initialize 
-                # which will be properly awaited by the caller
-                self.init_task = application.initialize()
-                logger.info("Telegram application initialization ready to be awaited")
-            except Exception as init_e:
-            logger.error(f"Error during application initialization: {str(init_e)}")
-            logger.exception(init_e)
-                
-            # Set bot commands for menu
-            commands = [
-                BotCommand("start", "Start the bot and get the welcome message"),
-                BotCommand("menu", "Show the main menu"),
-                BotCommand("help", "Show available commands and how to use the bot")
-            ]
-            
-            # Store the set_commands_task to be awaited later
-        try:
-                # Instead of asyncio.create_task, we will await this in the startup event
-                self.set_commands_task = self.bot.set_my_commands(commands)
-                logger.info("Bot commands ready to be set")
-            except Exception as cmd_e:
-            logger.error(f"Error preparing bot commands: {str(cmd_e)}")
-            
-            # Register command handlers
-            application.add_handler(CommandHandler("start", self.start_command))
-            application.add_handler(CommandHandler("menu", self.menu_command))
-            application.add_handler(CommandHandler("help", self.help_command))
-            
-            # Register secret admin commands
-            application.add_handler(CommandHandler("set_subscription", self.set_subscription_command))
-            application.add_handler(CommandHandler("set_payment_failed", self.set_payment_failed_command))
-            logger.info("Registered secret admin commands")
-            
-            # Register callback handlers
-            application.add_handler(CallbackQueryHandler(self.menu_analyse_callback, pattern="^menu_analyse$"))
-            application.add_handler(CallbackQueryHandler(self.menu_signals_callback, pattern="^menu_signals$"))
-            application.add_handler(CallbackQueryHandler(self.signals_add_callback, pattern="^signals_add$"))
-            application.add_handler(CallbackQueryHandler(self.signals_manage_callback, pattern="^signals_manage$"))
-            application.add_handler(CallbackQueryHandler(self.market_callback, pattern="^market_"))
-            application.add_handler(CallbackQueryHandler(self.instrument_callback, pattern="^instrument_(?!.*_signals)"))
-            application.add_handler(CallbackQueryHandler(self.instrument_signals_callback, pattern="^instrument_.*_signals$"))
-            
-            # Add handler for back buttons
-            application.add_handler(CallbackQueryHandler(self.back_market_callback, pattern="^back_market$"))
-            application.add_handler(CallbackQueryHandler(self.back_instrument_callback, pattern="^back_instrument$"))
-            application.add_handler(CallbackQueryHandler(self.back_signals_callback, pattern="^back_signals$"))
-            application.add_handler(CallbackQueryHandler(self.back_menu_callback, pattern="^back_menu$"))
-            
-            # Analysis handlers for regular flow
-            application.add_handler(CallbackQueryHandler(self.analysis_technical_callback, pattern="^analysis_technical$"))
-            application.add_handler(CallbackQueryHandler(self.analysis_sentiment_callback, pattern="^analysis_sentiment$"))
-            application.add_handler(CallbackQueryHandler(self.analysis_calendar_callback, pattern="^analysis_calendar$"))
-            
-            # Analysis handlers for signal flow - with instrument embedded in callback
-            application.add_handler(CallbackQueryHandler(self.signal_technical_callback, pattern="^signal_flow_technical_.*$"))
-            application.add_handler(CallbackQueryHandler(self.signal_sentiment_callback, pattern="^signal_flow_sentiment_.*$"))
-            application.add_handler(CallbackQueryHandler(self.signal_calendar_callback, pattern="^signal_flow_calendar_.*$"))
-            
-            # Analysis handlers for signal flow - with instrument embedded in callback
-            application.add_handler(CallbackQueryHandler(self.signal_technical_callback, pattern="^signal_flow_technical_.*$"))
-            application.add_handler(CallbackQueryHandler(self.signal_sentiment_callback, pattern="^signal_flow_sentiment_.*$"))
-            application.add_handler(CallbackQueryHandler(self.analysis_calendar_callback, pattern="^signal_flow_calendar_.*$"))
-            
-            # Signal analysis flow handlers
-            application.add_handler(CallbackQueryHandler(self.signal_technical_callback, pattern="^signal_technical$"))
-            application.add_handler(CallbackQueryHandler(self.signal_sentiment_callback, pattern="^signal_sentiment$"))
-            application.add_handler(CallbackQueryHandler(self.signal_calendar_callback, pattern="^signal_calendar$"))
-            application.add_handler(CallbackQueryHandler(self.signal_calendar_callback, pattern="^signal_flow_calendar_.*$"))
-            application.add_handler(CallbackQueryHandler(self.back_to_signal_callback, pattern="^back_to_signal$"))
-            application.add_handler(CallbackQueryHandler(self.back_to_signal_analysis_callback, pattern="^back_to_signal_analysis$"))
-            
-            # Signal from analysis
-            application.add_handler(CallbackQueryHandler(self.analyze_from_signal_callback, pattern="^analyze_from_signal_.*$"))
-            
-            # Ensure back_instrument is properly handled
-            application.add_handler(CallbackQueryHandler(self.back_instrument_callback, pattern="^back_instrument$"))
-            
-            # Catch-all handler for any other callbacks
-            application.add_handler(CallbackQueryHandler(self.button_callback))
-            
-            # Don't load signals here - it will be done in initialize_services
-            # self._load_signals()
-            
-            logger.info("Bot setup completed successfully")
-            
-    except Exception as e:
-        logger.error(f"Error setting up bot handlers: {str(e)}")
-        logger.exception(e)
-
-    @property
-    def signals_enabled(self):
-        """Get whether signals processing is enabled"""
-        return self._signals_enabled
-    
-    @signals_enabled.setter
-    def signals_enabled(self, value):
-        """Set whether signals processing is enabled"""
-        self._signals_enabled = bool(value)
-        logger.info(f"Signal processing is now {'enabled' if value else 'disabled'}")
-
-    async def _get_signal_related_trades(self, signal_id):
-    """Retrieve related trades from the database"""
-    try:
-        # Fetch the related trades data from the database
-        trades_data = await self.db.get_related_trades(signal_id)
-            
-        if trades_data:
-            return trades_data
-        else:
-            logger.warning(f"No related trades data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related trades: {str(e)}")
-        logger.exception(e)
-        return None
-
-
-from telegram.error import TelegramError, BadRequest
-import httpx
-import telegram.error  # Add this import for BadRequest error handling
-
-from trading_bot.services.database.db import Database
-from trading_bot.services.chart_service.chart import ChartService
-from trading_bot.services.sentiment_service.sentiment import MarketSentimentService
-from trading_bot.services.calendar_service import EconomicCalendarService
-from trading_bot.services.payment_service.stripe_service import StripeService
-from trading_bot.services.payment_service.stripe_config import get_subscription_features
-from trading_bot.services.telegram_service.states import (
-    MENU, ANALYSIS, SIGNALS, CHOOSE_MARKET, CHOOSE_INSTRUMENT, CHOOSE_STYLE,
-    CHOOSE_ANALYSIS, SIGNAL_DETAILS,
-    CALLBACK_MENU_ANALYSE, CALLBACK_MENU_SIGNALS, CALLBACK_ANALYSIS_TECHNICAL,
-    CALLBACK_ANALYSIS_SENTIMENT, CALLBACK_ANALYSIS_CALENDAR, CALLBACK_SIGNALS_ADD,
-    CALLBACK_SIGNALS_MANAGE, CALLBACK_BACK_MENU
-)
-import trading_bot.services.telegram_service.gif_utils as gif_utils
-
-# Initialize logger
-logger = logging.getLogger(__name__)
-
-# Major currencies to focus on
-MAJOR_CURRENCIES = ["USD", "EUR", "GBP", "JPY", "CHF", "AUD", "NZD", "CAD"]
-
-# Currency to flag emoji mapping
-CURRENCY_FLAG = {
-    "USD": "üá∫üá∏",
-    "EUR": "üá™üá∫",
-    "GBP": "üá¨üáß",
-    "JPY": "üáØüáµ",
-    "CHF": "üá®üá≠",
-    "AUD": "üá¶üá∫",
-    "NZD": "üá≥üáø",
-    "CAD": "üá®üá¶"
-}
-
-# Map of instruments to their corresponding currencies
-INSTRUMENT_CURRENCY_MAP = {
-    # Special case for global view
-    "GLOBAL": MAJOR_CURRENCIES,
-    
-    # Forex
-    "EURUSD": ["EUR", "USD"],
-    "GBPUSD": ["GBP", "USD"],
-    "USDJPY": ["USD", "JPY"],
-    "USDCHF": ["USD", "CHF"],
-    "AUDUSD": ["AUD", "USD"],
-    "NZDUSD": ["NZD", "USD"],
-    "USDCAD": ["USD", "CAD"],
-    "EURGBP": ["EUR", "GBP"],
-    "EURJPY": ["EUR", "JPY"],
-    "GBPJPY": ["GBP", "JPY"],
-    
-    # Indices (mapped to their related currencies)
-    "US30": ["USD"],
-    "US100": ["USD"],
-    "US500": ["USD"],
-    "UK100": ["GBP"],
-    "GER40": ["EUR"],
-    "FRA40": ["EUR"],
-    "ESP35": ["EUR"],
-    "JP225": ["JPY"],
-    "AUS200": ["AUD"],
-    
-    # Commodities (mapped to USD primarily)
-    "XAUUSD": ["USD", "XAU"],  # Gold
-    "XAGUSD": ["USD", "XAG"],  # Silver
-    "USOIL": ["USD"],          # Oil (WTI)
-    "UKOIL": ["USD", "GBP"],   # Oil (Brent)
-    
-    # Crypto
-    "BTCUSD": ["USD", "BTC"],
-    "ETHUSD": ["USD", "ETH"],
-    "LTCUSD": ["USD", "LTC"],
-    "XRPUSD": ["USD", "XRP"]
-}
-
-# Callback data constants
-CALLBACK_ANALYSIS_TECHNICAL = "analysis_technical"
-CALLBACK_ANALYSIS_SENTIMENT = "analysis_sentiment"
-CALLBACK_ANALYSIS_CALENDAR = "analysis_calendar"
-CALLBACK_BACK_MENU = "back_menu"
-CALLBACK_BACK_ANALYSIS = "back_to_analysis"
-CALLBACK_BACK_MARKET = "back_market"
-CALLBACK_BACK_INSTRUMENT = "back_instrument"
-CALLBACK_BACK_SIGNALS = "back_signals"
-CALLBACK_SIGNALS_ADD = "signals_add"
-CALLBACK_SIGNALS_MANAGE = "signals_manage"
-CALLBACK_MENU_ANALYSE = "menu_analyse"
-CALLBACK_MENU_SIGNALS = "menu_signals"
-
-# States
-MENU = 0
-CHOOSE_ANALYSIS = 1
-CHOOSE_SIGNALS = 2
-CHOOSE_MARKET = 3
-CHOOSE_INSTRUMENT = 4
-CHOOSE_STYLE = 5
-SHOW_RESULT = 6
-CHOOSE_TIMEFRAME = 7
-SIGNAL_DETAILS = 8
-SIGNAL = 9
-SUBSCRIBE = 10
-BACK_TO_MENU = 11  # Add this line
-
-# Messages
-WELCOME_MESSAGE = r"""
-<b>Sigmapips AI - Main Menu</b>
-
-Choose an option to access advanced trading support:
-
-Services:
-- <b>Technical Analysis</b> - Real-time chart analysis and key levels
-
-- <b>Market Sentiment</b> - Understand market trends and sentiment
-
-- <b>Economic Calendar</b> - Stay updated on market-moving events
-
-- <b>Trading Signals</b> - Get precise entry/exit points for your favorite pairs
-
-Select your option to continue:
-"""
-
-# Abonnementsbericht voor nieuwe gebruikers
-SUBSCRIPTION_WELCOME_MESSAGE = r"""
-<b>Welcome to Sigmapips AI!</b>
-
-To access all features, you need a subscription:
-
-<b>Trading Signals Subscription - $29.99/month</b>
-- Access to all trading signals (Forex, Crypto, Commodities, Indices)
-- Advanced timeframe analysis
-- Detailed chart analysis for each signal
-
-Click the button below to subscribe:
-"""
-
-MENU_MESSAGE = r"""
-Welcome to Sigmapips AI!
-
-Choose a command:
-
-/start - Set up new trading pairs
-Add new market/instrument/timeframe combinations to receive signals
-
-/manage - Manage your preferences
-View, edit or delete your saved trading pairs
-
-Need help? Use /help to see all available commands.
-"""
-
-HELP_MESSAGE = r"""
-Available commands:
-/menu - Show main menu
-/start - Set up new trading pairs
-/help - Show this help message
-"""
-
-# Start menu keyboard
-START_KEYBOARD = [
-    [InlineKeyboardButton("Analyze Market", callback_data=CALLBACK_MENU_ANALYSE)],
-    [InlineKeyboardButton("Trading Signals", callback_data=CALLBACK_MENU_SIGNALS)]
-]
-
-# Analysis menu keyboard
-ANALYSIS_KEYBOARD = [
-    [InlineKeyboardButton("Technical Analysis", callback_data=CALLBACK_ANALYSIS_TECHNICAL)],
-    [InlineKeyboardButton("Market Sentiment", callback_data=CALLBACK_ANALYSIS_SENTIMENT)],
-    [InlineKeyboardButton("Economic Calendar", callback_data=CALLBACK_ANALYSIS_CALENDAR)],
-    [InlineKeyboardButton("Back", callback_data=CALLBACK_BACK_MENU)]
-]
-
-# Signals menu keyboard
-SIGNALS_KEYBOARD = [
-    [InlineKeyboardButton("Add New Pairs", callback_data=CALLBACK_SIGNALS_ADD)],
-    [InlineKeyboardButton("Manage Signals", callback_data=CALLBACK_SIGNALS_MANAGE)],
-    [InlineKeyboardButton("Back", callback_data=CALLBACK_BACK_MENU)]
-]
-
-# Market keyboard voor signals
-MARKET_KEYBOARD_SIGNALS = [
-    [InlineKeyboardButton("Forex", callback_data="market_forex_signals")],
-    [InlineKeyboardButton("Crypto", callback_data="market_crypto_signals")],
-    [InlineKeyboardButton("Commodities", callback_data="market_commodities_signals")],
-    [InlineKeyboardButton("Indices", callback_data="market_indices_signals")],
-    [InlineKeyboardButton("Back", callback_data="back_signals")]
-]
-
-# Market keyboard voor analyse
-MARKET_KEYBOARD = [
-    [InlineKeyboardButton("Forex", callback_data="market_forex")],
-    [InlineKeyboardButton("Crypto", callback_data="market_crypto")],
-    [InlineKeyboardButton("Commodities", callback_data="market_commodities")],
-    [InlineKeyboardButton("Indices", callback_data="market_indices")],
-    [InlineKeyboardButton("Back", callback_data="back_analysis")]
-]
-
-# Market keyboard specifiek voor sentiment analyse
-MARKET_SENTIMENT_KEYBOARD = [
-    [InlineKeyboardButton("Forex", callback_data="market_forex_sentiment")],
-    [InlineKeyboardButton("Crypto", callback_data="market_crypto_sentiment")],
-    [InlineKeyboardButton("Commodities", callback_data="market_commodities_sentiment")],
-    [InlineKeyboardButton("Indices", callback_data="market_indices_sentiment")],
-    [InlineKeyboardButton("Back", callback_data="back_analysis")]
-]
-
-# Forex keyboard voor technical analyse
-FOREX_KEYBOARD = [
-    [
-        InlineKeyboardButton("EURUSD", callback_data="instrument_EURUSD_chart"),
-        InlineKeyboardButton("GBPUSD", callback_data="instrument_GBPUSD_chart"),
-        InlineKeyboardButton("USDJPY", callback_data="instrument_USDJPY_chart")
-    ],
-    [
-        InlineKeyboardButton("AUDUSD", callback_data="instrument_AUDUSD_chart"),
-        InlineKeyboardButton("USDCAD", callback_data="instrument_USDCAD_chart"),
-        InlineKeyboardButton("EURGBP", callback_data="instrument_EURGBP_chart")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Forex keyboard voor sentiment analyse
-FOREX_SENTIMENT_KEYBOARD = [
-    [
-        InlineKeyboardButton("EURUSD", callback_data="instrument_EURUSD_sentiment"),
-        InlineKeyboardButton("GBPUSD", callback_data="instrument_GBPUSD_sentiment"),
-        InlineKeyboardButton("USDJPY", callback_data="instrument_USDJPY_sentiment")
-    ],
-    [
-        InlineKeyboardButton("AUDUSD", callback_data="instrument_AUDUSD_sentiment"),
-        InlineKeyboardButton("USDCAD", callback_data="instrument_USDCAD_sentiment"),
-        InlineKeyboardButton("EURGBP", callback_data="instrument_EURGBP_sentiment")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Forex keyboard voor kalender analyse
-FOREX_CALENDAR_KEYBOARD = [
-    [
-        InlineKeyboardButton("EURUSD", callback_data="instrument_EURUSD_calendar"),
-        InlineKeyboardButton("GBPUSD", callback_data="instrument_GBPUSD_calendar"),
-        InlineKeyboardButton("USDJPY", callback_data="instrument_USDJPY_calendar")
-    ],
-    [
-        InlineKeyboardButton("AUDUSD", callback_data="instrument_AUDUSD_calendar"),
-        InlineKeyboardButton("USDCAD", callback_data="instrument_USDCAD_calendar"),
-        InlineKeyboardButton("EURGBP", callback_data="instrument_EURGBP_calendar")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Crypto keyboard voor analyse
-CRYPTO_KEYBOARD = [
-    [
-        InlineKeyboardButton("BTCUSD", callback_data="instrument_BTCUSD_chart"),
-        InlineKeyboardButton("ETHUSD", callback_data="instrument_ETHUSD_chart"),
-        InlineKeyboardButton("XRPUSD", callback_data="instrument_XRPUSD_chart")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Signal analysis keyboard
-SIGNAL_ANALYSIS_KEYBOARD = [
-    [InlineKeyboardButton("Technical Analysis", callback_data="signal_technical")],
-    [InlineKeyboardButton("Market Sentiment", callback_data="signal_sentiment")],
-    [InlineKeyboardButton("Economic Calendar", callback_data="signal_calendar")],
-    [InlineKeyboardButton("Back", callback_data="back_to_signal")]
-]
-
-# Crypto keyboard voor sentiment analyse
-CRYPTO_SENTIMENT_KEYBOARD = [
-    [
-        InlineKeyboardButton("BTCUSD", callback_data="instrument_BTCUSD_sentiment"),
-        InlineKeyboardButton("ETHUSD", callback_data="instrument_ETHUSD_sentiment"),
-        InlineKeyboardButton("XRPUSD", callback_data="instrument_XRPUSD_sentiment")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Indices keyboard voor analyse
-INDICES_KEYBOARD = [
-    [
-        InlineKeyboardButton("US30", callback_data="instrument_US30_chart"),
-        InlineKeyboardButton("US500", callback_data="instrument_US500_chart"),
-        InlineKeyboardButton("US100", callback_data="instrument_US100_chart")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Indices keyboard voor signals - Fix de "Terug" knop naar "Back"
-INDICES_KEYBOARD_SIGNALS = [
-    [
-        InlineKeyboardButton("US30", callback_data="instrument_US30_signals"),
-        InlineKeyboardButton("US500", callback_data="instrument_US500_signals"),
-        InlineKeyboardButton("US100", callback_data="instrument_US100_signals")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Commodities keyboard voor analyse
-COMMODITIES_KEYBOARD = [
-    [
-        InlineKeyboardButton("GOLD", callback_data="instrument_XAUUSD_chart"),
-        InlineKeyboardButton("SILVER", callback_data="instrument_XAGUSD_chart"),
-        InlineKeyboardButton("OIL", callback_data="instrument_USOIL_chart")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Commodities keyboard voor signals - Fix de "Terug" knop naar "Back"
-COMMODITIES_KEYBOARD_SIGNALS = [
-    [
-        InlineKeyboardButton("XAUUSD", callback_data="instrument_XAUUSD_signals"),
-        InlineKeyboardButton("XAGUSD", callback_data="instrument_XAGUSD_signals"),
-        InlineKeyboardButton("USOIL", callback_data="instrument_USOIL_signals")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Forex keyboard for signals
-FOREX_KEYBOARD_SIGNALS = [
-    [
-        InlineKeyboardButton("EURUSD", callback_data="instrument_EURUSD_signals"),
-        InlineKeyboardButton("GBPUSD", callback_data="instrument_GBPUSD_signals"),
-        InlineKeyboardButton("USDJPY", callback_data="instrument_USDJPY_signals")
-    ],
-    [
-        InlineKeyboardButton("USDCAD", callback_data="instrument_USDCAD_signals"),
-        InlineKeyboardButton("EURGBP", callback_data="instrument_EURGBP_signals")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Crypto keyboard for signals
-CRYPTO_KEYBOARD_SIGNALS = [
-    [
-        InlineKeyboardButton("BTCUSD", callback_data="instrument_BTCUSD_signals"),
-        InlineKeyboardButton("ETHUSD", callback_data="instrument_ETHUSD_signals"),
-        InlineKeyboardButton("XRPUSD", callback_data="instrument_XRPUSD_signals")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Indices keyboard voor sentiment analyse
-INDICES_SENTIMENT_KEYBOARD = [
-    [
-        InlineKeyboardButton("US30", callback_data="instrument_US30_sentiment"),
-        InlineKeyboardButton("US500", callback_data="instrument_US500_sentiment"),
-        InlineKeyboardButton("US100", callback_data="instrument_US100_sentiment")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Commodities keyboard voor sentiment analyse
-COMMODITIES_SENTIMENT_KEYBOARD = [
-    [
-        InlineKeyboardButton("GOLD", callback_data="instrument_XAUUSD_sentiment"),
-        InlineKeyboardButton("SILVER", callback_data="instrument_XAGUSD_sentiment"),
-        InlineKeyboardButton("OIL", callback_data="instrument_USOIL_sentiment")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Style keyboard
-STYLE_KEYBOARD = [
-    [InlineKeyboardButton("‚ö° Test (one_min)", callback_data="style_test")],
-    [InlineKeyboardButton("üèÉ Scalp (fifteen_min)", callback_data="style_scalp")],
-    [InlineKeyboardButton(" Intraday (one_hour)", callback_data="style_intraday")],
-    [InlineKeyboardButton("üåä Swing (four_hour)", callback_data="style_swing")],
-    [InlineKeyboardButton("Back", callback_data="back_instrument")]
-]
-
-# Timeframe mapping
-STYLE_TIMEFRAME_MAP = {
-    "test": "one_min",
-    "scalp": "fifteen_min",
-    "intraday": "one_hour",
-    "swing": "four_hour"
-}
-
-# Mapping of instruments to their allowed timeframes - updated 2023-03-23
-INSTRUMENT_TIMEFRAME_MAP = {
-    # H1 timeframe only
-    "AUDJPY": "H1", 
-    "AUDCHF": "H1",
-    "EURCAD": "H1",
-    "EURGBP": "H1",
-    "GBPCHF": "H1",
-    "HK50": "H1",
-    "NZDJPY": "H1",
-    "USDCHF": "H1",
-    "USDJPY": "H1",  # USDJPY toegevoegd voor signaalabonnementen
-    "XRPUSD": "H1",
-    
-    # H4 timeframe only
-    "AUDCAD": "H4",
-    "AU200": "H4", 
-    "CADCHF": "H4",
-    "EURCHF": "H4",
-    "EURUSD": "H4",
-    "GBPCAD": "H4",
-    "LINKUSD": "H4",
-    "NZDCHF": "H4",
-    
-    # M15 timeframe only
-    "DOGEUSD": "M15",
-    "GBPNZD": "M15",
-    "NZDUSD": "M15",
-    "SOLUSD": "M15",
-    "UK100": "M15",
-    "XAUUSD": "M15",
-    
-    # M30 timeframe only
-    "BNBUSD": "M30",
-    "DOTUSD": "M30",
-    "ETHUSD": "M30",
-    "EURAUD": "M30",
-    "EURJPY": "M30",
-    "GBPAUD": "M30",
-    "GBPUSD": "M30",
-    "NZDCAD": "M30",
-    "US30": "M30",
-    "US500": "M30",
-    "USDCAD": "M30",
-    "XLMUSD": "M30",
-    "XTIUSD": "M30",
-    "DE40": "M30",
-    "BTCUSD": "M30",  # Added for consistency with CRYPTO_KEYBOARD_SIGNALS
-    "US100": "M30",   # Added for consistency with INDICES_KEYBOARD_SIGNALS
-    "XAGUSD": "M15",  # Added for consistency with COMMODITIES_KEYBOARD_SIGNALS
-    "USOIL": "M30"    # Added for consistency with COMMODITIES_KEYBOARD_SIGNALS
-    
-    # Removed as requested: EU50, FR40, LTCUSD
-}
-
-# Map common timeframe notations
-TIMEFRAME_DISPLAY_MAP = {
-    "M15": "15 Minutes",
-    "M30": "30 Minutes", 
-    "H1": "1 Hour",
-    "H4": "4 Hours"
-}
-
-# Voeg deze functie toe aan het begin van bot.py, na de imports
-def _detect_market(instrument: str) -> str:
-    """Detecteer market type gebaseerd op instrument"""
-    instrument = instrument.upper()
-    
-    # Commodities eerst checken
-    commodities = [
-        "XAUUSD",  # Gold
-        "XAGUSD",  # Silver
-        "WTIUSD",  # Oil WTI
-        "BCOUSD",  # Oil Brent
-        "USOIL",   # Oil WTI (alternative symbol)
-    ]
-    if instrument in commodities:
-        logger.info(f"Detected {instrument} as commodity")
-        return "commodities"
-    
-    # Crypto pairs
-    crypto_base = ["BTC", "ETH", "XRP", "SOL", "BNB", "ADA", "DOT", "LINK"]
-    if any(c in instrument for c in crypto_base):
-        logger.info(f"Detected {instrument} as crypto")
-        return "crypto"
-    
-    # Major indices
-    indices = [
-        "US30", "US500", "US100",  # US indices
-        "UK100", "DE40", "FR40",   # European indices
-        "JP225", "AU200", "HK50"   # Asian indices
-    ]
-    if instrument in indices:
-        logger.info(f"Detected {instrument} as index")
-        return "indices"
-    
-    # Forex pairs als default
-    logger.info(f"Detected {instrument} as forex")
-    return "forex"
-
-# Voeg dit toe als decorator functie bovenaan het bestand na de imports
-def require_subscription(func):
-    """Check if user has an active subscription"""
-    async def wrapper(self, update: Update, context: ContextTypes.DEFAULT_TYPE, *args, **kwargs):
-        user_id = update.effective_user.id
-        
-        # Check subscription status
-        is_subscribed = await self.db.is_user_subscribed(user_id)
-        
-        # Check if payment has failed
-        payment_failed = await self.db.has_payment_failed(user_id)
-        
-        if is_subscribed and not payment_failed:
-            # User has subscription, proceed with function
-            return await func(self, update, context, *args, **kwargs)
-        else:
-            if payment_failed:
-                # Show payment failure message
-                failed_payment_text = f"""
- <b>Subscription Payment Failed</b> 
-
-Your subscription payment could not be processed and your service has been deactivated.
-
-To continue using Sigmapips AI and receive trading signals, please reactivate your subscription by clicking the button below.
-                """
-                
-                # Use direct URL link for reactivation
-                reactivation_url = "https://buy.stripe.com/9AQcPf3j63HL5JS145"
-                
-                # Create button for reactivation
-                keyboard = [
-                    [InlineKeyboardButton("üîÑ Reactivate Subscription", url=reactivation_url)]
-                ]
-            else:
-                # Show subscription screen with the welcome message from the screenshot
-                failed_payment_text = f"""
- <b>Welcome to Sigmapips AI!</b> 
-
-<b>Discover powerful trading signals for various markets:</b>
-- <b>Forex</b> - Major and minor currency pairs
-- <b>Crypto</b> - Bitcoin, Ethereum and other top cryptocurrencies
-- <b>Indices</b> - Global market indices
-- <b>Commodities</b> - Gold, silver and oil
-
-<b>Features:</b>
- Real-time trading signals
-
- Multi-timeframe analysis (timeframes)
-
- Advanced chart analysis
-
- Sentiment indicators
-
- Economic calendar integration
-
-<b>Start today with a FREE 14-day trial!</b>
-                """
-                
-                # Use direct URL link instead of callback for the trial button
-                reactivation_url = "https://buy.stripe.com/3cs3eF9Hu9256NW9AA"
-                
-                # Create button for trial
-                keyboard = [
-                    [InlineKeyboardButton("üî• Start 14-day FREE Trial", url=reactivation_url)]
-                ]
-            
-            # Handle both message and callback query updates
-            if update.callback_query:
-                await update.callback_query.answer()
-                await update.callback_query.edit_message_text(
-                    text=failed_payment_text,
-                    reply_markup=InlineKeyboardMarkup(keyboard),
-                    parse_mode=ParseMode.HTML
-                )
-            else:
-                await update.message.reply_text(
-                    text=failed_payment_text,
-                    reply_markup=InlineKeyboardMarkup(keyboard),
-                    parse_mode=ParseMode.HTML
-                )
-            return MENU
-    
-    return wrapper
-
-# API keys with robust sanitization
-PERPLEXITY_API_KEY = os.getenv("PERPLEXITY_API_KEY", "").strip()
-OPENAI_API_KEY = os.getenv("OPENAI_API_KEY", "").strip()  # Changed from DeepSeek to OpenAI
-
-# Only using OpenAI's o4-mini now
-# No Tavily API key needed anymore
-logger.info("Using only OpenAI o4-mini for Market Sentiment service")
-
-# Log OpenAI API key (partially masked)
-if OPENAI_API_KEY:
-    # Better masking for privacy and security
-    masked_key = f"sk-p...{OPENAI_API_KEY[-4:]}" if len(OPENAI_API_KEY) > 8 else "sk-p..."
-    logger.info(f"Using OpenAI API key: {masked_key}")
-    
-    # Validate the key format
-    from trading_bot.config import validate_openai_key
-    if not validate_openai_key(OPENAI_API_KEY):
-        logger.warning("OpenAI API key format is invalid. AI services may not work correctly.")
-else:
-    logger.warning("No OpenAI API key configured. AI services will be disabled.")
-    
-# Set environment variables for the API keys with sanitization
-os.environ["PERPLEXITY_API_KEY"] = PERPLEXITY_API_KEY
-os.environ["OPENAI_API_KEY"] = OPENAI_API_KEY  # Changed from DeepSeek to OpenAI
-# No Tavily environment needed
-
-class TelegramService:
-    def __init__(self, db: Database, stripe_service=None, bot_token: Optional[str] = None, proxy_url: Optional[str] = None, lazy_init: bool = False):
-        """Initialize the bot with given database and config."""
-        # Database connection
-        self.db = db
-        
-        # Setup configuration 
-        self.stripe_service = stripe_service
-        self.user_signals = {}
-        self.signals_dir = "data/signals"
-        self.signals_enabled_val = True
-        self.polling_started = False
-        self.admin_users = [2004519703]  # Updated with correct Telegram ID from logs
-        self._signals_enabled = True  # Enable signals by default
-        
-        # Setup logger
-        self.logger = logging.getLogger(__name__)
-        
-        # GIF utilities for UI
-        self.gif_utils = gif_utils  # Initialize gif_utils as an attribute
-        
-        # Setup the bot and application
-        self.bot = None
-        self.application = None
-        
-        # Telegram Bot configuratie
-        self.bot_token = bot_token or os.getenv("TELEGRAM_BOT_TOKEN", "")
-        self.token = self.bot_token  # Aliased for backward compatibility
-        self.proxy_url = proxy_url or os.getenv("TELEGRAM_PROXY_URL", "")
-        
-        # Configure custom request handler with improved connection settings
-        request = HTTPXRequest(
-            connection_pool_size=50,  # Increase from 20 to 50
-            connect_timeout=15.0,     # Increase from 10.0 to 15.0
-            read_timeout=45.0,        # Increase from 30.0 to 45.0
-            write_timeout=30.0,       # Increase from 20.0 to 30.0
-            pool_timeout=60.0,        # Increase from 30.0 to 60.0
-        )
-        
-        # Initialize the bot directly with connection pool settings
-        self.bot = Bot(token=self.bot_token, request=request)
-        self.application = None  # Will be initialized in setup()
-        
-        # Webhook configuration
-        self.webhook_url = os.getenv("WEBHOOK_URL", "")
-        self.webhook_path = "/webhook"  # Always use this path
-        if self.webhook_url.endswith("/"):
-            self.webhook_url = self.webhook_url[:-1]  # Remove trailing slash
-            
-        logger.info(f"Bot initialized with webhook URL: {self.webhook_url} and path: {self.webhook_path}")
-        
-        # Initialize API services
-        self.chart_service = ChartService()  # Initialize chart service
-        # Lazy load services only when needed
-        self._calendar_service = None
-        self._sentiment_service = None
-        
-        # Don't use asyncio.create_task here - it requires a running event loop
-        # We'll initialize chart service later when the event loop is running
-        
-        # Bot application initialization
-        self.persistence = None
-        self.bot_started = False
-        
-        # Cache for sentiment analysis
-        self.sentiment_cache = {}
-        self.sentiment_cache_ttl = 60 * 60  # 1 hour in seconds
-        
-        # Start the bot
-    try:
-            # Check for bot token
-            if not self.bot_token:
-                raise ValueError("Missing Telegram bot token")
-            
-            # Initialize the bot
-            self.bot = Bot(token=self.bot_token)
-        
-            # Initialize the application
-            self.application = Application.builder().bot(self.bot).build()
-        
-            # Register the handlers
-            self._register_handlers(self.application)
-            
-            # Initialize signals dictionary but don't load them yet (will be done in initialize_services)
-            self.user_signals = {}
-        
-            logger.info("Telegram service initialized")
-            
-            # Keep track of processed updates
-            self.processed_updates = set()
-            
-    except Exception as e:
-        logger.error(f"Error initializing Telegram service: {str(e)}")
-        raise
-
-    async def initialize_services(self):
-        """Initialize services that require an asyncio event loop"""
-        try:
-            # Initialize chart service
-            await self.chart_service.initialize()
-            logger.info("Chart service initialized")
-            
-            # Load stored signals
-            await self._load_signals()
-            logger.info("Signals loaded")
-            
-            # Schedule periodic cleanup of old signals
-            if hasattr(self, 'db') and self.db and self.db.using_redis:
-                # Run initial cleanup
-                cleaned = await self._cleanup_old_signals(max_age_days=7)
-                logger.info(f"Initial signal cleanup completed, removed {cleaned} old signals")
-                
-                # Schedule periodic cleanup (every 24 hours)
-                async def periodic_cleanup():
-                    while True:
-                        try:
-                            # Wait for 24 hours
-                            await asyncio.sleep(24 * 60 * 60)
-                            # Run cleanup
-                            cleaned = await self._cleanup_old_signals(max_age_days=7)
-                            logger.info(f"Periodic signal cleanup completed, removed {cleaned} old signals")
-                        except Exception as e:
-                            logger.error(f"Error in periodic signal cleanup: {str(e)}")
-                
-                # Start the periodic cleanup task
-                asyncio.create_task(periodic_cleanup())
-                logger.info("Scheduled periodic signal cleanup")
-        except Exception as e:
-            logger.error(f"Error initializing services: {str(e)}")
-            raise
-            
-    # Calendar service helpers
-    @property
-    def calendar_service(self):
-        """Lazy loaded calendar service"""
-        if self._calendar_service is None:
-            # Only initialize the calendar service when it's first accessed
-            self.logger.info("Lazy loading calendar service")
-            self._calendar_service = EconomicCalendarService()
-        return self._calendar_service
-        
-    def _get_calendar_service(self):
-        """Get the calendar service instance"""
-        self.logger.info("Getting calendar service")
-        return self.calendar_service
-
-    async def _format_calendar_events(self, calendar_data):
-        """Format the calendar data into a readable HTML message"""
-        self.logger.info(f"Formatting calendar data with {len(calendar_data)} events")
-        if not calendar_data:
-            return "<b>Economic Calendar</b>\n\nNo economic events found for today."
-        
-        # Sort events by time
-        try:
-            # Try to parse time for sorting
-            def parse_time_for_sorting(event):
-                time_str = event.get('time', '')
-                try:
-                    # Extract hour and minute if in format like "08:30 EST"
-                    if ':' in time_str:
-                        parts = time_str.split(' ')[0].split(':')
-                        hour = int(parts[0])
-                        minute = int(parts[1])
-                        return hour * 60 + minute
-                    return 0
-                except:
-                    return 0
-            
-            # Sort the events by time
-            sorted_events = sorted(calendar_data, key=parse_time_for_sorting)
-        except Exception as e:
-            self.logger.error(f"Error sorting calendar events: {str(e)}")
-            sorted_events = calendar_data
-        
-        # Format the message
-        message = "<b>Economic Calendar</b>\n\n"
-        
-        # Get current date
-        current_date = datetime.now().strftime("%B %d, %Y")
-        message += f"<b>Date:</b> {current_date}\n\n"
-        
-        # Add impact legend
-        message += "<b>Impact:</b> üî¥ High   üü† Medium   üü¢ Low\n\n"
-        
-        # Group events by country
-        events_by_country = {}
-        for event in sorted_events:
-            country = event.get('country', 'Unknown')
-            if country not in events_by_country:
-                events_by_country[country] = []
-            events_by_country[country].append(event)
-        
-        # Format events by country
-        for country, events in events_by_country.items():
-            country_flag = CURRENCY_FLAG.get(country, '')
-            message += f"<b>{country_flag} {country}</b>\n"
-            
-            for event in events:
-                time = event.get('time', 'TBA')
-                title = event.get('title', 'Unknown Event')
-                impact = event.get('impact', 'Low')
-                impact_emoji = {'High': 'üî¥', 'Medium': 'üü†', 'Low': 'üü¢'}.get(impact, 'üü¢')
-                
-                message += f"{time} - {impact_emoji} {title}\n"
-            
-            message += "\n"  # Add extra newline between countries
-        
-        return message
-        
-    # Utility functions that might be missing
-    async def update_message(self, query, text, keyboard=None, parse_mode=ParseMode.HTML):
-        """Utility to update a message with error handling"""
-        try:
-            # Check if the message is too long for Telegram caption limits (1024 chars)
-            MAX_CAPTION_LENGTH = 1000  # Slightly under the 1024 limit for safety
-            MAX_MESSAGE_LENGTH = 4000  # Telegram message limit
-            
-            # Log message length for debugging
-            logger.info(f"Updating message (length: {len(text)} chars)")
-            
-            # If message is too long for a caption but ok for a text message
-            if len(text) > MAX_CAPTION_LENGTH and len(text) <= MAX_MESSAGE_LENGTH:
-                logger.info("Message too long for caption but ok for text message")
-                # Try to edit message text first
-                await query.edit_message_text(
-                    text=text,
-                    reply_markup=keyboard,
-                    parse_mode=parse_mode
-                )
-                return True
-            # If message is too long even for a text message
-            elif len(text) > MAX_MESSAGE_LENGTH:
-                logger.warning(f"Message too long ({len(text)} chars), truncating")
-                # Find a good breaking point
-                truncated = text[:MAX_MESSAGE_LENGTH-100]
-                
-                # Try to break at a paragraph
-                last_newline = truncated.rfind('\n\n')
-                if last_newline > MAX_MESSAGE_LENGTH * 0.8:  # If we can keep at least 80% of the text
-                    truncated = truncated[:last_newline]
-                    
-                # Add indicator that text was truncated
-                truncated += "\n\n<i>... (message truncated)</i>"
-                
-                # Try to edit message text with truncated content
-                await query.edit_message_text(
-                    text=truncated,
-                    reply_markup=keyboard,
-                    parse_mode=parse_mode
-                )
-                return True
-            else:
-                # Normal case - message is within limits
-                # Try to edit message text first
-                await query.edit_message_text(
-                    text=text,
-                    reply_markup=keyboard,
-                    parse_mode=parse_mode
-                )
-                return True
-        except Exception as e:
-            logger.warning(f"Could not update message text: {str(e)}")
-            
-            # If text update fails, try to edit caption
-            try:
-                # Check if caption is too long
-                MAX_CAPTION_LENGTH = 1000  # Slightly under the 1024 limit for safety
-                
-                if len(text) > MAX_CAPTION_LENGTH:
-                    logger.warning(f"Caption too long ({len(text)} chars), truncating")
-                    # Find a good breaking point
-                    truncated = text[:MAX_CAPTION_LENGTH-100]
-                    
-                    # Try to break at a paragraph
-                    last_newline = truncated.rfind('\n\n')
-                    if last_newline > MAX_CAPTION_LENGTH * 0.8:  # If we can keep at least 80% of the text
-                        truncated = truncated[:last_newline]
-                        
-                    # Add indicator that text was truncated
-                    truncated += "\n\n<i>... (message truncated)</i>"
-                    
-                    # Use truncated text for caption
-                    await query.edit_message_caption(
-                        caption=truncated,
-                        reply_markup=keyboard,
-                        parse_mode=parse_mode
-                    )
-                else:
-                    # Caption is within limits
-                    await query.edit_message_caption(
-                        caption=text,
-                        reply_markup=keyboard,
-                        parse_mode=parse_mode
-                    )
-                return True
-            except Exception as e2:
-                logger.error(f"Could not update caption either: {str(e2)}")
-                
-                # As a last resort, send a new message
-                try:
-                    chat_id = query.message.chat_id
-                    
-                    # Check if message is too long
-                    MAX_MESSAGE_LENGTH = 4000  # Telegram message limit
-                    
-                    if len(text) > MAX_MESSAGE_LENGTH:
-                        logger.warning(f"New message too long ({len(text)} chars), truncating")
-                        # Find a good breaking point
-                        truncated = text[:MAX_MESSAGE_LENGTH-100]
-                        
-                        # Try to break at a paragraph
-                        last_newline = truncated.rfind('\n\n')
-                        if last_newline > MAX_MESSAGE_LENGTH * 0.8:  # If we can keep at least 80% of the text
-                            truncated = truncated[:last_newline]
-                            
-                        # Add indicator that text was truncated
-                        truncated += "\n\n<i>... (message truncated)</i>"
-                        
-                        # Use truncated text for new message
-                        await query.bot.send_message(
-                            chat_id=chat_id,
-                            text=truncated,
-                            reply_markup=keyboard,
-                            parse_mode=parse_mode
-                        )
-                    else:
-                        # Message is within limits
-                        await query.bot.send_message(
-                            chat_id=chat_id,
-                            text=text,
-                            reply_markup=keyboard,
-                            parse_mode=parse_mode
-                        )
-                    return True
-                except Exception as e3:
-                    logger.error(f"Failed to send new message: {str(e3)}")
-                    return False
-    
-    # Missing handler implementations
-    async def back_signals_callback(self, update: Update, context=None) -> int:
-        """Handle back_signals button press"""
-        query = update.callback_query
-        await query.answer()
-        
-        logger.info("back_signals_callback called")
-        
-        # Make sure we're in the signals flow context
-        if context and hasattr(context, 'user_data'):
-            # Reset signal flow flags
-            context.user_data['from_signal'] = False
-            context.user_data['in_signal_flow'] = False
-            logger.info(f"Reset signal flow flags: from_signal=False, in_signal_flow=False")
-            # Keep is_signals_context flag but reset from_signal flag
-            context.user_data['is_signals_context'] = True
-            context.user_data['from_signal'] = False
-            
-            # Clear other specific analysis keys but maintain signals context
-            keys_to_remove = [
-                'instrument', 'market', 'analysis_type', 'timeframe', 
-                'signal_id', 'signal_instrument', 'signal_direction', 'signal_timeframe',
-                'loading_message'
-            ]
-
-            for key in keys_to_remove:
-                if key in context.user_data:
-                    del context.user_data[key]
-            logger.info(f"Updated context in back_signals_callback: {context.user_data}")
-        
-        # Create keyboard for signal menu
-        keyboard = [
-            [InlineKeyboardButton(" Add Signal", callback_data="signals_add")],
-            [InlineKeyboardButton("Manage Signals", callback_data="signals_manage")],
-            [InlineKeyboardButton("Back to Menu", callback_data="back_menu")]
-        ]
-        reply_markup = InlineKeyboardMarkup(keyboard)
-        
-        # Get the signals GIF URL for better UX
-        signals_gif_url = "https://media.giphy.com/media/gSzIKNrqtotEYrZv7i/giphy.gif"
-        
-        # Update the message
-        await self.update_message(
-            query=query,\n            text="<b> Signal Management</b>\n\nManage your trading signals",
-            keyboard=reply_markup
-        )
-        
-        return SIGNALS
-        
-    async def get_subscribers_for_instrument(self, instrument: str, timeframe: str = None) -> List[int]:
-        """
-        Get a list of subscribed user IDs for a specific instrument and timeframe
-        
-        Args:
-            instrument: The trading instrument (e.g., EURUSD)
-            timeframe: Optional timeframe filter
-            
-        Returns:
-            List of subscribed user IDs
-        """
-    try:
-            logger.info(f"Getting subscribers for {instrument} timeframe: {timeframe}")
-            
-            # Get all subscribers from the database
-            # Note: Using get_signal_subscriptions instead of find_all
-            subscribers = await self.db.get_signal_subscriptions(instrument, timeframe)
-            
-            if not subscribers:
-                logger.warning(f"No subscribers found for {instrument}")
-                return []
-                
-            # Filter out subscribers that don't have an active subscription
-            active_subscribers = []
-            for subscriber in subscribers:
-                user_id = subscriber['user_id']
-                
-                # Check if user is subscribed
-                is_subscribed = await self.db.is_user_subscribed(user_id)
-                
-                # Check if payment has failed
-                payment_failed = await self.db.has_payment_failed(user_id)
-                
-                if is_subscribed and not payment_failed:
-                    active_subscribers.append(user_id)
-                else:
-                    logger.info(f"User {user_id} doesn't have an active subscription, skipping signal")
-            
-            return active_subscribers
-            
-    except Exception as e:
-        logger.error(f"Error getting subscribers: {str(e)}")
-            # FOR TESTING: Add admin users if available
-            if hasattr(self, 'admin_users') and self.admin_users:
-                logger.info(f"Returning admin users for testing: {self.admin_users}")
-                return self.admin_users
-            return []
-
-    async def process_signal(self, signal_data: Dict[str, Any]) -> bool:
-        """
-        Process a trading signal from TradingView webhook or API
-        
-        Supports two formats:
-        1. TradingView format: instrument, signal, price, sl, tp1, tp2, tp3, interval
-        2. Custom format: instrument, direction, entry, stop_loss, take_profit, timeframe
-        
-        Returns:
-            bool: True if signal was processed successfully, False otherwise
-        """
-        try:
-            # Log the incoming signal data
-            logger.info(f"Processing signal: {signal_data}")
-            
-            # Check which format we're dealing with and normalize it
-            instrument = signal_data.get('instrument')
-            
-            # Handle TradingView format (price, sl, interval)
-            if 'price' in signal_data and 'sl' in signal_data:
-                price = signal_data.get('price')
-                sl = signal_data.get('sl')
-                tp1 = signal_data.get('tp1')
-                tp2 = signal_data.get('tp2')
-                tp3 = signal_data.get('tp3')
-                interval = signal_data.get('interval', 'one_hour')
-                
-                # Determine signal direction based on price and SL relationship
-                direction = "BUY" if float(sl) < float(price) else "SELL"
-                
-                # Create normalized signal data
-                normalized_data = {
-                    'instrument': instrument,
-                    'direction': direction,
-                    'entry': price,
-                    'stop_loss': sl,
-                    'take_profit': tp1,  # Use first take profit level
-                    'timeframe': interval
-                }
-                
-                # Add optional fields if present
-                normalized_data['tp1'] = tp1
-                normalized_data['tp2'] = tp2
-                normalized_data['tp3'] = tp3
-                
-            # Handle custom format (direction, entry, stop_loss, timeframe)
-            elif 'direction' in signal_data and 'entry' in signal_data:
-                direction = signal_data.get('direction')
-                entry = signal_data.get('entry')
-                stop_loss = signal_data.get('stop_loss')
-                take_profit = signal_data.get('take_profit')
-                timeframe = signal_data.get('timeframe', 'one_hour')
-                
-                # Create normalized signal data
-                normalized_data = {
-                    'instrument': instrument,
-                    'direction': direction,
-                    'entry': entry,
-                    'stop_loss': stop_loss,
-                    'take_profit': take_profit,
-                    'timeframe': timeframe
-                }
-            else:
-                logger.error(f"Missing required signal data")
-                return False
-            
-            # Basic validation
-            if not normalized_data.get('instrument') or not normalized_data.get('direction') or not normalized_data.get('entry'):
-                logger.error(f"Missing required fields in normalized signal data: {normalized_data}")
-                return False
-                
-            # Create signal ID for tracking
-            signal_id = f"{normalized_data['instrument']}_{normalized_data['direction']}_{normalized_data['timeframe']}_{int(time.time())}"
-            
-            # Format the signal message
-            message = self._format_signal_message(normalized_data)
-            
-            # Determine market type for the instrument
-            market_type = _detect_market(instrument)
-            
-            # Store the full signal data for reference
-            normalized_data['id'] = signal_id
-            normalized_data['timestamp'] = datetime.now().isoformat()
-            normalized_data['message'] = message
-            normalized_data['market'] = market_type
-            
-            # Save signal for history tracking
-            if not os.path.exists(self.signals_dir):
-                os.makedirs(self.signals_dir, exist_ok=True)
-                
-            # Save to signals directory
-            with open(f"{self.signals_dir}/{signal_id}.json", 'w') as f:
-                json.dump(normalized_data, f)
-            
-            # FOR TESTING: Always send to admin for testing
-            if hasattr(self, 'admin_users') and self.admin_users:
-                try:
-                    logger.info(f"Sending signal to admin users for testing: {self.admin_users}")
-                    for admin_id in self.admin_users:
-                        # Prepare keyboard with analysis options
-                        keyboard = [
-                            [InlineKeyboardButton("Analyze Market", callback_data=f"analyze_from_signal_{instrument}_{signal_id}")]
-                        ]
-                        
-                        # Send the signal
-                        await self.bot.send_message(
-                            chat_id=admin_id,
-                            text=message,
-                            parse_mode=ParseMode.HTML,
-                            reply_markup=InlineKeyboardMarkup(keyboard)
-                        )
-                        logger.info(f"Test signal sent to admin {admin_id}")
-                        
-                        # Store signal reference for quick access
-                        if not hasattr(self, 'user_signals'):
-                            self.user_signals = {}
-                            
-                        admin_str_id = str(admin_id)
-                        if admin_str_id not in self.user_signals:
-                            self.user_signals[admin_str_id] = {}
-                        
-                        self.user_signals[admin_str_id][signal_id] = normalized_data
-            except Exception as e:
-                logger.error(f"Error sending test signal to admin: {str(e)}")
-            
-            # Get subscribers for this instrument
-            timeframe = normalized_data.get('timeframe', 'one_hour')
-            subscribers = await self.get_subscribers_for_instrument(instrument, timeframe)
-            
-            if not subscribers:
-                logger.warning(f"No subscribers found for {instrument}")
-                return True  # Successfully processed, just no subscribers
-            
-            # Send signal to all subscribers
-            logger.info(f"Sending signal {signal_id} to {len(subscribers)} subscribers")
-            
-            sent_count = 0
-            for user_id in subscribers:
-                try:
-                    # Prepare keyboard with analysis options
-                    keyboard = [
-                        [InlineKeyboardButton("Analyze Market", callback_data=f"analyze_from_signal_{instrument}_{signal_id}")]
-                    ]
-                    
-                    # Send the signal
-                    await self.bot.send_message(
-                        chat_id=user_id,
-                        text=message,
-                        parse_mode=ParseMode.HTML,
-                        reply_markup=InlineKeyboardMarkup(keyboard)
-                    )
-                    
-                    sent_count += 1
-                    
-                    # Store signal reference for quick access
-                    if not hasattr(self, 'user_signals'):
-                        self.user_signals = {}
-                        
-                    user_str_id = str(user_id)
-                    if user_str_id not in self.user_signals:
-                        self.user_signals[user_str_id] = {}
-                    
-                    self.user_signals[user_str_id][signal_id] = normalized_data
-                    
-            except Exception as e:
-                logger.error(f"Error sending signal to user {user_id}: {str(e)}")
-            
-            logger.info(f"Successfully sent signal {signal_id} to {sent_count}/{len(subscribers)} subscribers")
-            return True
-            
-    except Exception as e:
-        logger.error(f"Error processing signal: {str(e)}")
-        logger.exception(e)
-            return False
-
-    def _format_signal_message(self, signal_data: Dict[str, Any]) -> str:
-        """Format signal data into a nice message for Telegram"""
-    try:
-            # Extract fields from signal data
-            instrument = signal_data.get('instrument', 'Unknown')
-            direction = signal_data.get('direction', 'Unknown')
-            entry = signal_data.get('entry', 'Unknown')
-            stop_loss = signal_data.get('stop_loss')
-            take_profit = signal_data.get('take_profit')
-            timeframe = signal_data.get('timeframe', 'one_hour')
-            
-            # Get multiple take profit levels if available
-            tp1 = signal_data.get('tp1', take_profit)
-            tp2 = signal_data.get('tp2')
-            tp3 = signal_data.get('tp3')
-            
-            # Add emoji based on direction
-            direction_emoji = "üü¢" if direction.upper() == "BUY" else "üî¥"
-            
-            # Format the message with multiple take profits if available
-            message = "<b> New Trading Signal </b>\n"\n\n"
-            message += f"<b>Instrument:</b> {instrument}\n"
-            message += f"<b>Action:</b> {direction.upper()} {direction_emoji}\n\n"
-            message += f"<b>Entry Price:</b> {entry}\n"
-            
-            if stop_loss:
-                message += f"<b>Stop Loss:</b> {stop_loss} üî¥\n"
-            
-            # Add take profit levels
-            if tp1:
-                message += f"<b>Take Profit 1:</b> {tp1} \n"
-            if tp2:
-                message += f"<b>Take Profit 2:</b> {tp2} \n"
-            if tp3:
-                message += f"<b>Take Profit 3:</b> {tp3} \n"
-            
-            message += f"\n<b>Timeframe:</b> {timeframe}\n"
-            message += f"<b>Strategy:</b> TradingView Signal\n\n"
-            
-            message += "‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî\n\n"
-            message += "<b>Risk Management:</b>\n"
-            message += "- Position size: 1-2% max\n"
-            message += "- Use proper stop loss\n"
-            message += "- Follow your trading plan\n\n"
-            
-            message += "‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî\n\n"
-            
-            # Generate AI verdict
-            ai_verdict = f"The {instrument} {direction.lower()} signal shows a promising setup with defined entry at {entry} and stop loss at {stop_loss}. Multiple take profit levels provide opportunities for partial profit taking."
-            message += f"<b>ü§ñ SigmaPips AI Verdict:</b>\n{ai_verdict}"
-            
-            return message
-            
-    except Exception as e:
-        logger.error(f"Error formatting signal message: {str(e)}")
-            # Return simple message on error
-            return f"New {signal_data.get('instrument', 'Unknown')} {signal_data.get('direction', 'Unknown')} Signal"
-
-    def _register_handlers(self, application):
-        """Register event handlers for bot commands and callback queries"""
-    try:
-            logger.info("Registering command handlers")
-            
-            # Initialize the application without using run_until_complete
-        try:
-                # Instead of using loop.run_until_complete, directly call initialize 
-                # which will be properly awaited by the caller
-                self.init_task = application.initialize()
-                logger.info("Telegram application initialization ready to be awaited")
-            except Exception as init_e:
-            logger.error(f"Error during application initialization: {str(init_e)}")
-            logger.exception(init_e)
-                
-            # Set bot commands for menu
-            commands = [
-                BotCommand("start", "Start the bot and get the welcome message"),
-                BotCommand("menu", "Show the main menu"),
-                BotCommand("help", "Show available commands and how to use the bot")
-            ]
-            
-            # Store the set_commands_task to be awaited later
-        try:
-                # Instead of asyncio.create_task, we will await this in the startup event
-                self.set_commands_task = self.bot.set_my_commands(commands)
-                logger.info("Bot commands ready to be set")
-            except Exception as cmd_e:
-            logger.error(f"Error preparing bot commands: {str(cmd_e)}")
-            
-            # Register command handlers
-            application.add_handler(CommandHandler("start", self.start_command))
-            application.add_handler(CommandHandler("menu", self.menu_command))
-            application.add_handler(CommandHandler("help", self.help_command))
-            
-            # Register secret admin commands
-            application.add_handler(CommandHandler("set_subscription", self.set_subscription_command))
-            application.add_handler(CommandHandler("set_payment_failed", self.set_payment_failed_command))
-            logger.info("Registered secret admin commands")
-            
-            # Register callback handlers
-            application.add_handler(CallbackQueryHandler(self.menu_analyse_callback, pattern="^menu_analyse$"))
-            application.add_handler(CallbackQueryHandler(self.menu_signals_callback, pattern="^menu_signals$"))
-            application.add_handler(CallbackQueryHandler(self.signals_add_callback, pattern="^signals_add$"))
-            application.add_handler(CallbackQueryHandler(self.signals_manage_callback, pattern="^signals_manage$"))
-            application.add_handler(CallbackQueryHandler(self.market_callback, pattern="^market_"))
-            application.add_handler(CallbackQueryHandler(self.instrument_callback, pattern="^instrument_(?!.*_signals)"))
-            application.add_handler(CallbackQueryHandler(self.instrument_signals_callback, pattern="^instrument_.*_signals$"))
-            
-            # Add handler for back buttons
-            application.add_handler(CallbackQueryHandler(self.back_market_callback, pattern="^back_market$"))
-            application.add_handler(CallbackQueryHandler(self.back_instrument_callback, pattern="^back_instrument$"))
-            application.add_handler(CallbackQueryHandler(self.back_signals_callback, pattern="^back_signals$"))
-            application.add_handler(CallbackQueryHandler(self.back_menu_callback, pattern="^back_menu$"))
-            
-            # Analysis handlers for regular flow
-            application.add_handler(CallbackQueryHandler(self.analysis_technical_callback, pattern="^analysis_technical$"))
-            application.add_handler(CallbackQueryHandler(self.analysis_sentiment_callback, pattern="^analysis_sentiment$"))
-            application.add_handler(CallbackQueryHandler(self.analysis_calendar_callback, pattern="^analysis_calendar$"))
-            
-            # Analysis handlers for signal flow - with instrument embedded in callback
-            application.add_handler(CallbackQueryHandler(self.signal_technical_callback, pattern="^signal_flow_technical_.*$"))
-            application.add_handler(CallbackQueryHandler(self.signal_sentiment_callback, pattern="^signal_flow_sentiment_.*$"))
-            application.add_handler(CallbackQueryHandler(self.signal_calendar_callback, pattern="^signal_flow_calendar_.*$"))
-            
-            # Analysis handlers for signal flow - with instrument embedded in callback
-            application.add_handler(CallbackQueryHandler(self.signal_technical_callback, pattern="^signal_flow_technical_.*$"))
-            application.add_handler(CallbackQueryHandler(self.signal_sentiment_callback, pattern="^signal_flow_sentiment_.*$"))
-            application.add_handler(CallbackQueryHandler(self.analysis_calendar_callback, pattern="^signal_flow_calendar_.*$"))
-            
-            # Signal analysis flow handlers
-            application.add_handler(CallbackQueryHandler(self.signal_technical_callback, pattern="^signal_technical$"))
-            application.add_handler(CallbackQueryHandler(self.signal_sentiment_callback, pattern="^signal_sentiment$"))
-            application.add_handler(CallbackQueryHandler(self.signal_calendar_callback, pattern="^signal_calendar$"))
-            application.add_handler(CallbackQueryHandler(self.signal_calendar_callback, pattern="^signal_flow_calendar_.*$"))
-            application.add_handler(CallbackQueryHandler(self.back_to_signal_callback, pattern="^back_to_signal$"))
-            application.add_handler(CallbackQueryHandler(self.back_to_signal_analysis_callback, pattern="^back_to_signal_analysis$"))
-            
-            # Signal from analysis
-            application.add_handler(CallbackQueryHandler(self.analyze_from_signal_callback, pattern="^analyze_from_signal_.*$"))
-            
-            # Ensure back_instrument is properly handled
-            application.add_handler(CallbackQueryHandler(self.back_instrument_callback, pattern="^back_instrument$"))
-            
-            # Catch-all handler for any other callbacks
-            application.add_handler(CallbackQueryHandler(self.button_callback))
-            
-            # Don't load signals here - it will be done in initialize_services
-            # self._load_signals()
-            
-            logger.info("Bot setup completed successfully")
-            
-    except Exception as e:
-        logger.error(f"Error setting up bot handlers: {str(e)}")
-        logger.exception(e)
-
-    @property
-    def signals_enabled(self):
-        """Get whether signals processing is enabled"""
-        return self._signals_enabled
-    
-    @signals_enabled.setter
-    def signals_enabled(self, value):
-        """Set whether signals processing is enabled"""
-        self._signals_enabled = bool(value)
-        logger.info(f"Signal processing is now {'enabled' if value else 'disabled'}")
-
-        async def start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE = None) -> None:
-        """Send a welcome message when the bot is started."""
-        user = update.effective_user
-        user_id = user.id
-        first_name = user.first_name
-        
-        # Try to add the user to the database if they don't exist yet
-    try:
-            # Get user subscription since we can't check if user exists directly
-            existing_subscription = await self.db.get_user_subscription(user_id)
-            
-            if not existing_subscription:
-                # Add new user
-                logger.info(f"New user started: {user_id}, {first_name}")
-                await self.db.save_user(user_id, first_name, None, user.username)
-        else:
-                logger.info(f"Existing user started: {user_id}, {first_name}")
-                
-    except Exception as e:
-# Import necessary modules for improved logging
-import os
-import sys
-import json
-import logging
-import logging.config
-from datetime import datetime
-
-
-async def _get_signal_related_trades(self, signal_id):
-    """Retrieve related trades from the database"""
-    try:
-        # Fetch the related trades data from the database
-        trades_data = await self.db.get_related_trades(signal_id)
-        
-        if trades_data:
-            return trades_data
-        else:
-            logger.warning(f"No related trades data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related trades: {str(e)}")
-        logger.exception(e)
-        return None
-
-
-from telegram.error import TelegramError, BadRequest
-import httpx
-import telegram.error  # Add this import for BadRequest error handling
-
-from trading_bot.services.database.db import Database
-from trading_bot.services.chart_service.chart import ChartService
-from trading_bot.services.sentiment_service.sentiment import MarketSentimentService
-from trading_bot.services.calendar_service import EconomicCalendarService
-from trading_bot.services.payment_service.stripe_service import StripeService
-from trading_bot.services.payment_service.stripe_config import get_subscription_features
-from trading_bot.services.telegram_service.states import (
-    MENU, ANALYSIS, SIGNALS, CHOOSE_MARKET, CHOOSE_INSTRUMENT, CHOOSE_STYLE,
-    CHOOSE_ANALYSIS, SIGNAL_DETAILS,
-    CALLBACK_MENU_ANALYSE, CALLBACK_MENU_SIGNALS, CALLBACK_ANALYSIS_TECHNICAL,
-    CALLBACK_ANALYSIS_SENTIMENT, CALLBACK_ANALYSIS_CALENDAR, CALLBACK_SIGNALS_ADD,
-    CALLBACK_SIGNALS_MANAGE, CALLBACK_BACK_MENU
-)
-import trading_bot.services.telegram_service.gif_utils as gif_utils
-
-# Initialize logger
-logger = logging.getLogger(__name__)
-
-# Major currencies to focus on
-MAJOR_CURRENCIES = ["USD", "EUR", "GBP", "JPY", "CHF", "AUD", "NZD", "CAD"]
-
-# Currency to flag emoji mapping
-CURRENCY_FLAG = {
-    "USD": "üá∫üá∏",
-    "EUR": "üá™üá∫",
-    "GBP": "üá¨üáß",
-    "JPY": "üáØüáµ",
-    "CHF": "üá®üá≠",
-    "AUD": "üá¶üá∫",
-    "NZD": "üá≥üáø",
-    "CAD": "üá®üá¶"
-}
-
-# Map of instruments to their corresponding currencies
-INSTRUMENT_CURRENCY_MAP = {
-    # Special case for global view
-    "GLOBAL": MAJOR_CURRENCIES,
-    
-    # Forex
-    "EURUSD": ["EUR", "USD"],
-    "GBPUSD": ["GBP", "USD"],
-    "USDJPY": ["USD", "JPY"],
-    "USDCHF": ["USD", "CHF"],
-    "AUDUSD": ["AUD", "USD"],
-    "NZDUSD": ["NZD", "USD"],
-    "USDCAD": ["USD", "CAD"],
-    "EURGBP": ["EUR", "GBP"],
-    "EURJPY": ["EUR", "JPY"],
-    "GBPJPY": ["GBP", "JPY"],
-    
-    # Indices (mapped to their related currencies)
-    "US30": ["USD"],
-    "US100": ["USD"],
-    "US500": ["USD"],
-    "UK100": ["GBP"],
-    "GER40": ["EUR"],
-    "FRA40": ["EUR"],
-    "ESP35": ["EUR"],
-    "JP225": ["JPY"],
-    "AUS200": ["AUD"],
-    
-    # Commodities (mapped to USD primarily)
-    "XAUUSD": ["USD", "XAU"],  # Gold
-    "XAGUSD": ["USD", "XAG"],  # Silver
-    "USOIL": ["USD"],          # Oil (WTI)
-    "UKOIL": ["USD", "GBP"],   # Oil (Brent)
-    
-    # Crypto
-    "BTCUSD": ["USD", "BTC"],
-    "ETHUSD": ["USD", "ETH"],
-    "LTCUSD": ["USD", "LTC"],
-    "XRPUSD": ["USD", "XRP"]
-}
-
-# Callback data constants
-CALLBACK_ANALYSIS_TECHNICAL = "analysis_technical"
-CALLBACK_ANALYSIS_SENTIMENT = "analysis_sentiment"
-CALLBACK_ANALYSIS_CALENDAR = "analysis_calendar"
-CALLBACK_BACK_MENU = "back_menu"
-CALLBACK_BACK_ANALYSIS = "back_to_analysis"
-CALLBACK_BACK_MARKET = "back_market"
-CALLBACK_BACK_INSTRUMENT = "back_instrument"
-CALLBACK_BACK_SIGNALS = "back_signals"
-CALLBACK_SIGNALS_ADD = "signals_add"
-CALLBACK_SIGNALS_MANAGE = "signals_manage"
-CALLBACK_MENU_ANALYSE = "menu_analyse"
-CALLBACK_MENU_SIGNALS = "menu_signals"
-
-# States
-MENU = 0
-CHOOSE_ANALYSIS = 1
-CHOOSE_SIGNALS = 2
-CHOOSE_MARKET = 3
-CHOOSE_INSTRUMENT = 4
-CHOOSE_STYLE = 5
-SHOW_RESULT = 6
-CHOOSE_TIMEFRAME = 7
-SIGNAL_DETAILS = 8
-SIGNAL = 9
-SUBSCRIBE = 10
-BACK_TO_MENU = 11  # Add this line
-
-# Messages
-WELCOME_MESSAGE = r"""
-<b>Sigmapips AI - Main Menu</b>
-
-Choose an option to access advanced trading support:
-
-Services:
-- <b>Technical Analysis</b> - Real-time chart analysis and key levels
-
-- <b>Market Sentiment</b> - Understand market trends and sentiment
-
-- <b>Economic Calendar</b> - Stay updated on market-moving events
-
-- <b>Trading Signals</b> - Get precise entry/exit points for your favorite pairs
-
-Select your option to continue:
-"""
-
-# Abonnementsbericht voor nieuwe gebruikers
-SUBSCRIPTION_WELCOME_MESSAGE = r"""
-<b>Welcome to Sigmapips AI!</b>
-
-To access all features, you need a subscription:
-
-<b>Trading Signals Subscription - $29.99/month</b>
-- Access to all trading signals (Forex, Crypto, Commodities, Indices)
-- Advanced timeframe analysis
-- Detailed chart analysis for each signal
-
-Click the button below to subscribe:
-"""
-
-MENU_MESSAGE = r"""
-Welcome to Sigmapips AI!
-
-Choose a command:
-
-/start - Set up new trading pairs
-Add new market/instrument/timeframe combinations to receive signals
-
-/manage - Manage your preferences
-View, edit or delete your saved trading pairs
-
-Need help? Use /help to see all available commands.
-"""
-
-HELP_MESSAGE = r"""
-Available commands:
-/menu - Show main menu
-/start - Set up new trading pairs
-/help - Show this help message
-"""
-
-# Start menu keyboard
-START_KEYBOARD = [
-    [InlineKeyboardButton("Analyze Market", callback_data=CALLBACK_MENU_ANALYSE)],
-    [InlineKeyboardButton("Trading Signals", callback_data=CALLBACK_MENU_SIGNALS)]
-]
-
-# Analysis menu keyboard
-ANALYSIS_KEYBOARD = [
-    [InlineKeyboardButton("Technical Analysis", callback_data=CALLBACK_ANALYSIS_TECHNICAL)],
-    [InlineKeyboardButton("Market Sentiment", callback_data=CALLBACK_ANALYSIS_SENTIMENT)],
-    [InlineKeyboardButton("Economic Calendar", callback_data=CALLBACK_ANALYSIS_CALENDAR)],
-    [InlineKeyboardButton("Back", callback_data=CALLBACK_BACK_MENU)]
-]
-
-# Signals menu keyboard
-SIGNALS_KEYBOARD = [
-    [InlineKeyboardButton("Add New Pairs", callback_data=CALLBACK_SIGNALS_ADD)],
-    [InlineKeyboardButton("Manage Signals", callback_data=CALLBACK_SIGNALS_MANAGE)],
-    [InlineKeyboardButton("Back", callback_data=CALLBACK_BACK_MENU)]
-]
-
-# Market keyboard voor signals
-MARKET_KEYBOARD_SIGNALS = [
-    [InlineKeyboardButton("Forex", callback_data="market_forex_signals")],
-    [InlineKeyboardButton("Crypto", callback_data="market_crypto_signals")],
-    [InlineKeyboardButton("Commodities", callback_data="market_commodities_signals")],
-    [InlineKeyboardButton("Indices", callback_data="market_indices_signals")],
-    [InlineKeyboardButton("Back", callback_data="back_signals")]
-]
-
-# Market keyboard voor analyse
-MARKET_KEYBOARD = [
-    [InlineKeyboardButton("Forex", callback_data="market_forex")],
-    [InlineKeyboardButton("Crypto", callback_data="market_crypto")],
-    [InlineKeyboardButton("Commodities", callback_data="market_commodities")],
-    [InlineKeyboardButton("Indices", callback_data="market_indices")],
-    [InlineKeyboardButton("Back", callback_data="back_analysis")]
-]
-
-# Market keyboard specifiek voor sentiment analyse
-MARKET_SENTIMENT_KEYBOARD = [
-    [InlineKeyboardButton("Forex", callback_data="market_forex_sentiment")],
-    [InlineKeyboardButton("Crypto", callback_data="market_crypto_sentiment")],
-    [InlineKeyboardButton("Commodities", callback_data="market_commodities_sentiment")],
-    [InlineKeyboardButton("Indices", callback_data="market_indices_sentiment")],
-    [InlineKeyboardButton("Back", callback_data="back_analysis")]
-]
-
-# Forex keyboard voor technical analyse
-FOREX_KEYBOARD = [
-    [
-        InlineKeyboardButton("EURUSD", callback_data="instrument_EURUSD_chart"),
-        InlineKeyboardButton("GBPUSD", callback_data="instrument_GBPUSD_chart"),
-        InlineKeyboardButton("USDJPY", callback_data="instrument_USDJPY_chart")
-    ],
-    [
-        InlineKeyboardButton("AUDUSD", callback_data="instrument_AUDUSD_chart"),
-        InlineKeyboardButton("USDCAD", callback_data="instrument_USDCAD_chart"),
-        InlineKeyboardButton("EURGBP", callback_data="instrument_EURGBP_chart")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Forex keyboard voor sentiment analyse
-FOREX_SENTIMENT_KEYBOARD = [
-    [
-        InlineKeyboardButton("EURUSD", callback_data="instrument_EURUSD_sentiment"),
-        InlineKeyboardButton("GBPUSD", callback_data="instrument_GBPUSD_sentiment"),
-        InlineKeyboardButton("USDJPY", callback_data="instrument_USDJPY_sentiment")
-    ],
-    [
-        InlineKeyboardButton("AUDUSD", callback_data="instrument_AUDUSD_sentiment"),
-        InlineKeyboardButton("USDCAD", callback_data="instrument_USDCAD_sentiment"),
-        InlineKeyboardButton("EURGBP", callback_data="instrument_EURGBP_sentiment")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Forex keyboard voor kalender analyse
-FOREX_CALENDAR_KEYBOARD = [
-    [
-        InlineKeyboardButton("EURUSD", callback_data="instrument_EURUSD_calendar"),
-        InlineKeyboardButton("GBPUSD", callback_data="instrument_GBPUSD_calendar"),
-        InlineKeyboardButton("USDJPY", callback_data="instrument_USDJPY_calendar")
-    ],
-    [
-        InlineKeyboardButton("AUDUSD", callback_data="instrument_AUDUSD_calendar"),
-        InlineKeyboardButton("USDCAD", callback_data="instrument_USDCAD_calendar"),
-        InlineKeyboardButton("EURGBP", callback_data="instrument_EURGBP_calendar")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Crypto keyboard voor analyse
-CRYPTO_KEYBOARD = [
-    [
-        InlineKeyboardButton("BTCUSD", callback_data="instrument_BTCUSD_chart"),
-        InlineKeyboardButton("ETHUSD", callback_data="instrument_ETHUSD_chart"),
-        InlineKeyboardButton("XRPUSD", callback_data="instrument_XRPUSD_chart")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Signal analysis keyboard
-SIGNAL_ANALYSIS_KEYBOARD = [
-    [InlineKeyboardButton("Technical Analysis", callback_data="signal_technical")],
-    [InlineKeyboardButton("Market Sentiment", callback_data="signal_sentiment")],
-    [InlineKeyboardButton("Economic Calendar", callback_data="signal_calendar")],
-    [InlineKeyboardButton("Back", callback_data="back_to_signal")]
-]
-
-# Crypto keyboard voor sentiment analyse
-CRYPTO_SENTIMENT_KEYBOARD = [
-    [
-        InlineKeyboardButton("BTCUSD", callback_data="instrument_BTCUSD_sentiment"),
-        InlineKeyboardButton("ETHUSD", callback_data="instrument_ETHUSD_sentiment"),
-        InlineKeyboardButton("XRPUSD", callback_data="instrument_XRPUSD_sentiment")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Indices keyboard voor analyse
-INDICES_KEYBOARD = [
-    [
-        InlineKeyboardButton("US30", callback_data="instrument_US30_chart"),
-        InlineKeyboardButton("US500", callback_data="instrument_US500_chart"),
-        InlineKeyboardButton("US100", callback_data="instrument_US100_chart")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Indices keyboard voor signals - Fix de "Terug" knop naar "Back"
-INDICES_KEYBOARD_SIGNALS = [
-    [
-        InlineKeyboardButton("US30", callback_data="instrument_US30_signals"),
-        InlineKeyboardButton("US500", callback_data="instrument_US500_signals"),
-        InlineKeyboardButton("US100", callback_data="instrument_US100_signals")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Commodities keyboard voor analyse
-COMMODITIES_KEYBOARD = [
-    [
-        InlineKeyboardButton("GOLD", callback_data="instrument_XAUUSD_chart"),
-        InlineKeyboardButton("SILVER", callback_data="instrument_XAGUSD_chart"),
-        InlineKeyboardButton("OIL", callback_data="instrument_USOIL_chart")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Commodities keyboard voor signals - Fix de "Terug" knop naar "Back"
-COMMODITIES_KEYBOARD_SIGNALS = [
-    [
-        InlineKeyboardButton("XAUUSD", callback_data="instrument_XAUUSD_signals"),
-        InlineKeyboardButton("XAGUSD", callback_data="instrument_XAGUSD_signals"),
-        InlineKeyboardButton("USOIL", callback_data="instrument_USOIL_signals")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Forex keyboard for signals
-FOREX_KEYBOARD_SIGNALS = [
-    [
-        InlineKeyboardButton("EURUSD", callback_data="instrument_EURUSD_signals"),
-        InlineKeyboardButton("GBPUSD", callback_data="instrument_GBPUSD_signals"),
-        InlineKeyboardButton("USDJPY", callback_data="instrument_USDJPY_signals")
-    ],
-    [
-        InlineKeyboardButton("USDCAD", callback_data="instrument_USDCAD_signals"),
-        InlineKeyboardButton("EURGBP", callback_data="instrument_EURGBP_signals")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Crypto keyboard for signals
-CRYPTO_KEYBOARD_SIGNALS = [
-    [
-        InlineKeyboardButton("BTCUSD", callback_data="instrument_BTCUSD_signals"),
-        InlineKeyboardButton("ETHUSD", callback_data="instrument_ETHUSD_signals"),
-        InlineKeyboardButton("XRPUSD", callback_data="instrument_XRPUSD_signals")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Indices keyboard voor sentiment analyse
-INDICES_SENTIMENT_KEYBOARD = [
-    [
-        InlineKeyboardButton("US30", callback_data="instrument_US30_sentiment"),
-        InlineKeyboardButton("US500", callback_data="instrument_US500_sentiment"),
-        InlineKeyboardButton("US100", callback_data="instrument_US100_sentiment")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Commodities keyboard voor sentiment analyse
-COMMODITIES_SENTIMENT_KEYBOARD = [
-    [
-        InlineKeyboardButton("GOLD", callback_data="instrument_XAUUSD_sentiment"),
-        InlineKeyboardButton("SILVER", callback_data="instrument_XAGUSD_sentiment"),
-        InlineKeyboardButton("OIL", callback_data="instrument_USOIL_sentiment")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Style keyboard
-STYLE_KEYBOARD = [
-    [InlineKeyboardButton("‚ö° Test (one_min)", callback_data="style_test")],
-    [InlineKeyboardButton("üèÉ Scalp (fifteen_min)", callback_data="style_scalp")],
-    [InlineKeyboardButton(" Intraday (one_hour)", callback_data="style_intraday")],
-    [InlineKeyboardButton("üåä Swing (four_hour)", callback_data="style_swing")],
-    [InlineKeyboardButton("Back", callback_data="back_instrument")]
-]
-
-# Timeframe mapping
-STYLE_TIMEFRAME_MAP = {
-    "test": "one_min",
-    "scalp": "fifteen_min",
-    "intraday": "one_hour",
-    "swing": "four_hour"
-}
-
-# Mapping of instruments to their allowed timeframes - updated 2023-03-23
-INSTRUMENT_TIMEFRAME_MAP = {
-    # H1 timeframe only
-    "AUDJPY": "H1", 
-    "AUDCHF": "H1",
-    "EURCAD": "H1",
-    "EURGBP": "H1",
-    "GBPCHF": "H1",
-    "HK50": "H1",
-    "NZDJPY": "H1",
-    "USDCHF": "H1",
-    "USDJPY": "H1",  # USDJPY toegevoegd voor signaalabonnementen
-    "XRPUSD": "H1",
-    
-    # H4 timeframe only
-    "AUDCAD": "H4",
-    "AU200": "H4", 
-    "CADCHF": "H4",
-    "EURCHF": "H4",
-    "EURUSD": "H4",
-    "GBPCAD": "H4",
-    "LINKUSD": "H4",
-    "NZDCHF": "H4",
-    
-    # M15 timeframe only
-    "DOGEUSD": "M15",
-    "GBPNZD": "M15",
-    "NZDUSD": "M15",
-    "SOLUSD": "M15",
-    "UK100": "M15",
-    "XAUUSD": "M15",
-    
-    # M30 timeframe only
-    "BNBUSD": "M30",
-    "DOTUSD": "M30",
-    "ETHUSD": "M30",
-    "EURAUD": "M30",
-    "EURJPY": "M30",
-    "GBPAUD": "M30",
-    "GBPUSD": "M30",
-    "NZDCAD": "M30",
-    "US30": "M30",
-    "US500": "M30",
-    "USDCAD": "M30",
-    "XLMUSD": "M30",
-    "XTIUSD": "M30",
-    "DE40": "M30",
-    "BTCUSD": "M30",  # Added for consistency with CRYPTO_KEYBOARD_SIGNALS
-    "US100": "M30",   # Added for consistency with INDICES_KEYBOARD_SIGNALS
-    "XAGUSD": "M15",  # Added for consistency with COMMODITIES_KEYBOARD_SIGNALS
-    "USOIL": "M30"    # Added for consistency with COMMODITIES_KEYBOARD_SIGNALS
-    
-    # Removed as requested: EU50, FR40, LTCUSD
-}
-
-# Map common timeframe notations
-TIMEFRAME_DISPLAY_MAP = {
-    "M15": "15 Minutes",
-    "M30": "30 Minutes", 
-    "H1": "1 Hour",
-    "H4": "4 Hours"
-}
-
-# Voeg deze functie toe aan het begin van bot.py, na de imports
-def _detect_market(instrument: str) -> str:
-    """Detecteer market type gebaseerd op instrument"""
-    instrument = instrument.upper()
-    
-    # Commodities eerst checken
-    commodities = [
-        "XAUUSD",  # Gold
-        "XAGUSD",  # Silver
-        "WTIUSD",  # Oil WTI
-        "BCOUSD",  # Oil Brent
-        "USOIL",   # Oil WTI (alternative symbol)
-    ]
-    if instrument in commodities:
-        logger.info(f"Detected {instrument} as commodity")
-        return "commodities"
-    
-    # Crypto pairs
-    crypto_base = ["BTC", "ETH", "XRP", "SOL", "BNB", "ADA", "DOT", "LINK"]
-    if any(c in instrument for c in crypto_base):
-        logger.info(f"Detected {instrument} as crypto")
-        return "crypto"
-    
-    # Major indices
-    indices = [
-        "US30", "US500", "US100",  # US indices
-        "UK100", "DE40", "FR40",   # European indices
-        "JP225", "AU200", "HK50"   # Asian indices
-    ]
-    if instrument in indices:
-        logger.info(f"Detected {instrument} as index")
-        return "indices"
-    
-    # Forex pairs als default
-    logger.info(f"Detected {instrument} as forex")
-    return "forex"
-
-# Voeg dit toe als decorator functie bovenaan het bestand na de imports
-def require_subscription(func):
-    """Check if user has an active subscription"""
-    async def wrapper(self, update: Update, context: ContextTypes.DEFAULT_TYPE, *args, **kwargs):
-        user_id = update.effective_user.id
-        
-        # Check subscription status
-        is_subscribed = await self.db.is_user_subscribed(user_id)
-        
-        # Check if payment has failed
-        payment_failed = await self.db.has_payment_failed(user_id)
-        
-        if is_subscribed and not payment_failed:
-            # User has subscription, proceed with function
-            return await func(self, update, context, *args, **kwargs)
-        else:
-            if payment_failed:
-                # Show payment failure message
-                failed_payment_text = f"""
- <b>Subscription Payment Failed</b> 
-
-Your subscription payment could not be processed and your service has been deactivated.
-
-To continue using Sigmapips AI and receive trading signals, please reactivate your subscription by clicking the button below.
-                """
-                
-                # Use direct URL link for reactivation
-                reactivation_url = "https://buy.stripe.com/9AQcPf3j63HL5JS145"
-                
-                # Create button for reactivation
-                keyboard = [
-                    [InlineKeyboardButton("üîÑ Reactivate Subscription", url=reactivation_url)]
-                ]
-            else:
-                # Show subscription screen with the welcome message from the screenshot
-                failed_payment_text = f"""
- <b>Welcome to Sigmapips AI!</b> 
-
-<b>Discover powerful trading signals for various markets:</b>
-- <b>Forex</b> - Major and minor currency pairs
-- <b>Crypto</b> - Bitcoin, Ethereum and other top cryptocurrencies
-- <b>Indices</b> - Global market indices
-- <b>Commodities</b> - Gold, silver and oil
-
-<b>Features:</b>
- Real-time trading signals
-
- Multi-timeframe analysis (timeframes)
-
- Advanced chart analysis
-
- Sentiment indicators
-
- Economic calendar integration
-
-<b>Start today with a FREE 14-day trial!</b>
-                """
-                
-                # Use direct URL link instead of callback for the trial button
-                reactivation_url = "https://buy.stripe.com/3cs3eF9Hu9256NW9AA"
-                
-                # Create button for trial
-                keyboard = [
-                    [InlineKeyboardButton("üî• Start 14-day FREE Trial", url=reactivation_url)]
-                ]
-            
-            # Handle both message and callback query updates
-            if update.callback_query:
-                await update.callback_query.answer()
-                await update.callback_query.edit_message_text(
-                    text=failed_payment_text,
-                    reply_markup=InlineKeyboardMarkup(keyboard),
-                    parse_mode=ParseMode.HTML
-                )
-            else:
-                await update.message.reply_text(
-                    text=failed_payment_text,
-                    reply_markup=InlineKeyboardMarkup(keyboard),
-                    parse_mode=ParseMode.HTML
-                )
-            return MENU
-    
-    return wrapper
-
-# API keys with robust sanitization
-PERPLEXITY_API_KEY = os.getenv("PERPLEXITY_API_KEY", "").strip()
-OPENAI_API_KEY = os.getenv("OPENAI_API_KEY", "").strip()  # Changed from DeepSeek to OpenAI
-
-# Only using OpenAI's o4-mini now
-# No Tavily API key needed anymore
-logger.info("Using only OpenAI o4-mini for Market Sentiment service")
-
-# Log OpenAI API key (partially masked)
-if OPENAI_API_KEY:
-    # Better masking for privacy and security
-    masked_key = f"sk-p...{OPENAI_API_KEY[-4:]}" if len(OPENAI_API_KEY) > 8 else "sk-p..."
-    logger.info(f"Using OpenAI API key: {masked_key}")
-    
-    # Validate the key format
-    from trading_bot.config import validate_openai_key
-    if not validate_openai_key(OPENAI_API_KEY):
-        logger.warning("OpenAI API key format is invalid. AI services may not work correctly.")
-else:
-    logger.warning("No OpenAI API key configured. AI services will be disabled.")
-    
-# Set environment variables for the API keys with sanitization
-os.environ["PERPLEXITY_API_KEY"] = PERPLEXITY_API_KEY
-os.environ["OPENAI_API_KEY"] = OPENAI_API_KEY  # Changed from DeepSeek to OpenAI
-# No Tavily environment needed
-
-class TelegramService:
-    def __init__(self, db: Database, stripe_service=None, bot_token: Optional[str] = None, proxy_url: Optional[str] = None, lazy_init: bool = False):
-        """Initialize the bot with given database and config."""
-        # Database connection
-        self.db = db
-        
-        # Setup configuration 
-        self.stripe_service = stripe_service
-        self.user_signals = {}
-        self.signals_dir = "data/signals"
-        self.signals_enabled_val = True
-        self.polling_started = False
-        self.admin_users = [2004519703]  # Updated with correct Telegram ID from logs
-        self._signals_enabled = True  # Enable signals by default
-        
-        # Setup logger
-        self.logger = logging.getLogger(__name__)
-        
-        # GIF utilities for UI
-        self.gif_utils = gif_utils  # Initialize gif_utils as an attribute
-        
-        # Setup the bot and application
-        self.bot = None
-        self.application = None
-        
-        # Telegram Bot configuratie
-        self.bot_token = bot_token or os.getenv("TELEGRAM_BOT_TOKEN", "")
-        self.token = self.bot_token  # Aliased for backward compatibility
-        self.proxy_url = proxy_url or os.getenv("TELEGRAM_PROXY_URL", "")
-        
-        # Configure custom request handler with improved connection settings
-        request = HTTPXRequest(
-            connection_pool_size=50,  # Increase from 20 to 50
-            connect_timeout=15.0,     # Increase from 10.0 to 15.0
-            read_timeout=45.0,        # Increase from 30.0 to 45.0
-            write_timeout=30.0,       # Increase from 20.0 to 30.0
-            pool_timeout=60.0,        # Increase from 30.0 to 60.0
-        )
-        
-        # Initialize the bot directly with connection pool settings
-        self.bot = Bot(token=self.bot_token, request=request)
-        self.application = None  # Will be initialized in setup()
-        
-        # Webhook configuration
-        self.webhook_url = os.getenv("WEBHOOK_URL", "")
-        self.webhook_path = "/webhook"  # Always use this path
-        if self.webhook_url.endswith("/"):
-            self.webhook_url = self.webhook_url[:-1]  # Remove trailing slash
-            
-        logger.info(f"Bot initialized with webhook URL: {self.webhook_url} and path: {self.webhook_path}")
-        
-        # Initialize API services
-        self.chart_service = ChartService()  # Initialize chart service
-        # Lazy load services only when needed
-        self._calendar_service = None
-        self._sentiment_service = None
-        
-        # Don't use asyncio.create_task here - it requires a running event loop
-        # We'll initialize chart service later when the event loop is running
-        
-        # Bot application initialization
-        self.persistence = None
-        self.bot_started = False
-        
-        # Cache for sentiment analysis
-        self.sentiment_cache = {}
-        self.sentiment_cache_ttl = 60 * 60  # 1 hour in seconds
-        
-        # Start the bot
-    try:
-            # Check for bot token
-            if not self.bot_token:
-                raise ValueError("Missing Telegram bot token")
-            
-            # Initialize the bot
-            self.bot = Bot(token=self.bot_token)
-        
-            # Initialize the application
-            self.application = Application.builder().bot(self.bot).build()
-        
-            # Register the handlers
-            self._register_handlers(self.application)
-            
-            # Initialize signals dictionary but don't load them yet (will be done in initialize_services)
-            self.user_signals = {}
-        
-            logger.info("Telegram service initialized")
-            
-            # Keep track of processed updates
-            self.processed_updates = set()
-            
-    except Exception as e:
-        logger.error(f"Error initializing Telegram service: {str(e)}")
-        raise
-
-    async def initialize_services(self):
-        """Initialize services that require an asyncio event loop"""
-        try:
-            # Initialize chart service
-            await self.chart_service.initialize()
-            logger.info("Chart service initialized")
-            
-            # Load stored signals
-            await self._load_signals()
-            logger.info("Signals loaded")
-            
-            # Schedule periodic cleanup of old signals
-            if hasattr(self, 'db') and self.db and self.db.using_redis:
-                # Run initial cleanup
-                cleaned = await self._cleanup_old_signals(max_age_days=7)
-                logger.info(f"Initial signal cleanup completed, removed {cleaned} old signals")
-                
-                # Schedule periodic cleanup (every 24 hours)
-                async def periodic_cleanup():
-                    while True:
-                        try:
-                            # Wait for 24 hours
-                            await asyncio.sleep(24 * 60 * 60)
-                            # Run cleanup
-                            cleaned = await self._cleanup_old_signals(max_age_days=7)
-                            logger.info(f"Periodic signal cleanup completed, removed {cleaned} old signals")
-                        except Exception as e:
-                            logger.error(f"Error in periodic signal cleanup: {str(e)}")
-                
-                # Start the periodic cleanup task
-                asyncio.create_task(periodic_cleanup())
-                logger.info("Scheduled periodic signal cleanup")
-        except Exception as e:
-            logger.error(f"Error initializing services: {str(e)}")
-            raise
-
-# Calendar service helpers
-    @property
-    def signals_enabled(self):
-        """Get whether signals processing is enabled"""
-        return self._signals_enabled
-    
-    @signals_enabled.setter
-    def signals_enabled(self, value):
-        """Set whether signals processing is enabled"""
-        self._signals_enabled = bool(value)
-        logger.info(f"Signal processing is now {'enabled' if value else 'disabled'}")
-
-    async def start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE = None) -> None:
-        """Handle the /start command"""
-        user = update.effective_user
-        logger.info(f"User {user.id} ({user.username}) started the bot")
-        
-        # Check if user is subscribed
-        is_subscribed = await self.db.is_user_subscribed(user.id)
-        
-        # Create welcome message
-        welcome_text = (
-            f"üëã Welcome to SigmaPips Trading Bot, {user.first_name}!\n\n"
-            "I'm your AI-powered trading assistant. Here's what I can do for you:\n\n"
-            " <b>Market Analysis</b> - Technical and sentiment analysis for major markets\n"
-            " <b>Signal Management</b> - Receive and manage trading signals\n"
-            " <b>Economic Calendar</b> - Stay updated with important economic events\n\n"
-        )
-        
-        # Add subscription status
-        if is_subscribed:
-            welcome_text += " <b>Subscription Status:</b> Active\n\n"
-        else:
-            welcome_text += " <b>Subscription Status:</b> Inactive\n\n"
-        
-        welcome_text += "Use the /menu command to access all features."
-        
-        # Create keyboard for main menu
-        keyboard = [
-            [InlineKeyboardButton(" Analyze Markets", callback_data="menu_analyse")],
-            [InlineKeyboardButton(" Signal Management", callback_data="menu_signals")],
-            [InlineKeyboardButton("‚ùì Help", callback_data="menu_help")]
-        ]
-        reply_markup = InlineKeyboardMarkup(keyboard)
-        
-        # Send welcome message with keyboard
-        await update.message.reply_html(
-            welcome_text,
-            reply_markup=reply_markup
-        )
-        
-        # Log the user interaction
-        logger.info(f"Sent welcome message to user {user.id}")
-        
-        # Store user data if needed
-        if context:
-            context.user_data['is_signals_context'] = False
-            context.user_data['from_signal'] = False
-            context.user_data['in_signal_flow'] = False
-        
-        return MAIN_MENU
-
-# Initialize logging early in the application startup
-logger = setup_logging()
-
-import os
-import json
-import asyncio
-import traceback
-from typing import Dict, Any, List, Optional, Union, Set
-from datetime import datetime, timedelta
-import logging
-import copy
-import re
-import time
-import random
-
-from fastapi import FastAPI, Request, HTTPException, status
-from telegram import Bot, Update, BotCommand, InlineKeyboardButton, InlineKeyboardMarkup, CallbackQuery, InputMediaPhoto, InputMediaAnimation, InputMediaDocument, ReplyKeyboardMarkup, ReplyKeyboardRemove, InputFile
-from telegram.constants import ParseMode
-from telegram.request import HTTPXRequest
-from telegram.ext import (
-    Application,
-    CommandHandler,
-    CallbackQueryHandler,
-    ConversationHandler,
-    ContextTypes,
-    CallbackContext,
-    MessageHandler,
-    filters,
-    PicklePersistence
-)
-from telegram.error import TelegramError, BadRequest
-import httpx
-import telegram.error  # Add this import for BadRequest error handling
-
-from trading_bot.services.database.db import Database
-from trading_bot.services.chart_service.chart import ChartService
-from trading_bot.services.sentiment_service.sentiment import MarketSentimentService
-from trading_bot.services.calendar_service import EconomicCalendarService
-from trading_bot.services.payment_service.stripe_service import StripeService
-from trading_bot.services.payment_service.stripe_config import get_subscription_features
-from trading_bot.services.telegram_service.states import (
-    MENU, ANALYSIS, SIGNALS, CHOOSE_MARKET, CHOOSE_INSTRUMENT, CHOOSE_STYLE,
-    CHOOSE_ANALYSIS, SIGNAL_DETAILS,
-    CALLBACK_MENU_ANALYSE, CALLBACK_MENU_SIGNALS, CALLBACK_ANALYSIS_TECHNICAL,
-    CALLBACK_ANALYSIS_SENTIMENT, CALLBACK_ANALYSIS_CALENDAR, CALLBACK_SIGNALS_ADD,
-    CALLBACK_SIGNALS_MANAGE, CALLBACK_BACK_MENU
-)
-import trading_bot.services.telegram_service.gif_utils as gif_utils
-
-# Initialize logger
-logger = logging.getLogger(__name__)
-
-# Major currencies to focus on
-MAJOR_CURRENCIES = ["USD", "EUR", "GBP", "JPY", "CHF", "AUD", "NZD", "CAD"]
-
-# Currency to flag emoji mapping
-CURRENCY_FLAG = {
-    "USD": "üá∫üá∏",
-    "EUR": "üá™üá∫",
-    "GBP": "üá¨üáß",
-    "JPY": "üáØüáµ",
-    "CHF": "üá®üá≠",
-    "AUD": "üá¶üá∫",
-    "NZD": "üá≥üáø",
-    "CAD": "üá®üá¶"
-}
-
-# Map of instruments to their corresponding currencies
-INSTRUMENT_CURRENCY_MAP = {
-    # Special case for global view
-    "GLOBAL": MAJOR_CURRENCIES,
-    
-    # Forex
-    "EURUSD": ["EUR", "USD"],
-    "GBPUSD": ["GBP", "USD"],
-    "USDJPY": ["USD", "JPY"],
-    "USDCHF": ["USD", "CHF"],
-    "AUDUSD": ["AUD", "USD"],
-    "NZDUSD": ["NZD", "USD"],
-    "USDCAD": ["USD", "CAD"],
-    "EURGBP": ["EUR", "GBP"],
-    "EURJPY": ["EUR", "JPY"],
-    "GBPJPY": ["GBP", "JPY"],
-    
-    # Indices (mapped to their related currencies)
-    "US30": ["USD"],
-    "US100": ["USD"],
-    "US500": ["USD"],
-    "UK100": ["GBP"],
-    "GER40": ["EUR"],
-    "FRA40": ["EUR"],
-    "ESP35": ["EUR"],
-    "JP225": ["JPY"],
-    "AUS200": ["AUD"],
-    
-    # Commodities (mapped to USD primarily)
-    "XAUUSD": ["USD", "XAU"],  # Gold
-    "XAGUSD": ["USD", "XAG"],  # Silver
-    "USOIL": ["USD"],          # Oil (WTI)
-    "UKOIL": ["USD", "GBP"],   # Oil (Brent)
-    
-    # Crypto
-    "BTCUSD": ["USD", "BTC"],
-    "ETHUSD": ["USD", "ETH"],
-    "LTCUSD": ["USD", "LTC"],
-    "XRPUSD": ["USD", "XRP"]
-}
-
-# Callback data constants
-CALLBACK_ANALYSIS_TECHNICAL = "analysis_technical"
-CALLBACK_ANALYSIS_SENTIMENT = "analysis_sentiment"
-CALLBACK_ANALYSIS_CALENDAR = "analysis_calendar"
-CALLBACK_BACK_MENU = "back_menu"
-CALLBACK_BACK_ANALYSIS = "back_to_analysis"
-CALLBACK_BACK_MARKET = "back_market"
-CALLBACK_BACK_INSTRUMENT = "back_instrument"
-CALLBACK_BACK_SIGNALS = "back_signals"
-CALLBACK_SIGNALS_ADD = "signals_add"
-CALLBACK_SIGNALS_MANAGE = "signals_manage"
-CALLBACK_MENU_ANALYSE = "menu_analyse"
-CALLBACK_MENU_SIGNALS = "menu_signals"
-
-# States
-MENU = 0
-CHOOSE_ANALYSIS = 1
-CHOOSE_SIGNALS = 2
-CHOOSE_MARKET = 3
-CHOOSE_INSTRUMENT = 4
-CHOOSE_STYLE = 5
-SHOW_RESULT = 6
-CHOOSE_TIMEFRAME = 7
-SIGNAL_DETAILS = 8
-SIGNAL = 9
-SUBSCRIBE = 10
-BACK_TO_MENU = 11  # Add this line
-
-# Messages
-WELCOME_MESSAGE = r"""
-<b>Sigmapips AI - Main Menu</b>
-
-Choose an option to access advanced trading support:
-
-Services:
-- <b>Technical Analysis</b> - Real-time chart analysis and key levels
-
-- <b>Market Sentiment</b> - Understand market trends and sentiment
-
-- <b>Economic Calendar</b> - Stay updated on market-moving events
-
-- <b>Trading Signals</b> - Get precise entry/exit points for your favorite pairs
-
-Select your option to continue:
-"""
-
-# Abonnementsbericht voor nieuwe gebruikers
-SUBSCRIPTION_WELCOME_MESSAGE = r"""
-<b>Welcome to Sigmapips AI!</b>
-
-To access all features, you need a subscription:
-
-<b>Trading Signals Subscription - $29.99/month</b>
-- Access to all trading signals (Forex, Crypto, Commodities, Indices)
-- Advanced timeframe analysis
-- Detailed chart analysis for each signal
-
-Click the button below to subscribe:
-"""
-
-MENU_MESSAGE = r"""
-Welcome to Sigmapips AI!
-
-Choose a command:
-
-/start - Set up new trading pairs
-Add new market/instrument/timeframe combinations to receive signals
-
-/manage - Manage your preferences
-View, edit or delete your saved trading pairs
-
-Need help? Use /help to see all available commands.
-"""
-
-HELP_MESSAGE = r"""
-Available commands:
-/menu - Show main menu
-/start - Set up new trading pairs
-/help - Show this help message
-"""
-
-# Start menu keyboard
-START_KEYBOARD = [
-    [InlineKeyboardButton("Analyze Market", callback_data=CALLBACK_MENU_ANALYSE)],
-    [InlineKeyboardButton("Trading Signals", callback_data=CALLBACK_MENU_SIGNALS)]
-]
-
-# Analysis menu keyboard
-ANALYSIS_KEYBOARD = [
-    [InlineKeyboardButton("Technical Analysis", callback_data=CALLBACK_ANALYSIS_TECHNICAL)],
-    [InlineKeyboardButton("Market Sentiment", callback_data=CALLBACK_ANALYSIS_SENTIMENT)],
-    [InlineKeyboardButton("Economic Calendar", callback_data=CALLBACK_ANALYSIS_CALENDAR)],
-    [InlineKeyboardButton("Back", callback_data=CALLBACK_BACK_MENU)]
-]
-
-# Signals menu keyboard
-SIGNALS_KEYBOARD = [
-    [InlineKeyboardButton("Add New Pairs", callback_data=CALLBACK_SIGNALS_ADD)],
-    [InlineKeyboardButton("Manage Signals", callback_data=CALLBACK_SIGNALS_MANAGE)],
-    [InlineKeyboardButton("Back", callback_data=CALLBACK_BACK_MENU)]
-]
-
-# Market keyboard voor signals
-MARKET_KEYBOARD_SIGNALS = [
-    [InlineKeyboardButton("Forex", callback_data="market_forex_signals")],
-    [InlineKeyboardButton("Crypto", callback_data="market_crypto_signals")],
-    [InlineKeyboardButton("Commodities", callback_data="market_commodities_signals")],
-    [InlineKeyboardButton("Indices", callback_data="market_indices_signals")],
-    [InlineKeyboardButton("Back", callback_data="back_signals")]
-]
-
-# Market keyboard voor analyse
-MARKET_KEYBOARD = [
-    [InlineKeyboardButton("Forex", callback_data="market_forex")],
-    [InlineKeyboardButton("Crypto", callback_data="market_crypto")],
-    [InlineKeyboardButton("Commodities", callback_data="market_commodities")],
-    [InlineKeyboardButton("Indices", callback_data="market_indices")],
-    [InlineKeyboardButton("Back", callback_data="back_analysis")]
-]
-
-# Market keyboard specifiek voor sentiment analyse
-MARKET_SENTIMENT_KEYBOARD = [
-    [InlineKeyboardButton("Forex", callback_data="market_forex_sentiment")],
-    [InlineKeyboardButton("Crypto", callback_data="market_crypto_sentiment")],
-    [InlineKeyboardButton("Commodities", callback_data="market_commodities_sentiment")],
-    [InlineKeyboardButton("Indices", callback_data="market_indices_sentiment")],
-    [InlineKeyboardButton("Back", callback_data="back_analysis")]
-]
-
-# Forex keyboard voor technical analyse
-FOREX_KEYBOARD = [
-    [
-        InlineKeyboardButton("EURUSD", callback_data="instrument_EURUSD_chart"),
-        InlineKeyboardButton("GBPUSD", callback_data="instrument_GBPUSD_chart"),
-        InlineKeyboardButton("USDJPY", callback_data="instrument_USDJPY_chart")
-    ],
-    [
-        InlineKeyboardButton("AUDUSD", callback_data="instrument_AUDUSD_chart"),
-        InlineKeyboardButton("USDCAD", callback_data="instrument_USDCAD_chart"),
-        InlineKeyboardButton("EURGBP", callback_data="instrument_EURGBP_chart")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Forex keyboard voor sentiment analyse
-FOREX_SENTIMENT_KEYBOARD = [
-    [
-        InlineKeyboardButton("EURUSD", callback_data="instrument_EURUSD_sentiment"),
-        InlineKeyboardButton("GBPUSD", callback_data="instrument_GBPUSD_sentiment"),
-        InlineKeyboardButton("USDJPY", callback_data="instrument_USDJPY_sentiment")
-    ],
-    [
-        InlineKeyboardButton("AUDUSD", callback_data="instrument_AUDUSD_sentiment"),
-        InlineKeyboardButton("USDCAD", callback_data="instrument_USDCAD_sentiment"),
-        InlineKeyboardButton("EURGBP", callback_data="instrument_EURGBP_sentiment")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Forex keyboard voor kalender analyse
-FOREX_CALENDAR_KEYBOARD = [
-    [
-        InlineKeyboardButton("EURUSD", callback_data="instrument_EURUSD_calendar"),
-        InlineKeyboardButton("GBPUSD", callback_data="instrument_GBPUSD_calendar"),
-        InlineKeyboardButton("USDJPY", callback_data="instrument_USDJPY_calendar")
-    ],
-    [
-        InlineKeyboardButton("AUDUSD", callback_data="instrument_AUDUSD_calendar"),
-        InlineKeyboardButton("USDCAD", callback_data="instrument_USDCAD_calendar"),
-        InlineKeyboardButton("EURGBP", callback_data="instrument_EURGBP_calendar")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Crypto keyboard voor analyse
-CRYPTO_KEYBOARD = [
-    [
-        InlineKeyboardButton("BTCUSD", callback_data="instrument_BTCUSD_chart"),
-        InlineKeyboardButton("ETHUSD", callback_data="instrument_ETHUSD_chart"),
-        InlineKeyboardButton("XRPUSD", callback_data="instrument_XRPUSD_chart")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Signal analysis keyboard
-SIGNAL_ANALYSIS_KEYBOARD = [
-    [InlineKeyboardButton("Technical Analysis", callback_data="signal_technical")],
-    [InlineKeyboardButton("Market Sentiment", callback_data="signal_sentiment")],
-    [InlineKeyboardButton("Economic Calendar", callback_data="signal_calendar")],
-    [InlineKeyboardButton("Back", callback_data="back_to_signal")]
-]
-
-# Crypto keyboard voor sentiment analyse
-CRYPTO_SENTIMENT_KEYBOARD = [
-    [
-        InlineKeyboardButton("BTCUSD", callback_data="instrument_BTCUSD_sentiment"),
-        InlineKeyboardButton("ETHUSD", callback_data="instrument_ETHUSD_sentiment"),
-        InlineKeyboardButton("XRPUSD", callback_data="instrument_XRPUSD_sentiment")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Indices keyboard voor analyse
-INDICES_KEYBOARD = [
-    [
-        InlineKeyboardButton("US30", callback_data="instrument_US30_chart"),
-        InlineKeyboardButton("US500", callback_data="instrument_US500_chart"),
-        InlineKeyboardButton("US100", callback_data="instrument_US100_chart")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Indices keyboard voor signals - Fix de "Terug" knop naar "Back"
-INDICES_KEYBOARD_SIGNALS = [
-    [
-        InlineKeyboardButton("US30", callback_data="instrument_US30_signals"),
-        InlineKeyboardButton("US500", callback_data="instrument_US500_signals"),
-        InlineKeyboardButton("US100", callback_data="instrument_US100_signals")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Commodities keyboard voor analyse
-COMMODITIES_KEYBOARD = [
-    [
-        InlineKeyboardButton("GOLD", callback_data="instrument_XAUUSD_chart"),
-        InlineKeyboardButton("SILVER", callback_data="instrument_XAGUSD_chart"),
-        InlineKeyboardButton("OIL", callback_data="instrument_USOIL_chart")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Commodities keyboard voor signals - Fix de "Terug" knop naar "Back"
-COMMODITIES_KEYBOARD_SIGNALS = [
-    [
-        InlineKeyboardButton("XAUUSD", callback_data="instrument_XAUUSD_signals"),
-        InlineKeyboardButton("XAGUSD", callback_data="instrument_XAGUSD_signals"),
-        InlineKeyboardButton("USOIL", callback_data="instrument_USOIL_signals")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Forex keyboard for signals
-FOREX_KEYBOARD_SIGNALS = [
-    [
-        InlineKeyboardButton("EURUSD", callback_data="instrument_EURUSD_signals"),
-        InlineKeyboardButton("GBPUSD", callback_data="instrument_GBPUSD_signals"),
-        InlineKeyboardButton("USDJPY", callback_data="instrument_USDJPY_signals")
-    ],
-    [
-        InlineKeyboardButton("USDCAD", callback_data="instrument_USDCAD_signals"),
-        InlineKeyboardButton("EURGBP", callback_data="instrument_EURGBP_signals")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Crypto keyboard for signals
-CRYPTO_KEYBOARD_SIGNALS = [
-    [
-        InlineKeyboardButton("BTCUSD", callback_data="instrument_BTCUSD_signals"),
-        InlineKeyboardButton("ETHUSD", callback_data="instrument_ETHUSD_signals"),
-        InlineKeyboardButton("XRPUSD", callback_data="instrument_XRPUSD_signals")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Indices keyboard voor sentiment analyse
-INDICES_SENTIMENT_KEYBOARD = [
-    [
-        InlineKeyboardButton("US30", callback_data="instrument_US30_sentiment"),
-        InlineKeyboardButton("US500", callback_data="instrument_US500_sentiment"),
-        InlineKeyboardButton("US100", callback_data="instrument_US100_sentiment")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Commodities keyboard voor sentiment analyse
-COMMODITIES_SENTIMENT_KEYBOARD = [
-    [
-        InlineKeyboardButton("GOLD", callback_data="instrument_XAUUSD_sentiment"),
-        InlineKeyboardButton("SILVER", callback_data="instrument_XAGUSD_sentiment"),
-        InlineKeyboardButton("OIL", callback_data="instrument_USOIL_sentiment")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Style keyboard
-STYLE_KEYBOARD = [
-    [InlineKeyboardButton("‚ö° Test (one_min)", callback_data="style_test")],
-    [InlineKeyboardButton("üèÉ Scalp (fifteen_min)", callback_data="style_scalp")],
-    [InlineKeyboardButton(" Intraday (one_hour)", callback_data="style_intraday")],
-    [InlineKeyboardButton("üåä Swing (four_hour)", callback_data="style_swing")],
-    [InlineKeyboardButton("Back", callback_data="back_instrument")]
-]
-
-# Timeframe mapping
-STYLE_TIMEFRAME_MAP = {
-    "test": "one_min",
-    "scalp": "fifteen_min",
-    "intraday": "one_hour",
-    "swing": "four_hour"
-}
-
-# Mapping of instruments to their allowed timeframes - updated 2023-03-23
-INSTRUMENT_TIMEFRAME_MAP = {
-    # H1 timeframe only
-    "AUDJPY": "H1", 
-    "AUDCHF": "H1",
-    "EURCAD": "H1",
-    "EURGBP": "H1",
-    "GBPCHF": "H1",
-    "HK50": "H1",
-    "NZDJPY": "H1",
-    "USDCHF": "H1",
-    "USDJPY": "H1",  # USDJPY toegevoegd voor signaalabonnementen
-    "XRPUSD": "H1",
-    
-    # H4 timeframe only
-    "AUDCAD": "H4",
-    "AU200": "H4", 
-    "CADCHF": "H4",
-    "EURCHF": "H4",
-    "EURUSD": "H4",
-    "GBPCAD": "H4",
-    "LINKUSD": "H4",
-    "NZDCHF": "H4",
-    
-    # M15 timeframe only
-    "DOGEUSD": "M15",
-    "GBPNZD": "M15",
-    "NZDUSD": "M15",
-    "SOLUSD": "M15",
-    "UK100": "M15",
-    "XAUUSD": "M15",
-    
-    # M30 timeframe only
-    "BNBUSD": "M30",
-    "DOTUSD": "M30",
-    "ETHUSD": "M30",
-    "EURAUD": "M30",
-    "EURJPY": "M30",
-    "GBPAUD": "M30",
-    "GBPUSD": "M30",
-    "NZDCAD": "M30",
-    "US30": "M30",
-    "US500": "M30",
-    "USDCAD": "M30",
-    "XLMUSD": "M30",
-    "XTIUSD": "M30",
-    "DE40": "M30",
-    "BTCUSD": "M30",  # Added for consistency with CRYPTO_KEYBOARD_SIGNALS
-    "US100": "M30",   # Added for consistency with INDICES_KEYBOARD_SIGNALS
-    "XAGUSD": "M15",  # Added for consistency with COMMODITIES_KEYBOARD_SIGNALS
-    "USOIL": "M30"    # Added for consistency with COMMODITIES_KEYBOARD_SIGNALS
-    
-    # Removed as requested: EU50, FR40, LTCUSD
-}
-
-# Map common timeframe notations
-TIMEFRAME_DISPLAY_MAP = {
-    "M15": "15 Minutes",
-    "M30": "30 Minutes", 
-    "H1": "1 Hour",
-    "H4": "4 Hours"
-}
-
-# Voeg deze functie toe aan het begin van bot.py, na de imports
-def _detect_market(instrument: str) -> str:
-    """Detecteer market type gebaseerd op instrument"""
-    instrument = instrument.upper()
-    
-    # Commodities eerst checken
-    commodities = [
-        "XAUUSD",  # Gold
-        "XAGUSD",  # Silver
-        "WTIUSD",  # Oil WTI
-        "BCOUSD",  # Oil Brent
-        "USOIL",   # Oil WTI (alternative symbol)
-    ]
-    if instrument in commodities:
-        logger.info(f"Detected {instrument} as commodity")
-        return "commodities"
-    
-    # Crypto pairs
-    crypto_base = ["BTC", "ETH", "XRP", "SOL", "BNB", "ADA", "DOT", "LINK"]
-    if any(c in instrument for c in crypto_base):
-        logger.info(f"Detected {instrument} as crypto")
-        return "crypto"
-    
-    # Major indices
-    indices = [
-        "US30", "US500", "US100",  # US indices
-        "UK100", "DE40", "FR40",   # European indices
-        "JP225", "AU200", "HK50"   # Asian indices
-    ]
-    if instrument in indices:
-        logger.info(f"Detected {instrument} as index")
-        return "indices"
-    
-    # Forex pairs als default
-    logger.info(f"Detected {instrument} as forex")
-    return "forex"
-
-# Voeg dit toe als decorator functie bovenaan het bestand na de imports
-def require_subscription(func):
-    """Check if user has an active subscription"""
-    async def wrapper(self, update: Update, context: ContextTypes.DEFAULT_TYPE, *args, **kwargs):
-        user_id = update.effective_user.id
-        
-        # Check subscription status
-        is_subscribed = await self.db.is_user_subscribed(user_id)
-        
-        # Check if payment has failed
-        payment_failed = await self.db.has_payment_failed(user_id)
-        
-        if is_subscribed and not payment_failed:
-            # User has subscription, proceed with function
-            return await func(self, update, context, *args, **kwargs)
-        else:
-            if payment_failed:
-                # Show payment failure message
-                failed_payment_text = f"""
- <b>Subscription Payment Failed</b> 
-
-Your subscription payment could not be processed and your service has been deactivated.
-
-To continue using Sigmapips AI and receive trading signals, please reactivate your subscription by clicking the button below.
-                """
-                
-                # Use direct URL link for reactivation
-                reactivation_url = "https://buy.stripe.com/9AQcPf3j63HL5JS145"
-                
-                # Create button for reactivation
-                keyboard = [
-                    [InlineKeyboardButton("üîÑ Reactivate Subscription", url=reactivation_url)]
-                ]
-            else:
-                # Show subscription screen with the welcome message from the screenshot
-                failed_payment_text = f"""
- <b>Welcome to Sigmapips AI!</b> 
-
-<b>Discover powerful trading signals for various markets:</b>
-- <b>Forex</b> - Major and minor currency pairs
-- <b>Crypto</b> - Bitcoin, Ethereum and other top cryptocurrencies
-- <b>Indices</b> - Global market indices
-- <b>Commodities</b> - Gold, silver and oil
-
-<b>Features:</b>
- Real-time trading signals
-
- Multi-timeframe analysis (timeframes)
-
- Advanced chart analysis
-
- Sentiment indicators
-
- Economic calendar integration
-
-<b>Start today with a FREE 14-day trial!</b>
-                """
-                
-                # Use direct URL link instead of callback for the trial button
-                reactivation_url = "https://buy.stripe.com/3cs3eF9Hu9256NW9AA"
-                
-                # Create button for trial
-                keyboard = [
-                    [InlineKeyboardButton("üî• Start 14-day FREE Trial", url=reactivation_url)]
-                ]
-            
-            # Handle both message and callback query updates
-            if update.callback_query:
-                await update.callback_query.answer()
-                await update.callback_query.edit_message_text(
-                    text=failed_payment_text,
-                    reply_markup=InlineKeyboardMarkup(keyboard),
-                    parse_mode=ParseMode.HTML
-                )
-            else:
-                await update.message.reply_text(
-                    text=failed_payment_text,
-                    reply_markup=InlineKeyboardMarkup(keyboard),
-                    parse_mode=ParseMode.HTML
-                )
-            return MENU
-    
-    return wrapper
-
-# API keys with robust sanitization
-PERPLEXITY_API_KEY = os.getenv("PERPLEXITY_API_KEY", "").strip()
-OPENAI_API_KEY = os.getenv("OPENAI_API_KEY", "").strip()  # Changed from DeepSeek to OpenAI
-
-# Only using OpenAI's o4-mini now
-# No Tavily API key needed anymore
-logger.info("Using only OpenAI o4-mini for Market Sentiment service")
-
-# Log OpenAI API key (partially masked)
-if OPENAI_API_KEY:
-    # Better masking for privacy and security
-    masked_key = f"sk-p...{OPENAI_API_KEY[-4:]}" if len(OPENAI_API_KEY) > 8 else "sk-p..."
-    logger.info(f"Using OpenAI API key: {masked_key}")
-    
-    # Validate the key format
-    from trading_bot.config import validate_openai_key
-    if not validate_openai_key(OPENAI_API_KEY):
-        logger.warning("OpenAI API key format is invalid. AI services may not work correctly.")
-else:
-    logger.warning("No OpenAI API key configured. AI services will be disabled.")
-    
-# Set environment variables for the API keys with sanitization
-os.environ["PERPLEXITY_API_KEY"] = PERPLEXITY_API_KEY
-os.environ["OPENAI_API_KEY"] = OPENAI_API_KEY  # Changed from DeepSeek to OpenAI
-# No Tavily environment needed
-
-class TelegramService:
-    def __init__(self, db: Database, stripe_service=None, bot_token: Optional[str] = None, proxy_url: Optional[str] = None, lazy_init: bool = False):
-        """Initialize the bot with given database and config."""
-        # Database connection
-        self.db = db
-        
-        # Setup configuration 
-        self.stripe_service = stripe_service
-        self.user_signals = {}
-        self.signals_dir = "data/signals"
-        self.signals_enabled_val = True
-        self.polling_started = False
-        self.admin_users = [2004519703]  # Updated with correct Telegram ID from logs
-        self._signals_enabled = True  # Enable signals by default
-        
-        # Setup logger
-        self.logger = logging.getLogger(__name__)
-        
-        # GIF utilities for UI
-        self.gif_utils = gif_utils  # Initialize gif_utils as an attribute
-        
-        # Setup the bot and application
-        self.bot = None
-        self.application = None
-        
-        # Telegram Bot configuratie
-        self.bot_token = bot_token or os.getenv("TELEGRAM_BOT_TOKEN", "")
-        self.token = self.bot_token  # Aliased for backward compatibility
-        self.proxy_url = proxy_url or os.getenv("TELEGRAM_PROXY_URL", "")
-        
-        # Configure custom request handler with improved connection settings
-        request = HTTPXRequest(
-            connection_pool_size=50,  # Increase from 20 to 50
-            connect_timeout=15.0,     # Increase from 10.0 to 15.0
-            read_timeout=45.0,        # Increase from 30.0 to 45.0
-            write_timeout=30.0,       # Increase from 20.0 to 30.0
-            pool_timeout=60.0,        # Increase from 30.0 to 60.0
-        )
-        
-        # Initialize the bot directly with connection pool settings
-        self.bot = Bot(token=self.bot_token, request=request)
-        self.application = None  # Will be initialized in setup()
-        
-        # Webhook configuration
-        self.webhook_url = os.getenv("WEBHOOK_URL", "")
-        self.webhook_path = "/webhook"  # Always use this path
-        if self.webhook_url.endswith("/"):
-            self.webhook_url = self.webhook_url[:-1]  # Remove trailing slash
-            
-        logger.info(f"Bot initialized with webhook URL: {self.webhook_url} and path: {self.webhook_path}")
-        
-        # Initialize API services
-        self.chart_service = ChartService()  # Initialize chart service
-        # Lazy load services only when needed
-        self._calendar_service = None
-        self._sentiment_service = None
-        
-        # Don't use asyncio.create_task here - it requires a running event loop
-        # We'll initialize chart service later when the event loop is running
-        
-        # Bot application initialization
-        self.persistence = None
-        self.bot_started = False
-        
-        # Cache for sentiment analysis
-        self.sentiment_cache = {}
-        self.sentiment_cache_ttl = 60 * 60  # 1 hour in seconds
-        
-        # Start the bot
-    try:
-            # Check for bot token
-            if not self.bot_token:
-                raise ValueError("Missing Telegram bot token")
-            
-            # Initialize the bot
-            self.bot = Bot(token=self.bot_token)
-        
-            # Initialize the application
-            self.application = Application.builder().bot(self.bot).build()
-        
-            # Register the handlers
-            self._register_handlers(self.application)
-            
-            # Initialize signals dictionary but don't load them yet (will be done in initialize_services)
-            self.user_signals = {}
-        
-            logger.info("Telegram service initialized")
-            
-            # Keep track of processed updates
-            self.processed_updates = set()
-            
-    except Exception as e:
-        logger.error(f"Error initializing Telegram service: {str(e)}")
-        raise
-
-    async def initialize_services(self):
-        """Initialize services that require an asyncio event loop"""
-        try:
-            # Initialize chart service
-            await self.chart_service.initialize()
-            logger.info("Chart service initialized")
-            
-            # Load stored signals
-            await self._load_signals()
-            logger.info("Signals loaded")
-            
-            # Schedule periodic cleanup of old signals
-            if hasattr(self, 'db') and self.db and self.db.using_redis:
-                # Run initial cleanup
-                cleaned = await self._cleanup_old_signals(max_age_days=7)
-                logger.info(f"Initial signal cleanup completed, removed {cleaned} old signals")
-                
-                # Schedule periodic cleanup (every 24 hours)
-                async def periodic_cleanup():
-                    while True:
-                        try:
-                            # Wait for 24 hours
-                            await asyncio.sleep(24 * 60 * 60)
-                            # Run cleanup
-                            cleaned = await self._cleanup_old_signals(max_age_days=7)
-                            logger.info(f"Periodic signal cleanup completed, removed {cleaned} old signals")
-                        except Exception as e:
-                            logger.error(f"Error in periodic signal cleanup: {str(e)}")
-                
-                # Start the periodic cleanup task
-                asyncio.create_task(periodic_cleanup())
-                logger.info("Scheduled periodic signal cleanup")
-        except Exception as e:
-            logger.error(f"Error initializing services: {str(e)}")
-            raise
-            
-    # Calendar service helpers
-    @property
-    def calendar_service(self):
-        """Lazy loaded calendar service"""
-        if self._calendar_service is None:
-            # Only initialize the calendar service when it's first accessed
-            self.logger.info("Lazy loading calendar service")
-            self._calendar_service = EconomicCalendarService()
-        return self._calendar_service
-        
-    def _get_calendar_service(self):
-        """Get the calendar service instance"""
-        self.logger.info("Getting calendar service")
-        return self.calendar_service
-
-    async def _format_calendar_events(self, calendar_data):
-        """Format the calendar data into a readable HTML message"""
-        self.logger.info(f"Formatting calendar data with {len(calendar_data)} events")
-        if not calendar_data:
-            return "<b>Economic Calendar</b>\n\nNo economic events found for today."
-        
-        # Sort events by time
-        try:
-            # Try to parse time for sorting
-            def parse_time_for_sorting(event):
-                time_str = event.get('time', '')
-                try:
-                    # Extract hour and minute if in format like "08:30 EST"
-                    if ':' in time_str:
-                        parts = time_str.split(' ')[0].split(':')
-                        hour = int(parts[0])
-                        minute = int(parts[1])
-                        return hour * 60 + minute
-                    return 0
-                except:
-                    return 0
-            
-            # Sort the events by time
-            sorted_events = sorted(calendar_data, key=parse_time_for_sorting)
-        except Exception as e:
-            self.logger.error(f"Error sorting calendar events: {str(e)}")
-            sorted_events = calendar_data
-        
-        # Format the message
-        message = "<b>Economic Calendar</b>\n\n"
-        
-        # Get current date
-        current_date = datetime.now().strftime("%B %d, %Y")
-        message += f"<b>Date:</b> {current_date}\n\n"
-        
-        # Add impact legend
-        message += "<b>Impact:</b> üî¥ High   üü† Medium   üü¢ Low\n\n"
-        
-        # Group events by country
-        events_by_country = {}
-        for event in sorted_events:
-            country = event.get('country', 'Unknown')
-            if country not in events_by_country:
-                events_by_country[country] = []
-            events_by_country[country].append(event)
-        
-        # Format events by country
-        for country, events in events_by_country.items():
-            country_flag = CURRENCY_FLAG.get(country, '')
-            message += f"<b>{country_flag} {country}</b>\n"
-            
-            for event in events:
-                time = event.get('time', 'TBA')
-                title = event.get('title', 'Unknown Event')
-                impact = event.get('impact', 'Low')
-                impact_emoji = {'High': 'üî¥', 'Medium': 'üü†', 'Low': 'üü¢'}.get(impact, 'üü¢')
-                
-                message += f"{time} - {impact_emoji} {title}\n"
-            
-            message += "\n"  # Add extra newline between countries
-        
-        return message
-        
-    # Utility functions that might be missing
-    async def update_message(self, query, text, keyboard=None, parse_mode=ParseMode.HTML):
-        """Utility to update a message with error handling"""
-        try:
-            # Check if the message is too long for Telegram caption limits (1024 chars)
-            MAX_CAPTION_LENGTH = 1000  # Slightly under the 1024 limit for safety
-            MAX_MESSAGE_LENGTH = 4000  # Telegram message limit
-            
-            # Log message length for debugging
-            logger.info(f"Updating message (length: {len(text)} chars)")
-            
-            # If message is too long for a caption but ok for a text message
-            if len(text) > MAX_CAPTION_LENGTH and len(text) <= MAX_MESSAGE_LENGTH:
-                logger.info("Message too long for caption but ok for text message")
-                # Try to edit message text first
-                await query.edit_message_text(
-                    text=text,
-                    reply_markup=keyboard,
-                    parse_mode=parse_mode
-                )
-                return True
-            # If message is too long even for a text message
-            elif len(text) > MAX_MESSAGE_LENGTH:
-                logger.warning(f"Message too long ({len(text)} chars), truncating")
-                # Find a good breaking point
-                truncated = text[:MAX_MESSAGE_LENGTH-100]
-                
-                # Try to break at a paragraph
-                last_newline = truncated.rfind('\n\n')
-                if last_newline > MAX_MESSAGE_LENGTH * 0.8:  # If we can keep at least 80% of the text
-                    truncated = truncated[:last_newline]
-                    
-                # Add indicator that text was truncated
-                truncated += "\n\n<i>... (message truncated)</i>"
-                
-                # Try to edit message text with truncated content
-                await query.edit_message_text(
-                    text=truncated,
-                    reply_markup=keyboard,
-                    parse_mode=parse_mode
-                )
-                return True
-            else:
-                # Normal case - message is within limits
-                # Try to edit message text first
-                await query.edit_message_text(
-                    text=text,
-                    reply_markup=keyboard,
-                    parse_mode=parse_mode
-                )
-                return True
-        except Exception as e:
-            logger.warning(f"Could not update message text: {str(e)}")
-            
-            # If text update fails, try to edit caption
-            try:
-                # Check if caption is too long
-                MAX_CAPTION_LENGTH = 1000  # Slightly under the 1024 limit for safety
-                
-                if len(text) > MAX_CAPTION_LENGTH:
-                    logger.warning(f"Caption too long ({len(text)} chars), truncating")
-                    # Find a good breaking point
-                    truncated = text[:MAX_CAPTION_LENGTH-100]
-                    
-                    # Try to break at a paragraph
-                    last_newline = truncated.rfind('\n\n')
-                    if last_newline > MAX_CAPTION_LENGTH * 0.8:  # If we can keep at least 80% of the text
-                        truncated = truncated[:last_newline]
-                        
-                    # Add indicator that text was truncated
-                    truncated += "\n\n<i>... (message truncated)</i>"
-                    
-                    # Use truncated text for caption
-                    await query.edit_message_caption(
-                        caption=truncated,
-                        reply_markup=keyboard,
-                        parse_mode=parse_mode
-                    )
-                else:
-                    # Caption is within limits
-                    await query.edit_message_caption(
-                        caption=text,
-                        reply_markup=keyboard,
-                        parse_mode=parse_mode
-                    )
-                return True
-            except Exception as e2:
-                logger.error(f"Could not update caption either: {str(e2)}")
-                
-                # As a last resort, send a new message
-                try:
-                    chat_id = query.message.chat_id
-                    
-                    # Check if message is too long
-                    MAX_MESSAGE_LENGTH = 4000  # Telegram message limit
-                    
-                    if len(text) > MAX_MESSAGE_LENGTH:
-                        logger.warning(f"New message too long ({len(text)} chars), truncating")
-                        # Find a good breaking point
-                        truncated = text[:MAX_MESSAGE_LENGTH-100]
-                        
-                        # Try to break at a paragraph
-                        last_newline = truncated.rfind('\n\n')
-                        if last_newline > MAX_MESSAGE_LENGTH * 0.8:  # If we can keep at least 80% of the text
-                            truncated = truncated[:last_newline]
-                            
-                        # Add indicator that text was truncated
-                        truncated += "\n\n<i>... (message truncated)</i>"
-                        
-                        # Use truncated text for new message
-                        await query.bot.send_message(
-                            chat_id=chat_id,
-                            text=truncated,
-                            reply_markup=keyboard,
-                            parse_mode=parse_mode
-                        )
-                    else:
-                        # Message is within limits
-                        await query.bot.send_message(
-                            chat_id=chat_id,
-                            text=text,
-                            reply_markup=keyboard,
-                            parse_mode=parse_mode
-                        )
-                    return True
-                except Exception as e3:
-                    logger.error(f"Failed to send new message: {str(e3)}")
-                    return False
-    
-    # Missing handler implementations
-    async def back_signals_callback(self, update: Update, context=None) -> int:
-        """Handle back_signals button press"""
-        query = update.callback_query
-        await query.answer()
-        
-        logger.info("back_signals_callback called")
-        
-        # Make sure we're in the signals flow context
-        if context and hasattr(context, 'user_data'):
-            # Reset signal flow flags
-            context.user_data['from_signal'] = False
-            context.user_data['in_signal_flow'] = False
-            logger.info(f"Reset signal flow flags: from_signal=False, in_signal_flow=False")
-            # Keep is_signals_context flag but reset from_signal flag
-            context.user_data['is_signals_context'] = True
-            context.user_data['from_signal'] = False
-            
-            # Clear other specific analysis keys but maintain signals context
-            keys_to_remove = [
-                'instrument', 'market', 'analysis_type', 'timeframe', 
-                'signal_id', 'signal_instrument', 'signal_direction', 'signal_timeframe',
-                'loading_message'
-            ]
-
-            for key in keys_to_remove:
-                if key in context.user_data:
-                    del context.user_data[key]
-            logger.info(f"Updated context in back_signals_callback: {context.user_data}")
-        
-        # Create keyboard for signal menu
-        keyboard = [
-            [InlineKeyboardButton(" Add Signal", callback_data="signals_add")],
-            [InlineKeyboardButton("Manage Signals", callback_data="signals_manage")],
-            [InlineKeyboardButton("Back to Menu", callback_data="back_menu")]
-        ]
-        reply_markup = InlineKeyboardMarkup(keyboard)
-        
-        # Get the signals GIF URL for better UX
-        signals_gif_url = "https://media.giphy.com/media/gSzIKNrqtotEYrZv7i/giphy.gif"
-        
-        # Update the message
-        await self.update_message(
-            query=query,            text="<b> Signal Management</b>\n\nManage your trading signals",
-
-
-            keyboard=reply_markup
-        )
-        
-        return SIGNALS
-        
-    async def get_subscribers_for_instrument(self, instrument: str, timeframe: str = None) -> List[int]:
-        """
-        Get a list of subscribed user IDs for a specific instrument and timeframe
-        
-        Args:
-            instrument: The trading instrument (e.g., EURUSD)
-            timeframe: Optional timeframe filter
-            
-        Returns:
-            List of subscribed user IDs
-        """
-    try:
-            logger.info(f"Getting subscribers for {instrument} timeframe: {timeframe}")
-            
-            # Get all subscribers from the database
-            # Note: Using get_signal_subscriptions instead of find_all
-            subscribers = await self.db.get_signal_subscriptions(instrument, timeframe)
-            
-            if not subscribers:
-                logger.warning(f"No subscribers found for {instrument}")
-                return []
-                
-            # Filter out subscribers that don't have an active subscription
-            active_subscribers = []
-            for subscriber in subscribers:
-                user_id = subscriber['user_id']
-                
-                # Check if user is subscribed
-                is_subscribed = await self.db.is_user_subscribed(user_id)
-                
-                # Check if payment has failed
-                payment_failed = await self.db.has_payment_failed(user_id)
-                
-                if is_subscribed and not payment_failed:
-                    active_subscribers.append(user_id)
-                else:
-                    logger.info(f"User {user_id} doesn't have an active subscription, skipping signal")
-            
-            return active_subscribers
-            
-    except Exception as e:
-        logger.error(f"Error getting subscribers: {str(e)}")
-        # FOR TESTING: Add admin users if available
-        if hasattr(self, 'admin_users') and self.admin_users:
-            logger.info(f"Returning admin users for testing: {self.admin_users}")
-            return self.admin_users
-        return []
-
-    async def process_signal(self, signal_data: Dict[str, Any]) -> bool:
-        """
-        Process a trading signal from TradingView webhook or API
-        
-        Supports two formats:
-        1. TradingView format: instrument, signal, price, sl, tp1, tp2, tp3, interval
-        2. Custom format: instrument, direction, entry, stop_loss, take_profit, timeframe
-        
-        Returns:
-            bool: True if signal was processed successfully, False otherwise
-        """
-        try:
-            # Log the incoming signal data
-            logger.info(f"Processing signal: {signal_data}")
-            
-            # Check which format we're dealing with and normalize it
-            instrument = signal_data.get('instrument')
-            
-            # Handle TradingView format (price, sl, interval)
-            if 'price' in signal_data and 'sl' in signal_data:
-                price = signal_data.get('price')
-                sl = signal_data.get('sl')
-                tp1 = signal_data.get('tp1')
-                tp2 = signal_data.get('tp2')
-                tp3 = signal_data.get('tp3')
-                interval = signal_data.get('interval', 'one_hour')
-                
-                # Determine signal direction based on price and SL relationship
-                direction = "BUY" if float(sl) < float(price) else "SELL"
-                
-                # Create normalized signal data
-                normalized_data = {
-                    'instrument': instrument,
-                    'direction': direction,
-                    'entry': price,
-                    'stop_loss': sl,
-                    'take_profit': tp1,  # Use first take profit level
-                    'timeframe': interval
-                }
-                
-                # Add optional fields if present
-                normalized_data['tp1'] = tp1
-                normalized_data['tp2'] = tp2
-                normalized_data['tp3'] = tp3
-                
-            # Handle custom format (direction, entry, stop_loss, timeframe)
-            elif 'direction' in signal_data and 'entry' in signal_data:
-                direction = signal_data.get('direction')
-                entry = signal_data.get('entry')
-                stop_loss = signal_data.get('stop_loss')
-                take_profit = signal_data.get('take_profit')
-                timeframe = signal_data.get('timeframe', 'one_hour')
-                
-                # Create normalized signal data
-                normalized_data = {
-                    'instrument': instrument,
-                    'direction': direction,
-                    'entry': entry,
-                    'stop_loss': stop_loss,
-                    'take_profit': take_profit,
-                    'timeframe': timeframe
-                }
-            else:
-                logger.error(f"Missing required signal data")
-                return False
-            
-            # Basic validation
-            if not normalized_data.get('instrument') or not normalized_data.get('direction') or not normalized_data.get('entry'):
-                logger.error(f"Missing required fields in normalized signal data: {normalized_data}")
-                return False
-                
-            # Create signal ID for tracking
-            signal_id = f"{normalized_data['instrument']}_{normalized_data['direction']}_{normalized_data['timeframe']}_{int(time.time())}"
-            
-            # Format the signal message
-            message = self._format_signal_message(normalized_data)
-            
-            # Determine market type for the instrument
-            market_type = _detect_market(instrument)
-            
-            # Store the full signal data for reference
-            normalized_data['id'] = signal_id
-            normalized_data['timestamp'] = datetime.now().isoformat()
-            normalized_data['message'] = message
-            normalized_data['market'] = market_type
-            
-            # Save signal for history tracking
-            if not os.path.exists(self.signals_dir):
-                os.makedirs(self.signals_dir, exist_ok=True)
-                
-            # Save to signals directory
-            with open(f"{self.signals_dir}/{signal_id}.json", 'w') as f:
-                json.dump(normalized_data, f)
-            
-            # FOR TESTING: Always send to admin for testing
-            if hasattr(self, 'admin_users') and self.admin_users:
-                try:
-                    logger.info(f"Sending signal to admin users for testing: {self.admin_users}")
-                    for admin_id in self.admin_users:
-                        # Prepare keyboard with analysis options
-                        keyboard = [
-                            [InlineKeyboardButton("Analyze Market", callback_data=f"analyze_from_signal_{instrument}_{signal_id}")]
-                        ]
-                        
-                        # Send the signal
-                        await self.bot.send_message(
-                            chat_id=admin_id,
-                            text=message,
-                            parse_mode=ParseMode.HTML,
-                            reply_markup=InlineKeyboardMarkup(keyboard)
-                        )
-                        logger.info(f"Test signal sent to admin {admin_id}")
-                        
-                        # Store signal reference for quick access
-                        if not hasattr(self, 'user_signals'):
-                            self.user_signals = {}
-                            
-                        admin_str_id = str(admin_id)
-                        if admin_str_id not in self.user_signals:
-                            self.user_signals[admin_str_id] = {}
-                        
-                        self.user_signals[admin_str_id][signal_id] = normalized_data
-            except Exception as e:
-                logger.error(f"Error sending test signal to admin: {str(e)}")
-            
-            # Get subscribers for this instrument
-            timeframe = normalized_data.get('timeframe', 'one_hour')
-            subscribers = await self.get_subscribers_for_instrument(instrument, timeframe)
-            
-            if not subscribers:
-                logger.warning(f"No subscribers found for {instrument}")
-                return True  # Successfully processed, just no subscribers
-            
-            # Send signal to all subscribers
-            logger.info(f"Sending signal {signal_id} to {len(subscribers)} subscribers")
-            
-            sent_count = 0
-            for user_id in subscribers:
-                try:
-                    # Prepare keyboard with analysis options
-                    keyboard = [
-                        [InlineKeyboardButton("Analyze Market", callback_data=f"analyze_from_signal_{instrument}_{signal_id}")]
-                    ]
-                    
-                    # Send the signal
-                    await self.bot.send_message(
-                        chat_id=user_id,
-                        text=message,
-                        parse_mode=ParseMode.HTML,
-                        reply_markup=InlineKeyboardMarkup(keyboard)
-                    )
-                    
-                    sent_count += 1
-                    
-                    # Store signal reference for quick access
-                    if not hasattr(self, 'user_signals'):
-                        self.user_signals = {}
-                        
-                    user_str_id = str(user_id)
-                    if user_str_id not in self.user_signals:
-                        self.user_signals[user_str_id] = {}
-                    
-                    self.user_signals[user_str_id][signal_id] = normalized_data
-                    
-            except Exception as e:
-                logger.error(f"Error sending signal to user {user_id}: {str(e)}")
-            
-            logger.info(f"Successfully sent signal {signal_id} to {sent_count}/{len(subscribers)} subscribers")
-            return True
-            
-    except Exception as e:
-        logger.error(f"Error processing signal: {str(e)}")
-        logger.exception(e)
-            return False
-
-    def _format_signal_message(self, signal_data: Dict[str, Any]) -> str:
-        """Format signal data into a nice message for Telegram"""
-    try:
-            # Extract fields from signal data
-            instrument = signal_data.get('instrument', 'Unknown')
-            direction = signal_data.get('direction', 'Unknown')
-            entry = signal_data.get('entry', 'Unknown')
-            stop_loss = signal_data.get('stop_loss')
-            take_profit = signal_data.get('take_profit')
-            timeframe = signal_data.get('timeframe', 'one_hour')
-            
-            # Get multiple take profit levels if available
-            tp1 = signal_data.get('tp1', take_profit)
-            tp2 = signal_data.get('tp2')
-            tp3 = signal_data.get('tp3')
-            
-            # Add emoji based on direction
-            direction_emoji = "üü¢" if direction.upper() == "BUY" else "üî¥"
-            
-            # Format the message with multiple take profits if available
-            message = "<b> New Trading Signal </b>\n"
-\n"
-            message += f"<b>Instrument:</b> {instrument}\n"
-            message += f"<b>Action:</b> {direction.upper()} {direction_emoji}
-\n"
-            message += f"<b>Entry Price:</b> {entry}\n"
-            
-            if stop_loss:
-                message += f"<b>Stop Loss:</b> {stop_loss} üî¥\n"
-            
-            # Add take profit levels
-            if tp1:
-                message += f"<b>Take Profit 1:</b> {tp1} \n"
-            if tp2:
-                message += f"<b>Take Profit 2:</b> {tp2} \n"
-            if tp3:
-                message += f"<b>Take Profit 3:</b> {tp3} \n"
-            
-            message += f"
-<b>Timeframe:</b> {timeframe}\n"
-            message += f"<b>Strategy:</b> TradingView Signal
-\n"
-            
-            message += "‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
-
-"
-            message += "<b>Risk Management:</b>\n"
-            message += "- Position size: 1-2% max\n"
-            message += "- Use proper stop loss\n"
-            message += "- Follow your trading plan
-
-"
-            
-            message += "‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
-
-"
-            
-            # Generate AI verdict
-            ai_verdict = f"The {instrument} {direction.lower()} signal shows a promising setup with defined entry at {entry} and stop loss at {stop_loss}. Multiple take profit levels provide opportunities for partial profit taking."
-            message += f"<b>ü§ñ SigmaPips AI Verdict:</b>\n{ai_verdict}"
-            
-            return message
-            
-    except Exception as e:
-        logger.error(f"Error formatting signal message: {str(e)}")
-            # Return simple message on error
-            return f"New {signal_data.get('instrument', 'Unknown')} {signal_data.get('direction', 'Unknown')} Signal"
-
-    def _register_handlers(self, application):
-        """Register event handlers for bot commands and callback queries"""
-    try:
-            logger.info("Registering command handlers")
-            
-            # Initialize the application without using run_until_complete
-        try:
-                # Instead of using loop.run_until_complete, directly call initialize 
-                # which will be properly awaited by the caller
-                self.init_task = application.initialize()
-                logger.info("Telegram application initialization ready to be awaited")
-            except Exception as init_e:
-            logger.error(f"Error during application initialization: {str(init_e)}")
-            logger.exception(init_e)
-                
-            # Set bot commands for menu
-            commands = [
-                BotCommand("start", "Start the bot and get the welcome message"),
-                BotCommand("menu", "Show the main menu"),
-                BotCommand("help", "Show available commands and how to use the bot")
-            ]
-            
-            # Store the set_commands_task to be awaited later
-        try:
-                # Instead of asyncio.create_task, we will await this in the startup event
-                self.set_commands_task = self.bot.set_my_commands(commands)
-                logger.info("Bot commands ready to be set")
-            except Exception as cmd_e:
-            logger.error(f"Error preparing bot commands: {str(cmd_e)}")
-            
-            # Register command handlers
-            application.add_handler(CommandHandler("start", self.start_command))
-            application.add_handler(CommandHandler("menu", self.menu_command))
-            application.add_handler(CommandHandler("help", self.help_command))
-            
-            # Register secret admin commands
-            application.add_handler(CommandHandler("set_subscription", self.set_subscription_command))
-            application.add_handler(CommandHandler("set_payment_failed", self.set_payment_failed_command))
-            logger.info("Registered secret admin commands")
-            
-            # Register callback handlers
-            application.add_handler(CallbackQueryHandler(self.menu_analyse_callback, pattern="^menu_analyse$"))
-            application.add_handler(CallbackQueryHandler(self.menu_signals_callback, pattern="^menu_signals$"))
-            application.add_handler(CallbackQueryHandler(self.signals_add_callback, pattern="^signals_add$"))
-            application.add_handler(CallbackQueryHandler(self.signals_manage_callback, pattern="^signals_manage$"))
-            application.add_handler(CallbackQueryHandler(self.market_callback, pattern="^market_"))
-            application.add_handler(CallbackQueryHandler(self.instrument_callback, pattern="^instrument_(?!.*_signals)"))
-            application.add_handler(CallbackQueryHandler(self.instrument_signals_callback, pattern="^instrument_.*_signals$"))
-            
-            # Add handler for back buttons
-            application.add_handler(CallbackQueryHandler(self.back_market_callback, pattern="^back_market$"))
-            application.add_handler(CallbackQueryHandler(self.back_instrument_callback, pattern="^back_instrument$"))
-            application.add_handler(CallbackQueryHandler(self.back_signals_callback, pattern="^back_signals$"))
-            application.add_handler(CallbackQueryHandler(self.back_menu_callback, pattern="^back_menu$"))
-            
-            # Analysis handlers for regular flow
-            application.add_handler(CallbackQueryHandler(self.analysis_technical_callback, pattern="^analysis_technical$"))
-            application.add_handler(CallbackQueryHandler(self.analysis_sentiment_callback, pattern="^analysis_sentiment$"))
-            application.add_handler(CallbackQueryHandler(self.analysis_calendar_callback, pattern="^analysis_calendar$"))
-            
-            # Analysis handlers for signal flow - with instrument embedded in callback
-            application.add_handler(CallbackQueryHandler(self.signal_technical_callback, pattern="^signal_flow_technical_.*$"))
-            application.add_handler(CallbackQueryHandler(self.signal_sentiment_callback, pattern="^signal_flow_sentiment_.*$"))
-            application.add_handler(CallbackQueryHandler(self.signal_calendar_callback, pattern="^signal_flow_calendar_.*$"))
-            
-            # Analysis handlers for signal flow - with instrument embedded in callback
-            application.add_handler(CallbackQueryHandler(self.signal_technical_callback, pattern="^signal_flow_technical_.*$"))
-            application.add_handler(CallbackQueryHandler(self.signal_sentiment_callback, pattern="^signal_flow_sentiment_.*$"))
-            application.add_handler(CallbackQueryHandler(self.analysis_calendar_callback, pattern="^signal_flow_calendar_.*$"))
-            
-            # Signal analysis flow handlers
-            application.add_handler(CallbackQueryHandler(self.signal_technical_callback, pattern="^signal_technical$"))
-            application.add_handler(CallbackQueryHandler(self.signal_sentiment_callback, pattern="^signal_sentiment$"))
-            application.add_handler(CallbackQueryHandler(self.signal_calendar_callback, pattern="^signal_calendar$"))
-            application.add_handler(CallbackQueryHandler(self.signal_calendar_callback, pattern="^signal_flow_calendar_.*$"))
-            application.add_handler(CallbackQueryHandler(self.back_to_signal_callback, pattern="^back_to_signal$"))
-            application.add_handler(CallbackQueryHandler(self.back_to_signal_analysis_callback, pattern="^back_to_signal_analysis$"))
-            
-            # Signal from analysis
-            application.add_handler(CallbackQueryHandler(self.analyze_from_signal_callback, pattern="^analyze_from_signal_.*$"))
-            
-            # Ensure back_instrument is properly handled
-            application.add_handler(CallbackQueryHandler(self.back_instrument_callback, pattern="^back_instrument$"))
-            
-            # Catch-all handler for any other callbacks
-            application.add_handler(CallbackQueryHandler(self.button_callback))
-            
-            # Don't load signals here - it will be done in initialize_services
-            # self._load_signals()
-            
-            logger.info("Bot setup completed successfully")
-            
-    except Exception as e:
-        logger.error(f"Error setting up bot handlers: {str(e)}")
-        logger.exception(e)
-
-    @property
-    def signals_enabled(self):
-        """Get whether signals processing is enabled"""
-        return self._signals_enabled
-    
-    @signals_enabled.setter
-    def signals_enabled(self, value):
-        """Set whether signals processing is enabled"""
-        self._signals_enabled = bool(value)
-        logger.info(f"Signal processing is now {'enabled' if value else 'disabled'}")
-
-    async def _get_signal_related_trades(self, signal_id):
-    """Retrieve related trades from the database"""
-    try:
-        # Fetch the related trades data from the database
-        trades_data = await self.db.get_related_trades(signal_id)
-            
-        if trades_data:
-            return trades_data
-        else:
-            logger.warning(f"No related trades data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related trades: {str(e)}")
-        logger.exception(e)
-        return None
-
-
-from telegram.error import TelegramError, BadRequest
-import httpx
-import telegram.error  # Add this import for BadRequest error handling
-
-from trading_bot.services.database.db import Database
-from trading_bot.services.chart_service.chart import ChartService
-from trading_bot.services.sentiment_service.sentiment import MarketSentimentService
-from trading_bot.services.calendar_service import EconomicCalendarService
-from trading_bot.services.payment_service.stripe_service import StripeService
-from trading_bot.services.payment_service.stripe_config import get_subscription_features
-from trading_bot.services.telegram_service.states import (
-    MENU, ANALYSIS, SIGNALS, CHOOSE_MARKET, CHOOSE_INSTRUMENT, CHOOSE_STYLE,
-    CHOOSE_ANALYSIS, SIGNAL_DETAILS,
-    CALLBACK_MENU_ANALYSE, CALLBACK_MENU_SIGNALS, CALLBACK_ANALYSIS_TECHNICAL,
-    CALLBACK_ANALYSIS_SENTIMENT, CALLBACK_ANALYSIS_CALENDAR, CALLBACK_SIGNALS_ADD,
-    CALLBACK_SIGNALS_MANAGE, CALLBACK_BACK_MENU
-)
-import trading_bot.services.telegram_service.gif_utils as gif_utils
-
-# Initialize logger
-logger = logging.getLogger(__name__)
-
-# Major currencies to focus on
-MAJOR_CURRENCIES = ["USD", "EUR", "GBP", "JPY", "CHF", "AUD", "NZD", "CAD"]
-
-# Currency to flag emoji mapping
-CURRENCY_FLAG = {
-    "USD": "üá∫üá∏",
-    "EUR": "üá™üá∫",
-    "GBP": "üá¨üáß",
-    "JPY": "üáØüáµ",
-    "CHF": "üá®üá≠",
-    "AUD": "üá¶üá∫",
-    "NZD": "üá≥üáø",
-    "CAD": "üá®üá¶"
-}
-
-# Map of instruments to their corresponding currencies
-INSTRUMENT_CURRENCY_MAP = {
-    # Special case for global view
-    "GLOBAL": MAJOR_CURRENCIES,
-    
-    # Forex
-    "EURUSD": ["EUR", "USD"],
-    "GBPUSD": ["GBP", "USD"],
-    "USDJPY": ["USD", "JPY"],
-    "USDCHF": ["USD", "CHF"],
-    "AUDUSD": ["AUD", "USD"],
-    "NZDUSD": ["NZD", "USD"],
-    "USDCAD": ["USD", "CAD"],
-    "EURGBP": ["EUR", "GBP"],
-    "EURJPY": ["EUR", "JPY"],
-    "GBPJPY": ["GBP", "JPY"],
-    
-    # Indices (mapped to their related currencies)
-    "US30": ["USD"],
-    "US100": ["USD"],
-    "US500": ["USD"],
-    "UK100": ["GBP"],
-    "GER40": ["EUR"],
-    "FRA40": ["EUR"],
-    "ESP35": ["EUR"],
-    "JP225": ["JPY"],
-    "AUS200": ["AUD"],
-    
-    # Commodities (mapped to USD primarily)
-    "XAUUSD": ["USD", "XAU"],  # Gold
-    "XAGUSD": ["USD", "XAG"],  # Silver
-    "USOIL": ["USD"],          # Oil (WTI)
-    "UKOIL": ["USD", "GBP"],   # Oil (Brent)
-    
-    # Crypto
-    "BTCUSD": ["USD", "BTC"],
-    "ETHUSD": ["USD", "ETH"],
-    "LTCUSD": ["USD", "LTC"],
-    "XRPUSD": ["USD", "XRP"]
-}
-
-# Callback data constants
-CALLBACK_ANALYSIS_TECHNICAL = "analysis_technical"
-CALLBACK_ANALYSIS_SENTIMENT = "analysis_sentiment"
-CALLBACK_ANALYSIS_CALENDAR = "analysis_calendar"
-CALLBACK_BACK_MENU = "back_menu"
-CALLBACK_BACK_ANALYSIS = "back_to_analysis"
-CALLBACK_BACK_MARKET = "back_market"
-CALLBACK_BACK_INSTRUMENT = "back_instrument"
-CALLBACK_BACK_SIGNALS = "back_signals"
-CALLBACK_SIGNALS_ADD = "signals_add"
-CALLBACK_SIGNALS_MANAGE = "signals_manage"
-CALLBACK_MENU_ANALYSE = "menu_analyse"
-CALLBACK_MENU_SIGNALS = "menu_signals"
-
-# States
-MENU = 0
-CHOOSE_ANALYSIS = 1
-CHOOSE_SIGNALS = 2
-CHOOSE_MARKET = 3
-CHOOSE_INSTRUMENT = 4
-CHOOSE_STYLE = 5
-SHOW_RESULT = 6
-CHOOSE_TIMEFRAME = 7
-SIGNAL_DETAILS = 8
-SIGNAL = 9
-SUBSCRIBE = 10
-BACK_TO_MENU = 11  # Add this line
-
-# Messages
-WELCOME_MESSAGE = r"""
-<b>Sigmapips AI - Main Menu</b>
-
-Choose an option to access advanced trading support:
-
-Services:
-- <b>Technical Analysis</b> - Real-time chart analysis and key levels
-
-- <b>Market Sentiment</b> - Understand market trends and sentiment
-
-- <b>Economic Calendar</b> - Stay updated on market-moving events
-
-- <b>Trading Signals</b> - Get precise entry/exit points for your favorite pairs
-
-Select your option to continue:
-"""
-
-# Abonnementsbericht voor nieuwe gebruikers
-SUBSCRIPTION_WELCOME_MESSAGE = r"""
-<b>Welcome to Sigmapips AI!</b>
-
-To access all features, you need a subscription:
-
-<b>Trading Signals Subscription - $29.99/month</b>
-- Access to all trading signals (Forex, Crypto, Commodities, Indices)
-- Advanced timeframe analysis
-- Detailed chart analysis for each signal
-
-Click the button below to subscribe:
-"""
-
-MENU_MESSAGE = r"""
-Welcome to Sigmapips AI!
-
-Choose a command:
-
-/start - Set up new trading pairs
-Add new market/instrument/timeframe combinations to receive signals
-
-/manage - Manage your preferences
-View, edit or delete your saved trading pairs
-
-Need help? Use /help to see all available commands.
-"""
-
-HELP_MESSAGE = r"""
-Available commands:
-/menu - Show main menu
-/start - Set up new trading pairs
-/help - Show this help message
-"""
-
-# Start menu keyboard
-START_KEYBOARD = [
-    [InlineKeyboardButton("Analyze Market", callback_data=CALLBACK_MENU_ANALYSE)],
-    [InlineKeyboardButton("Trading Signals", callback_data=CALLBACK_MENU_SIGNALS)]
-]
-
-# Analysis menu keyboard
-ANALYSIS_KEYBOARD = [
-    [InlineKeyboardButton("Technical Analysis", callback_data=CALLBACK_ANALYSIS_TECHNICAL)],
-    [InlineKeyboardButton("Market Sentiment", callback_data=CALLBACK_ANALYSIS_SENTIMENT)],
-    [InlineKeyboardButton("Economic Calendar", callback_data=CALLBACK_ANALYSIS_CALENDAR)],
-    [InlineKeyboardButton("Back", callback_data=CALLBACK_BACK_MENU)]
-]
-
-# Signals menu keyboard
-SIGNALS_KEYBOARD = [
-    [InlineKeyboardButton("Add New Pairs", callback_data=CALLBACK_SIGNALS_ADD)],
-    [InlineKeyboardButton("Manage Signals", callback_data=CALLBACK_SIGNALS_MANAGE)],
-    [InlineKeyboardButton("Back", callback_data=CALLBACK_BACK_MENU)]
-]
-
-# Market keyboard voor signals
-MARKET_KEYBOARD_SIGNALS = [
-    [InlineKeyboardButton("Forex", callback_data="market_forex_signals")],
-    [InlineKeyboardButton("Crypto", callback_data="market_crypto_signals")],
-    [InlineKeyboardButton("Commodities", callback_data="market_commodities_signals")],
-    [InlineKeyboardButton("Indices", callback_data="market_indices_signals")],
-    [InlineKeyboardButton("Back", callback_data="back_signals")]
-]
-
-# Market keyboard voor analyse
-MARKET_KEYBOARD = [
-    [InlineKeyboardButton("Forex", callback_data="market_forex")],
-    [InlineKeyboardButton("Crypto", callback_data="market_crypto")],
-    [InlineKeyboardButton("Commodities", callback_data="market_commodities")],
-    [InlineKeyboardButton("Indices", callback_data="market_indices")],
-    [InlineKeyboardButton("Back", callback_data="back_analysis")]
-]
-
-# Market keyboard specifiek voor sentiment analyse
-MARKET_SENTIMENT_KEYBOARD = [
-    [InlineKeyboardButton("Forex", callback_data="market_forex_sentiment")],
-    [InlineKeyboardButton("Crypto", callback_data="market_crypto_sentiment")],
-    [InlineKeyboardButton("Commodities", callback_data="market_commodities_sentiment")],
-    [InlineKeyboardButton("Indices", callback_data="market_indices_sentiment")],
-    [InlineKeyboardButton("Back", callback_data="back_analysis")]
-]
-
-# Forex keyboard voor technical analyse
-FOREX_KEYBOARD = [
-    [
-        InlineKeyboardButton("EURUSD", callback_data="instrument_EURUSD_chart"),
-        InlineKeyboardButton("GBPUSD", callback_data="instrument_GBPUSD_chart"),
-        InlineKeyboardButton("USDJPY", callback_data="instrument_USDJPY_chart")
-    ],
-    [
-        InlineKeyboardButton("AUDUSD", callback_data="instrument_AUDUSD_chart"),
-        InlineKeyboardButton("USDCAD", callback_data="instrument_USDCAD_chart"),
-        InlineKeyboardButton("EURGBP", callback_data="instrument_EURGBP_chart")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Forex keyboard voor sentiment analyse
-FOREX_SENTIMENT_KEYBOARD = [
-    [
-        InlineKeyboardButton("EURUSD", callback_data="instrument_EURUSD_sentiment"),
-        InlineKeyboardButton("GBPUSD", callback_data="instrument_GBPUSD_sentiment"),
-        InlineKeyboardButton("USDJPY", callback_data="instrument_USDJPY_sentiment")
-    ],
-    [
-        InlineKeyboardButton("AUDUSD", callback_data="instrument_AUDUSD_sentiment"),
-        InlineKeyboardButton("USDCAD", callback_data="instrument_USDCAD_sentiment"),
-        InlineKeyboardButton("EURGBP", callback_data="instrument_EURGBP_sentiment")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Forex keyboard voor kalender analyse
-FOREX_CALENDAR_KEYBOARD = [
-    [
-        InlineKeyboardButton("EURUSD", callback_data="instrument_EURUSD_calendar"),
-        InlineKeyboardButton("GBPUSD", callback_data="instrument_GBPUSD_calendar"),
-        InlineKeyboardButton("USDJPY", callback_data="instrument_USDJPY_calendar")
-    ],
-    [
-        InlineKeyboardButton("AUDUSD", callback_data="instrument_AUDUSD_calendar"),
-        InlineKeyboardButton("USDCAD", callback_data="instrument_USDCAD_calendar"),
-        InlineKeyboardButton("EURGBP", callback_data="instrument_EURGBP_calendar")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Crypto keyboard voor analyse
-CRYPTO_KEYBOARD = [
-    [
-        InlineKeyboardButton("BTCUSD", callback_data="instrument_BTCUSD_chart"),
-        InlineKeyboardButton("ETHUSD", callback_data="instrument_ETHUSD_chart"),
-        InlineKeyboardButton("XRPUSD", callback_data="instrument_XRPUSD_chart")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Signal analysis keyboard
-SIGNAL_ANALYSIS_KEYBOARD = [
-    [InlineKeyboardButton("Technical Analysis", callback_data="signal_technical")],
-    [InlineKeyboardButton("Market Sentiment", callback_data="signal_sentiment")],
-    [InlineKeyboardButton("Economic Calendar", callback_data="signal_calendar")],
-    [InlineKeyboardButton("Back", callback_data="back_to_signal")]
-]
-
-# Crypto keyboard voor sentiment analyse
-CRYPTO_SENTIMENT_KEYBOARD = [
-    [
-        InlineKeyboardButton("BTCUSD", callback_data="instrument_BTCUSD_sentiment"),
-        InlineKeyboardButton("ETHUSD", callback_data="instrument_ETHUSD_sentiment"),
-        InlineKeyboardButton("XRPUSD", callback_data="instrument_XRPUSD_sentiment")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Indices keyboard voor analyse
-INDICES_KEYBOARD = [
-    [
-        InlineKeyboardButton("US30", callback_data="instrument_US30_chart"),
-        InlineKeyboardButton("US500", callback_data="instrument_US500_chart"),
-        InlineKeyboardButton("US100", callback_data="instrument_US100_chart")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Indices keyboard voor signals - Fix de "Terug" knop naar "Back"
-INDICES_KEYBOARD_SIGNALS = [
-    [
-        InlineKeyboardButton("US30", callback_data="instrument_US30_signals"),
-        InlineKeyboardButton("US500", callback_data="instrument_US500_signals"),
-        InlineKeyboardButton("US100", callback_data="instrument_US100_signals")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Commodities keyboard voor analyse
-COMMODITIES_KEYBOARD = [
-    [
-        InlineKeyboardButton("GOLD", callback_data="instrument_XAUUSD_chart"),
-        InlineKeyboardButton("SILVER", callback_data="instrument_XAGUSD_chart"),
-        InlineKeyboardButton("OIL", callback_data="instrument_USOIL_chart")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Commodities keyboard voor signals - Fix de "Terug" knop naar "Back"
-COMMODITIES_KEYBOARD_SIGNALS = [
-    [
-        InlineKeyboardButton("XAUUSD", callback_data="instrument_XAUUSD_signals"),
-        InlineKeyboardButton("XAGUSD", callback_data="instrument_XAGUSD_signals"),
-        InlineKeyboardButton("USOIL", callback_data="instrument_USOIL_signals")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Forex keyboard for signals
-FOREX_KEYBOARD_SIGNALS = [
-    [
-        InlineKeyboardButton("EURUSD", callback_data="instrument_EURUSD_signals"),
-        InlineKeyboardButton("GBPUSD", callback_data="instrument_GBPUSD_signals"),
-        InlineKeyboardButton("USDJPY", callback_data="instrument_USDJPY_signals")
-    ],
-    [
-        InlineKeyboardButton("USDCAD", callback_data="instrument_USDCAD_signals"),
-        InlineKeyboardButton("EURGBP", callback_data="instrument_EURGBP_signals")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Crypto keyboard for signals
-CRYPTO_KEYBOARD_SIGNALS = [
-    [
-        InlineKeyboardButton("BTCUSD", callback_data="instrument_BTCUSD_signals"),
-        InlineKeyboardButton("ETHUSD", callback_data="instrument_ETHUSD_signals"),
-        InlineKeyboardButton("XRPUSD", callback_data="instrument_XRPUSD_signals")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Indices keyboard voor sentiment analyse
-INDICES_SENTIMENT_KEYBOARD = [
-    [
-        InlineKeyboardButton("US30", callback_data="instrument_US30_sentiment"),
-        InlineKeyboardButton("US500", callback_data="instrument_US500_sentiment"),
-        InlineKeyboardButton("US100", callback_data="instrument_US100_sentiment")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Commodities keyboard voor sentiment analyse
-COMMODITIES_SENTIMENT_KEYBOARD = [
-    [
-        InlineKeyboardButton("GOLD", callback_data="instrument_XAUUSD_sentiment"),
-        InlineKeyboardButton("SILVER", callback_data="instrument_XAGUSD_sentiment"),
-        InlineKeyboardButton("OIL", callback_data="instrument_USOIL_sentiment")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Style keyboard
-STYLE_KEYBOARD = [
-    [InlineKeyboardButton("‚ö° Test (one_min)", callback_data="style_test")],
-    [InlineKeyboardButton("üèÉ Scalp (fifteen_min)", callback_data="style_scalp")],
-    [InlineKeyboardButton(" Intraday (one_hour)", callback_data="style_intraday")],
-    [InlineKeyboardButton("üåä Swing (four_hour)", callback_data="style_swing")],
-    [InlineKeyboardButton("Back", callback_data="back_instrument")]
-]
-
-# Timeframe mapping
-STYLE_TIMEFRAME_MAP = {
-    "test": "one_min",
-    "scalp": "fifteen_min",
-    "intraday": "one_hour",
-    "swing": "four_hour"
-}
-
-# Mapping of instruments to their allowed timeframes - updated 2023-03-23
-INSTRUMENT_TIMEFRAME_MAP = {
-    # H1 timeframe only
-    "AUDJPY": "H1", 
-    "AUDCHF": "H1",
-    "EURCAD": "H1",
-    "EURGBP": "H1",
-    "GBPCHF": "H1",
-    "HK50": "H1",
-    "NZDJPY": "H1",
-    "USDCHF": "H1",
-    "USDJPY": "H1",  # USDJPY toegevoegd voor signaalabonnementen
-    "XRPUSD": "H1",
-    
-    # H4 timeframe only
-    "AUDCAD": "H4",
-    "AU200": "H4", 
-    "CADCHF": "H4",
-    "EURCHF": "H4",
-    "EURUSD": "H4",
-    "GBPCAD": "H4",
-    "LINKUSD": "H4",
-    "NZDCHF": "H4",
-    
-    # M15 timeframe only
-    "DOGEUSD": "M15",
-    "GBPNZD": "M15",
-    "NZDUSD": "M15",
-    "SOLUSD": "M15",
-    "UK100": "M15",
-    "XAUUSD": "M15",
-    
-    # M30 timeframe only
-    "BNBUSD": "M30",
-    "DOTUSD": "M30",
-    "ETHUSD": "M30",
-    "EURAUD": "M30",
-    "EURJPY": "M30",
-    "GBPAUD": "M30",
-    "GBPUSD": "M30",
-    "NZDCAD": "M30",
-    "US30": "M30",
-    "US500": "M30",
-    "USDCAD": "M30",
-    "XLMUSD": "M30",
-    "XTIUSD": "M30",
-    "DE40": "M30",
-    "BTCUSD": "M30",  # Added for consistency with CRYPTO_KEYBOARD_SIGNALS
-    "US100": "M30",   # Added for consistency with INDICES_KEYBOARD_SIGNALS
-    "XAGUSD": "M15",  # Added for consistency with COMMODITIES_KEYBOARD_SIGNALS
-    "USOIL": "M30"    # Added for consistency with COMMODITIES_KEYBOARD_SIGNALS
-    
-    # Removed as requested: EU50, FR40, LTCUSD
-}
-
-# Map common timeframe notations
-TIMEFRAME_DISPLAY_MAP = {
-    "M15": "15 Minutes",
-    "M30": "30 Minutes", 
-    "H1": "1 Hour",
-    "H4": "4 Hours"
-}
-
-# Voeg deze functie toe aan het begin van bot.py, na de imports
-def _detect_market(instrument: str) -> str:
-    """Detecteer market type gebaseerd op instrument"""
-    instrument = instrument.upper()
-    
-    # Commodities eerst checken
-    commodities = [
-        "XAUUSD",  # Gold
-        "XAGUSD",  # Silver
-        "WTIUSD",  # Oil WTI
-        "BCOUSD",  # Oil Brent
-        "USOIL",   # Oil WTI (alternative symbol)
-    ]
-    if instrument in commodities:
-        logger.info(f"Detected {instrument} as commodity")
-        return "commodities"
-    
-    # Crypto pairs
-    crypto_base = ["BTC", "ETH", "XRP", "SOL", "BNB", "ADA", "DOT", "LINK"]
-    if any(c in instrument for c in crypto_base):
-        logger.info(f"Detected {instrument} as crypto")
-        return "crypto"
-    
-    # Major indices
-    indices = [
-        "US30", "US500", "US100",  # US indices
-        "UK100", "DE40", "FR40",   # European indices
-        "JP225", "AU200", "HK50"   # Asian indices
-    ]
-    if instrument in indices:
-        logger.info(f"Detected {instrument} as index")
-        return "indices"
-    
-    # Forex pairs als default
-    logger.info(f"Detected {instrument} as forex")
-    return "forex"
-
-# Voeg dit toe als decorator functie bovenaan het bestand na de imports
-def require_subscription(func):
-    """Check if user has an active subscription"""
-    async def wrapper(self, update: Update, context: ContextTypes.DEFAULT_TYPE, *args, **kwargs):
-        user_id = update.effective_user.id
-        
-        # Check subscription status
-        is_subscribed = await self.db.is_user_subscribed(user_id)
-        
-        # Check if payment has failed
-        payment_failed = await self.db.has_payment_failed(user_id)
-        
-        if is_subscribed and not payment_failed:
-            # User has subscription, proceed with function
-            return await func(self, update, context, *args, **kwargs)
-        else:
-            if payment_failed:
-                # Show payment failure message
-                failed_payment_text = f"""
- <b>Subscription Payment Failed</b> 
-
-Your subscription payment could not be processed and your service has been deactivated.
-
-To continue using Sigmapips AI and receive trading signals, please reactivate your subscription by clicking the button below.
-                """
-                
-                # Use direct URL link for reactivation
-                reactivation_url = "https://buy.stripe.com/9AQcPf3j63HL5JS145"
-                
-                # Create button for reactivation
-                keyboard = [
-                    [InlineKeyboardButton("üîÑ Reactivate Subscription", url=reactivation_url)]
-                ]
-            else:
-                # Show subscription screen with the welcome message from the screenshot
-                failed_payment_text = f"""
- <b>Welcome to Sigmapips AI!</b> 
-
-<b>Discover powerful trading signals for various markets:</b>
-- <b>Forex</b> - Major and minor currency pairs
-- <b>Crypto</b> - Bitcoin, Ethereum and other top cryptocurrencies
-- <b>Indices</b> - Global market indices
-- <b>Commodities</b> - Gold, silver and oil
-
-<b>Features:</b>
- Real-time trading signals
-
- Multi-timeframe analysis (timeframes)
-
- Advanced chart analysis
-
- Sentiment indicators
-
- Economic calendar integration
-
-<b>Start today with a FREE 14-day trial!</b>
-                """
-                
-                # Use direct URL link instead of callback for the trial button
-                reactivation_url = "https://buy.stripe.com/3cs3eF9Hu9256NW9AA"
-                
-                # Create button for trial
-                keyboard = [
-                    [InlineKeyboardButton("üî• Start 14-day FREE Trial", url=reactivation_url)]
-                ]
-            
-            # Handle both message and callback query updates
-            if update.callback_query:
-                await update.callback_query.answer()
-                await update.callback_query.edit_message_text(
-                    text=failed_payment_text,
-                    reply_markup=InlineKeyboardMarkup(keyboard),
-                    parse_mode=ParseMode.HTML
-                )
-            else:
-                await update.message.reply_text(
-                    text=failed_payment_text,
-                    reply_markup=InlineKeyboardMarkup(keyboard),
-                    parse_mode=ParseMode.HTML
-                )
-            return MENU
-    
-    return wrapper
-
-# API keys with robust sanitization
-PERPLEXITY_API_KEY = os.getenv("PERPLEXITY_API_KEY", "").strip()
-OPENAI_API_KEY = os.getenv("OPENAI_API_KEY", "").strip()  # Changed from DeepSeek to OpenAI
-
-# Only using OpenAI's o4-mini now
-# No Tavily API key needed anymore
-logger.info("Using only OpenAI o4-mini for Market Sentiment service")
-
-# Log OpenAI API key (partially masked)
-if OPENAI_API_KEY:
-    # Better masking for privacy and security
-    masked_key = f"sk-p...{OPENAI_API_KEY[-4:]}" if len(OPENAI_API_KEY) > 8 else "sk-p..."
-    logger.info(f"Using OpenAI API key: {masked_key}")
-    
-    # Validate the key format
-    from trading_bot.config import validate_openai_key
-    if not validate_openai_key(OPENAI_API_KEY):
-        logger.warning("OpenAI API key format is invalid. AI services may not work correctly.")
-else:
-    logger.warning("No OpenAI API key configured. AI services will be disabled.")
-    
-# Set environment variables for the API keys with sanitization
-os.environ["PERPLEXITY_API_KEY"] = PERPLEXITY_API_KEY
-os.environ["OPENAI_API_KEY"] = OPENAI_API_KEY  # Changed from DeepSeek to OpenAI
-# No Tavily environment needed
-
-class TelegramService:
-    def __init__(self, db: Database, stripe_service=None, bot_token: Optional[str] = None, proxy_url: Optional[str] = None, lazy_init: bool = False):
-        """Initialize the bot with given database and config."""
-        # Database connection
-        self.db = db
-        
-        # Setup configuration 
-        self.stripe_service = stripe_service
-        self.user_signals = {}
-        self.signals_dir = "data/signals"
-        self.signals_enabled_val = True
-        self.polling_started = False
-        self.admin_users = [2004519703]  # Updated with correct Telegram ID from logs
-        self._signals_enabled = True  # Enable signals by default
-        
-        # Setup logger
-        self.logger = logging.getLogger(__name__)
-        
-        # GIF utilities for UI
-        self.gif_utils = gif_utils  # Initialize gif_utils as an attribute
-        
-        # Setup the bot and application
-        self.bot = None
-        self.application = None
-        
-        # Telegram Bot configuratie
-        self.bot_token = bot_token or os.getenv("TELEGRAM_BOT_TOKEN", "")
-        self.token = self.bot_token  # Aliased for backward compatibility
-        self.proxy_url = proxy_url or os.getenv("TELEGRAM_PROXY_URL", "")
-        
-        # Configure custom request handler with improved connection settings
-        request = HTTPXRequest(
-            connection_pool_size=50,  # Increase from 20 to 50
-            connect_timeout=15.0,     # Increase from 10.0 to 15.0
-            read_timeout=45.0,        # Increase from 30.0 to 45.0
-            write_timeout=30.0,       # Increase from 20.0 to 30.0
-            pool_timeout=60.0,        # Increase from 30.0 to 60.0
-        )
-        
-        # Initialize the bot directly with connection pool settings
-        self.bot = Bot(token=self.bot_token, request=request)
-        self.application = None  # Will be initialized in setup()
-        
-        # Webhook configuration
-        self.webhook_url = os.getenv("WEBHOOK_URL", "")
-        self.webhook_path = "/webhook"  # Always use this path
-        if self.webhook_url.endswith("/"):
-            self.webhook_url = self.webhook_url[:-1]  # Remove trailing slash
-            
-        logger.info(f"Bot initialized with webhook URL: {self.webhook_url} and path: {self.webhook_path}")
-        
-        # Initialize API services
-        self.chart_service = ChartService()  # Initialize chart service
-        # Lazy load services only when needed
-        self._calendar_service = None
-        self._sentiment_service = None
-        
-        # Don't use asyncio.create_task here - it requires a running event loop
-        # We'll initialize chart service later when the event loop is running
-        
-        # Bot application initialization
-        self.persistence = None
-        self.bot_started = False
-        
-        # Cache for sentiment analysis
-        self.sentiment_cache = {}
-        self.sentiment_cache_ttl = 60 * 60  # 1 hour in seconds
-        
-        # Start the bot
-    try:
-            # Check for bot token
-            if not self.bot_token:
-                raise ValueError("Missing Telegram bot token")
-            
-            # Initialize the bot
-            self.bot = Bot(token=self.bot_token)
-        
-            # Initialize the application
-            self.application = Application.builder().bot(self.bot).build()
-        
-            # Register the handlers
-            self._register_handlers(self.application)
-            
-            # Initialize signals dictionary but don't load them yet (will be done in initialize_services)
-            self.user_signals = {}
-        
-            logger.info("Telegram service initialized")
-            
-            # Keep track of processed updates
-            self.processed_updates = set()
-            
-    except Exception as e:
-        logger.error(f"Error initializing Telegram service: {str(e)}")
-        raise
-
-    async def initialize_services(self):
-        """Initialize services that require an asyncio event loop"""
-        try:
-            # Initialize chart service
-            await self.chart_service.initialize()
-            logger.info("Chart service initialized")
-            
-            # Load stored signals
-            await self._load_signals()
-            logger.info("Signals loaded")
-            
-            # Schedule periodic cleanup of old signals
-            if hasattr(self, 'db') and self.db and self.db.using_redis:
-                # Run initial cleanup
-                cleaned = await self._cleanup_old_signals(max_age_days=7)
-                logger.info(f"Initial signal cleanup completed, removed {cleaned} old signals")
-                
-                # Schedule periodic cleanup (every 24 hours)
-                async def periodic_cleanup():
-                    while True:
-                        try:
-                            # Wait for 24 hours
-                            await asyncio.sleep(24 * 60 * 60)
-                            # Run cleanup
-                            cleaned = await self._cleanup_old_signals(max_age_days=7)
-                            logger.info(f"Periodic signal cleanup completed, removed {cleaned} old signals")
-                        except Exception as e:
-                            logger.error(f"Error in periodic signal cleanup: {str(e)}")
-                
-                # Start the periodic cleanup task
-                asyncio.create_task(periodic_cleanup())
-                logger.info("Scheduled periodic signal cleanup")
-        except Exception as e:
-            logger.error(f"Error initializing services: {str(e)}")
-            raise
-            
-    # Calendar service helpers
-    @property
-    def calendar_service(self):
-        """Lazy loaded calendar service"""
-        if self._calendar_service is None:
-            # Only initialize the calendar service when it's first accessed
-            self.logger.info("Lazy loading calendar service")
-            self._calendar_service = EconomicCalendarService()
-        return self._calendar_service
-        
-    def _get_calendar_service(self):
-        """Get the calendar service instance"""
-        self.logger.info("Getting calendar service")
-        return self.calendar_service
-
-    async def _format_calendar_events(self, calendar_data):
-        """Format the calendar data into a readable HTML message"""
-        self.logger.info(f"Formatting calendar data with {len(calendar_data)} events")
-        if not calendar_data:
-            return "<b>Economic Calendar</b>\n\nNo economic events found for today."
-        
-        # Sort events by time
-        try:
-            # Try to parse time for sorting
-            def parse_time_for_sorting(event):
-                time_str = event.get('time', '')
-                try:
-                    # Extract hour and minute if in format like "08:30 EST"
-                    if ':' in time_str:
-                        parts = time_str.split(' ')[0].split(':')
-                        hour = int(parts[0])
-                        minute = int(parts[1])
-                        return hour * 60 + minute
-                    return 0
-                except:
-                    return 0
-            
-            # Sort the events by time
-            sorted_events = sorted(calendar_data, key=parse_time_for_sorting)
-        except Exception as e:
-            self.logger.error(f"Error sorting calendar events: {str(e)}")
-            sorted_events = calendar_data
-        
-        # Format the message
-        message = "<b>Economic Calendar</b>\n\n"
-        
-        # Get current date
-        current_date = datetime.now().strftime("%B %d, %Y")
-        message += f"<b>Date:</b> {current_date}\n\n"
-        
-        # Add impact legend
-        message += "<b>Impact:</b> üî¥ High   üü† Medium   üü¢ Low\n\n"
-        
-        # Group events by country
-        events_by_country = {}
-        for event in sorted_events:
-            country = event.get('country', 'Unknown')
-            if country not in events_by_country:
-                events_by_country[country] = []
-            events_by_country[country].append(event)
-        
-        # Format events by country
-        for country, events in events_by_country.items():
-            country_flag = CURRENCY_FLAG.get(country, '')
-            message += f"<b>{country_flag} {country}</b>\n"
-            
-            for event in events:
-                time = event.get('time', 'TBA')
-                title = event.get('title', 'Unknown Event')
-                impact = event.get('impact', 'Low')
-                impact_emoji = {'High': 'üî¥', 'Medium': 'üü†', 'Low': 'üü¢'}.get(impact, 'üü¢')
-                
-                message += f"{time} - {impact_emoji} {title}\n"
-            
-            message += "\n"  # Add extra newline between countries
-        
-        return message
-        
-    # Utility functions that might be missing
-    async def update_message(self, query, text, keyboard=None, parse_mode=ParseMode.HTML):
-        """Utility to update a message with error handling"""
-        try:
-            # Check if the message is too long for Telegram caption limits (1024 chars)
-            MAX_CAPTION_LENGTH = 1000  # Slightly under the 1024 limit for safety
-            MAX_MESSAGE_LENGTH = 4000  # Telegram message limit
-            
-            # Log message length for debugging
-            logger.info(f"Updating message (length: {len(text)} chars)")
-            
-            # If message is too long for a caption but ok for a text message
-            if len(text) > MAX_CAPTION_LENGTH and len(text) <= MAX_MESSAGE_LENGTH:
-                logger.info("Message too long for caption but ok for text message")
-                # Try to edit message text first
-                await query.edit_message_text(
-                    text=text,
-                    reply_markup=keyboard,
-                    parse_mode=parse_mode
-                )
-                return True
-            # If message is too long even for a text message
-            elif len(text) > MAX_MESSAGE_LENGTH:
-                logger.warning(f"Message too long ({len(text)} chars), truncating")
-                # Find a good breaking point
-                truncated = text[:MAX_MESSAGE_LENGTH-100]
-                
-                # Try to break at a paragraph
-                last_newline = truncated.rfind('\n\n')
-                if last_newline > MAX_MESSAGE_LENGTH * 0.8:  # If we can keep at least 80% of the text
-                    truncated = truncated[:last_newline]
-                    
-                # Add indicator that text was truncated
-                truncated += "\n\n<i>... (message truncated)</i>"
-                
-                # Try to edit message text with truncated content
-                await query.edit_message_text(
-                    text=truncated,
-                    reply_markup=keyboard,
-                    parse_mode=parse_mode
-                )
-                return True
-            else:
-                # Normal case - message is within limits
-                # Try to edit message text first
-                await query.edit_message_text(
-                    text=text,
-                    reply_markup=keyboard,
-                    parse_mode=parse_mode
-                )
-                return True
-        except Exception as e:
-            logger.warning(f"Could not update message text: {str(e)}")
-            
-            # If text update fails, try to edit caption
-            try:
-                # Check if caption is too long
-                MAX_CAPTION_LENGTH = 1000  # Slightly under the 1024 limit for safety
-                
-                if len(text) > MAX_CAPTION_LENGTH:
-                    logger.warning(f"Caption too long ({len(text)} chars), truncating")
-                    # Find a good breaking point
-                    truncated = text[:MAX_CAPTION_LENGTH-100]
-                    
-                    # Try to break at a paragraph
-                    last_newline = truncated.rfind('\n\n')
-                    if last_newline > MAX_CAPTION_LENGTH * 0.8:  # If we can keep at least 80% of the text
-                        truncated = truncated[:last_newline]
-                        
-                    # Add indicator that text was truncated
-                    truncated += "\n\n<i>... (message truncated)</i>"
-                    
-                    # Use truncated text for caption
-                    await query.edit_message_caption(
-                        caption=truncated,
-                        reply_markup=keyboard,
-                        parse_mode=parse_mode
-                    )
-                else:
-                    # Caption is within limits
-                    await query.edit_message_caption(
-                        caption=text,
-                        reply_markup=keyboard,
-                        parse_mode=parse_mode
-                    )
-                return True
-            except Exception as e2:
-                logger.error(f"Could not update caption either: {str(e2)}")
-                
-                # As a last resort, send a new message
-                try:
-                    chat_id = query.message.chat_id
-                    
-                    # Check if message is too long
-                    MAX_MESSAGE_LENGTH = 4000  # Telegram message limit
-                    
-                    if len(text) > MAX_MESSAGE_LENGTH:
-                        logger.warning(f"New message too long ({len(text)} chars), truncating")
-                        # Find a good breaking point
-                        truncated = text[:MAX_MESSAGE_LENGTH-100]
-                        
-                        # Try to break at a paragraph
-                        last_newline = truncated.rfind('\n\n')
-                        if last_newline > MAX_MESSAGE_LENGTH * 0.8:  # If we can keep at least 80% of the text
-                            truncated = truncated[:last_newline]
-                            
-                        # Add indicator that text was truncated
-                        truncated += "\n\n<i>... (message truncated)</i>"
-                        
-                        # Use truncated text for new message
-                        await query.bot.send_message(
-                            chat_id=chat_id,
-                            text=truncated,
-                            reply_markup=keyboard,
-                            parse_mode=parse_mode
-                        )
-                    else:
-                        # Message is within limits
-                        await query.bot.send_message(
-                            chat_id=chat_id,
-                            text=text,
-                            reply_markup=keyboard,
-                            parse_mode=parse_mode
-                        )
-                    return True
-                except Exception as e3:
-                    logger.error(f"Failed to send new message: {str(e3)}")
-                    return False
-    
-    # Missing handler implementations
-    async def back_signals_callback(self, update: Update, context=None) -> int:
-        """Handle back_signals button press"""
-        query = update.callback_query
-        await query.answer()
-        
-        logger.info("back_signals_callback called")
-        
-        # Make sure we're in the signals flow context
-        if context and hasattr(context, 'user_data'):
-            # Reset signal flow flags
-            context.user_data['from_signal'] = False
-            context.user_data['in_signal_flow'] = False
-            logger.info(f"Reset signal flow flags: from_signal=False, in_signal_flow=False")
-            # Keep is_signals_context flag but reset from_signal flag
-            context.user_data['is_signals_context'] = True
-            context.user_data['from_signal'] = False
-            
-            # Clear other specific analysis keys but maintain signals context
-            keys_to_remove = [
-                'instrument', 'market', 'analysis_type', 'timeframe', 
-                'signal_id', 'signal_instrument', 'signal_direction', 'signal_timeframe',
-                'loading_message'
-            ]
-
-            for key in keys_to_remove:
-                if key in context.user_data:
-                    del context.user_data[key]
-            logger.info(f"Updated context in back_signals_callback: {context.user_data}")
-        
-        # Create keyboard for signal menu
-        keyboard = [
-            [InlineKeyboardButton(" Add Signal", callback_data="signals_add")],
-            [InlineKeyboardButton("Manage Signals", callback_data="signals_manage")],
-            [InlineKeyboardButton("Back to Menu", callback_data="back_menu")]
-        ]
-        reply_markup = InlineKeyboardMarkup(keyboard)
-        
-        # Get the signals GIF URL for better UX
-        signals_gif_url = "https://media.giphy.com/media/gSzIKNrqtotEYrZv7i/giphy.gif"
-        
-        # Update the message
-        await self.update_message(
-            query=query,\n            text="<b> Signal Management</b>\n\nManage your trading signals",
-            keyboard=reply_markup
-        )
-        
-        return SIGNALS
-        
-    async def get_subscribers_for_instrument(self, instrument: str, timeframe: str = None) -> List[int]:
-        """
-        Get a list of subscribed user IDs for a specific instrument and timeframe
-        
-        Args:
-            instrument: The trading instrument (e.g., EURUSD)
-            timeframe: Optional timeframe filter
-            
-        Returns:
-            List of subscribed user IDs
-        """
-    try:
-            logger.info(f"Getting subscribers for {instrument} timeframe: {timeframe}")
-            
-            # Get all subscribers from the database
-            # Note: Using get_signal_subscriptions instead of find_all
-            subscribers = await self.db.get_signal_subscriptions(instrument, timeframe)
-            
-            if not subscribers:
-                logger.warning(f"No subscribers found for {instrument}")
-                return []
-                
-            # Filter out subscribers that don't have an active subscription
-            active_subscribers = []
-            for subscriber in subscribers:
-                user_id = subscriber['user_id']
-                
-                # Check if user is subscribed
-                is_subscribed = await self.db.is_user_subscribed(user_id)
-                
-                # Check if payment has failed
-                payment_failed = await self.db.has_payment_failed(user_id)
-                
-                if is_subscribed and not payment_failed:
-                    active_subscribers.append(user_id)
-                else:
-                    logger.info(f"User {user_id} doesn't have an active subscription, skipping signal")
-            
-            return active_subscribers
-            
-    except Exception as e:
-        logger.error(f"Error getting subscribers: {str(e)}")
-            # FOR TESTING: Add admin users if available
-            if hasattr(self, 'admin_users') and self.admin_users:
-                logger.info(f"Returning admin users for testing: {self.admin_users}")
-                return self.admin_users
-            return []
-
-    async def process_signal(self, signal_data: Dict[str, Any]) -> bool:
-        """
-        Process a trading signal from TradingView webhook or API
-        
-        Supports two formats:
-        1. TradingView format: instrument, signal, price, sl, tp1, tp2, tp3, interval
-        2. Custom format: instrument, direction, entry, stop_loss, take_profit, timeframe
-        
-        Returns:
-            bool: True if signal was processed successfully, False otherwise
-        """
-        try:
-            # Log the incoming signal data
-            logger.info(f"Processing signal: {signal_data}")
-            
-            # Check which format we're dealing with and normalize it
-            instrument = signal_data.get('instrument')
-            
-            # Handle TradingView format (price, sl, interval)
-            if 'price' in signal_data and 'sl' in signal_data:
-                price = signal_data.get('price')
-                sl = signal_data.get('sl')
-                tp1 = signal_data.get('tp1')
-                tp2 = signal_data.get('tp2')
-                tp3 = signal_data.get('tp3')
-                interval = signal_data.get('interval', 'one_hour')
-                
-                # Determine signal direction based on price and SL relationship
-                direction = "BUY" if float(sl) < float(price) else "SELL"
-                
-                # Create normalized signal data
-                normalized_data = {
-                    'instrument': instrument,
-                    'direction': direction,
-                    'entry': price,
-                    'stop_loss': sl,
-                    'take_profit': tp1,  # Use first take profit level
-                    'timeframe': interval
-                }
-                
-                # Add optional fields if present
-                normalized_data['tp1'] = tp1
-                normalized_data['tp2'] = tp2
-                normalized_data['tp3'] = tp3
-                
-            # Handle custom format (direction, entry, stop_loss, timeframe)
-            elif 'direction' in signal_data and 'entry' in signal_data:
-                direction = signal_data.get('direction')
-                entry = signal_data.get('entry')
-                stop_loss = signal_data.get('stop_loss')
-                take_profit = signal_data.get('take_profit')
-                timeframe = signal_data.get('timeframe', 'one_hour')
-                
-                # Create normalized signal data
-                normalized_data = {
-                    'instrument': instrument,
-                    'direction': direction,
-                    'entry': entry,
-                    'stop_loss': stop_loss,
-                    'take_profit': take_profit,
-                    'timeframe': timeframe
-                }
-            else:
-                logger.error(f"Missing required signal data")
-                return False
-            
-            # Basic validation
-            if not normalized_data.get('instrument') or not normalized_data.get('direction') or not normalized_data.get('entry'):
-                logger.error(f"Missing required fields in normalized signal data: {normalized_data}")
-                return False
-                
-            # Create signal ID for tracking
-            signal_id = f"{normalized_data['instrument']}_{normalized_data['direction']}_{normalized_data['timeframe']}_{int(time.time())}"
-            
-            # Format the signal message
-            message = self._format_signal_message(normalized_data)
-            
-            # Determine market type for the instrument
-            market_type = _detect_market(instrument)
-            
-            # Store the full signal data for reference
-            normalized_data['id'] = signal_id
-            normalized_data['timestamp'] = datetime.now().isoformat()
-            normalized_data['message'] = message
-            normalized_data['market'] = market_type
-            
-            # Save signal for history tracking
-            if not os.path.exists(self.signals_dir):
-                os.makedirs(self.signals_dir, exist_ok=True)
-                
-            # Save to signals directory
-            with open(f"{self.signals_dir}/{signal_id}.json", 'w') as f:
-                json.dump(normalized_data, f)
-            
-            # FOR TESTING: Always send to admin for testing
-            if hasattr(self, 'admin_users') and self.admin_users:
-                try:
-                    logger.info(f"Sending signal to admin users for testing: {self.admin_users}")
-                    for admin_id in self.admin_users:
-                        # Prepare keyboard with analysis options
-                        keyboard = [
-                            [InlineKeyboardButton("Analyze Market", callback_data=f"analyze_from_signal_{instrument}_{signal_id}")]
-                        ]
-                        
-                        # Send the signal
-                        await self.bot.send_message(
-                            chat_id=admin_id,
-                            text=message,
-                            parse_mode=ParseMode.HTML,
-                            reply_markup=InlineKeyboardMarkup(keyboard)
-                        )
-                        logger.info(f"Test signal sent to admin {admin_id}")
-                        
-                        # Store signal reference for quick access
-                        if not hasattr(self, 'user_signals'):
-                            self.user_signals = {}
-                            
-                        admin_str_id = str(admin_id)
-                        if admin_str_id not in self.user_signals:
-                            self.user_signals[admin_str_id] = {}
-                        
-                        self.user_signals[admin_str_id][signal_id] = normalized_data
-            except Exception as e:
-                logger.error(f"Error sending test signal to admin: {str(e)}")
-            
-            # Get subscribers for this instrument
-            timeframe = normalized_data.get('timeframe', 'one_hour')
-            subscribers = await self.get_subscribers_for_instrument(instrument, timeframe)
-            
-            if not subscribers:
-                logger.warning(f"No subscribers found for {instrument}")
-                return True  # Successfully processed, just no subscribers
-            
-            # Send signal to all subscribers
-            logger.info(f"Sending signal {signal_id} to {len(subscribers)} subscribers")
-            
-            sent_count = 0
-            for user_id in subscribers:
-                try:
-                    # Prepare keyboard with analysis options
-                    keyboard = [
-                        [InlineKeyboardButton("Analyze Market", callback_data=f"analyze_from_signal_{instrument}_{signal_id}")]
-                    ]
-                    
-                    # Send the signal
-                    await self.bot.send_message(
-                        chat_id=user_id,
-                        text=message,
-                        parse_mode=ParseMode.HTML,
-                        reply_markup=InlineKeyboardMarkup(keyboard)
-                    )
-                    
-                    sent_count += 1
-                    
-                    # Store signal reference for quick access
-                    if not hasattr(self, 'user_signals'):
-                        self.user_signals = {}
-                        
-                    user_str_id = str(user_id)
-                    if user_str_id not in self.user_signals:
-                        self.user_signals[user_str_id] = {}
-                    
-                    self.user_signals[user_str_id][signal_id] = normalized_data
-                    
-            except Exception as e:
-                logger.error(f"Error sending signal to user {user_id}: {str(e)}")
-            
-            logger.info(f"Successfully sent signal {signal_id} to {sent_count}/{len(subscribers)} subscribers")
-            return True
-            
-    except Exception as e:
-        logger.error(f"Error processing signal: {str(e)}")
-        logger.exception(e)
-            return False
-
-    def _format_signal_message(self, signal_data: Dict[str, Any]) -> str:
-        """Format signal data into a nice message for Telegram"""
-    try:
-            # Extract fields from signal data
-            instrument = signal_data.get('instrument', 'Unknown')
-            direction = signal_data.get('direction', 'Unknown')
-            entry = signal_data.get('entry', 'Unknown')
-            stop_loss = signal_data.get('stop_loss')
-            take_profit = signal_data.get('take_profit')
-            timeframe = signal_data.get('timeframe', 'one_hour')
-            
-            # Get multiple take profit levels if available
-            tp1 = signal_data.get('tp1', take_profit)
-            tp2 = signal_data.get('tp2')
-            tp3 = signal_data.get('tp3')
-            
-            # Add emoji based on direction
-            direction_emoji = "üü¢" if direction.upper() == "BUY" else "üî¥"
-            
-            # Format the message with multiple take profits if available
-            message = "<b> New Trading Signal </b>\n"\n\n"
-            message += f"<b>Instrument:</b> {instrument}\n"
-            message += f"<b>Action:</b> {direction.upper()} {direction_emoji}\n\n"
-            message += f"<b>Entry Price:</b> {entry}\n"
-            
-            if stop_loss:
-                message += f"<b>Stop Loss:</b> {stop_loss} üî¥\n"
-            
-            # Add take profit levels
-            if tp1:
-                message += f"<b>Take Profit 1:</b> {tp1} \n"
-            if tp2:
-                message += f"<b>Take Profit 2:</b> {tp2} \n"
-            if tp3:
-                message += f"<b>Take Profit 3:</b> {tp3} \n"
-            
-            message += f"\n<b>Timeframe:</b> {timeframe}\n"
-            message += f"<b>Strategy:</b> TradingView Signal\n\n"
-            
-            message += "‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî\n\n"
-            message += "<b>Risk Management:</b>\n"
-            message += "- Position size: 1-2% max\n"
-            message += "- Use proper stop loss\n"
-            message += "- Follow your trading plan\n\n"
-            
-            message += "‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî\n\n"
-            
-            # Generate AI verdict
-            ai_verdict = f"The {instrument} {direction.lower()} signal shows a promising setup with defined entry at {entry} and stop loss at {stop_loss}. Multiple take profit levels provide opportunities for partial profit taking."
-            message += f"<b>ü§ñ SigmaPips AI Verdict:</b>\n{ai_verdict}"
-            
-            return message
-            
-    except Exception as e:
-        logger.error(f"Error formatting signal message: {str(e)}")
-            # Return simple message on error
-            return f"New {signal_data.get('instrument', 'Unknown')} {signal_data.get('direction', 'Unknown')} Signal"
-
-    def _register_handlers(self, application):
-        """Register event handlers for bot commands and callback queries"""
-    try:
-            logger.info("Registering command handlers")
-            
-            # Initialize the application without using run_until_complete
-        try:
-                # Instead of using loop.run_until_complete, directly call initialize 
-                # which will be properly awaited by the caller
-                self.init_task = application.initialize()
-                logger.info("Telegram application initialization ready to be awaited")
-            except Exception as init_e:
-            logger.error(f"Error during application initialization: {str(init_e)}")
-            logger.exception(init_e)
-                
-            # Set bot commands for menu
-            commands = [
-                BotCommand("start", "Start the bot and get the welcome message"),
-                BotCommand("menu", "Show the main menu"),
-                BotCommand("help", "Show available commands and how to use the bot")
-            ]
-            
-            # Store the set_commands_task to be awaited later
-        try:
-                # Instead of asyncio.create_task, we will await this in the startup event
-                self.set_commands_task = self.bot.set_my_commands(commands)
-                logger.info("Bot commands ready to be set")
-            except Exception as cmd_e:
-            logger.error(f"Error preparing bot commands: {str(cmd_e)}")
-            
-            # Register command handlers
-            application.add_handler(CommandHandler("start", self.start_command))
-            application.add_handler(CommandHandler("menu", self.menu_command))
-            application.add_handler(CommandHandler("help", self.help_command))
-            
-            # Register secret admin commands
-            application.add_handler(CommandHandler("set_subscription", self.set_subscription_command))
-            application.add_handler(CommandHandler("set_payment_failed", self.set_payment_failed_command))
-            logger.info("Registered secret admin commands")
-            
-            # Register callback handlers
-            application.add_handler(CallbackQueryHandler(self.menu_analyse_callback, pattern="^menu_analyse$"))
-            application.add_handler(CallbackQueryHandler(self.menu_signals_callback, pattern="^menu_signals$"))
-            application.add_handler(CallbackQueryHandler(self.signals_add_callback, pattern="^signals_add$"))
-            application.add_handler(CallbackQueryHandler(self.signals_manage_callback, pattern="^signals_manage$"))
-            application.add_handler(CallbackQueryHandler(self.market_callback, pattern="^market_"))
-            application.add_handler(CallbackQueryHandler(self.instrument_callback, pattern="^instrument_(?!.*_signals)"))
-            application.add_handler(CallbackQueryHandler(self.instrument_signals_callback, pattern="^instrument_.*_signals$"))
-            
-            # Add handler for back buttons
-            application.add_handler(CallbackQueryHandler(self.back_market_callback, pattern="^back_market$"))
-            application.add_handler(CallbackQueryHandler(self.back_instrument_callback, pattern="^back_instrument$"))
-            application.add_handler(CallbackQueryHandler(self.back_signals_callback, pattern="^back_signals$"))
-            application.add_handler(CallbackQueryHandler(self.back_menu_callback, pattern="^back_menu$"))
-            
-            # Analysis handlers for regular flow
-            application.add_handler(CallbackQueryHandler(self.analysis_technical_callback, pattern="^analysis_technical$"))
-            application.add_handler(CallbackQueryHandler(self.analysis_sentiment_callback, pattern="^analysis_sentiment$"))
-            application.add_handler(CallbackQueryHandler(self.analysis_calendar_callback, pattern="^analysis_calendar$"))
-            
-            # Analysis handlers for signal flow - with instrument embedded in callback
-            application.add_handler(CallbackQueryHandler(self.signal_technical_callback, pattern="^signal_flow_technical_.*$"))
-            application.add_handler(CallbackQueryHandler(self.signal_sentiment_callback, pattern="^signal_flow_sentiment_.*$"))
-            application.add_handler(CallbackQueryHandler(self.signal_calendar_callback, pattern="^signal_flow_calendar_.*$"))
-            
-            # Analysis handlers for signal flow - with instrument embedded in callback
-            application.add_handler(CallbackQueryHandler(self.signal_technical_callback, pattern="^signal_flow_technical_.*$"))
-            application.add_handler(CallbackQueryHandler(self.signal_sentiment_callback, pattern="^signal_flow_sentiment_.*$"))
-            application.add_handler(CallbackQueryHandler(self.analysis_calendar_callback, pattern="^signal_flow_calendar_.*$"))
-            
-            # Signal analysis flow handlers
-            application.add_handler(CallbackQueryHandler(self.signal_technical_callback, pattern="^signal_technical$"))
-            application.add_handler(CallbackQueryHandler(self.signal_sentiment_callback, pattern="^signal_sentiment$"))
-            application.add_handler(CallbackQueryHandler(self.signal_calendar_callback, pattern="^signal_calendar$"))
-            application.add_handler(CallbackQueryHandler(self.signal_calendar_callback, pattern="^signal_flow_calendar_.*$"))
-            application.add_handler(CallbackQueryHandler(self.back_to_signal_callback, pattern="^back_to_signal$"))
-            application.add_handler(CallbackQueryHandler(self.back_to_signal_analysis_callback, pattern="^back_to_signal_analysis$"))
-            
-            # Signal from analysis
-            application.add_handler(CallbackQueryHandler(self.analyze_from_signal_callback, pattern="^analyze_from_signal_.*$"))
-            
-            # Ensure back_instrument is properly handled
-            application.add_handler(CallbackQueryHandler(self.back_instrument_callback, pattern="^back_instrument$"))
-            
-            # Catch-all handler for any other callbacks
-            application.add_handler(CallbackQueryHandler(self.button_callback))
-            
-            # Don't load signals here - it will be done in initialize_services
-            # self._load_signals()
-            
-            logger.info("Bot setup completed successfully")
-            
-    except Exception as e:
-        logger.error(f"Error setting up bot handlers: {str(e)}")
-        logger.exception(e)
-
-    @property
-    def signals_enabled(self):
-        """Get whether signals processing is enabled"""
-        return self._signals_enabled
-    
-    @signals_enabled.setter
-    def signals_enabled(self, value):
-        """Set whether signals processing is enabled"""
-        self._signals_enabled = bool(value)
-        logger.info(f"Signal processing is now {'enabled' if value else 'disabled'}")
-
-        async def start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE = None) -> None:
-        """Send a welcome message when the bot is started."""
-        user = update.effective_user
-        user_id = user.id
-        first_name = user.first_name
-        
-        # Try to add the user to the database if they don't exist yet
-    try:
-            # Get user subscription since we can't check if user exists directly
-            existing_subscription = await self.db.get_user_subscription(user_id)
-            
-            if not existing_subscription:
-                # Add new user
-                logger.info(f"New user started: {user_id}, {first_name}")
-                await self.db.save_user(user_id, first_name, None, user.username)
-        else:
-                logger.info(f"Existing user started: {user_id}, {first_name}")
-                
-# Import necessary modules for improved logging
-import os
-import sys
-import json
-import logging
-import logging.config
-from datetime import datetime
-
-
-async def _get_signal_related_trades(self, signal_id):
-    """Retrieve related trades from the database"""
-    try:
-        # Fetch the related trades data from the database
-        trades_data = await self.db.get_related_trades(signal_id)
-        
-        if trades_data:
-            return trades_data
-        else:
-            logger.warning(f"No related trades data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related trades: {str(e)}")
-        logger.exception(e)
-        return None
-
-
-from telegram.error import TelegramError, BadRequest
-import httpx
-import telegram.error  # Add this import for BadRequest error handling
-
-from trading_bot.services.database.db import Database
-from trading_bot.services.chart_service.chart import ChartService
-from trading_bot.services.sentiment_service.sentiment import MarketSentimentService
-from trading_bot.services.calendar_service import EconomicCalendarService
-from trading_bot.services.payment_service.stripe_service import StripeService
-from trading_bot.services.payment_service.stripe_config import get_subscription_features
-from trading_bot.services.telegram_service.states import (
-    MENU, ANALYSIS, SIGNALS, CHOOSE_MARKET, CHOOSE_INSTRUMENT, CHOOSE_STYLE,
-    CHOOSE_ANALYSIS, SIGNAL_DETAILS,
-    CALLBACK_MENU_ANALYSE, CALLBACK_MENU_SIGNALS, CALLBACK_ANALYSIS_TECHNICAL,
-    CALLBACK_ANALYSIS_SENTIMENT, CALLBACK_ANALYSIS_CALENDAR, CALLBACK_SIGNALS_ADD,
-    CALLBACK_SIGNALS_MANAGE, CALLBACK_BACK_MENU
-)
-import trading_bot.services.telegram_service.gif_utils as gif_utils
-
-# Initialize logger
-logger = logging.getLogger(__name__)
-
-# Major currencies to focus on
-MAJOR_CURRENCIES = ["USD", "EUR", "GBP", "JPY", "CHF", "AUD", "NZD", "CAD"]
-
-# Currency to flag emoji mapping
-CURRENCY_FLAG = {
-    "USD": "üá∫üá∏",
-    "EUR": "üá™üá∫",
-    "GBP": "üá¨üáß",
-    "JPY": "üáØüáµ",
-    "CHF": "üá®üá≠",
-    "AUD": "üá¶üá∫",
-    "NZD": "üá≥üáø",
-    "CAD": "üá®üá¶"
-}
-
-# Map of instruments to their corresponding currencies
-INSTRUMENT_CURRENCY_MAP = {
-    # Special case for global view
-    "GLOBAL": MAJOR_CURRENCIES,
-    
-    # Forex
-    "EURUSD": ["EUR", "USD"],
-    "GBPUSD": ["GBP", "USD"],
-    "USDJPY": ["USD", "JPY"],
-    "USDCHF": ["USD", "CHF"],
-    "AUDUSD": ["AUD", "USD"],
-    "NZDUSD": ["NZD", "USD"],
-    "USDCAD": ["USD", "CAD"],
-    "EURGBP": ["EUR", "GBP"],
-    "EURJPY": ["EUR", "JPY"],
-    "GBPJPY": ["GBP", "JPY"],
-    
-    # Indices (mapped to their related currencies)
-    "US30": ["USD"],
-    "US100": ["USD"],
-    "US500": ["USD"],
-    "UK100": ["GBP"],
-    "GER40": ["EUR"],
-    "FRA40": ["EUR"],
-    "ESP35": ["EUR"],
-    "JP225": ["JPY"],
-    "AUS200": ["AUD"],
-    
-    # Commodities (mapped to USD primarily)
-    "XAUUSD": ["USD", "XAU"],  # Gold
-    "XAGUSD": ["USD", "XAG"],  # Silver
-    "USOIL": ["USD"],          # Oil (WTI)
-    "UKOIL": ["USD", "GBP"],   # Oil (Brent)
-    
-    # Crypto
-    "BTCUSD": ["USD", "BTC"],
-    "ETHUSD": ["USD", "ETH"],
-    "LTCUSD": ["USD", "LTC"],
-    "XRPUSD": ["USD", "XRP"]
-}
-
-# Callback data constants
-CALLBACK_ANALYSIS_TECHNICAL = "analysis_technical"
-CALLBACK_ANALYSIS_SENTIMENT = "analysis_sentiment"
-CALLBACK_ANALYSIS_CALENDAR = "analysis_calendar"
-CALLBACK_BACK_MENU = "back_menu"
-CALLBACK_BACK_ANALYSIS = "back_to_analysis"
-CALLBACK_BACK_MARKET = "back_market"
-CALLBACK_BACK_INSTRUMENT = "back_instrument"
-CALLBACK_BACK_SIGNALS = "back_signals"
-CALLBACK_SIGNALS_ADD = "signals_add"
-CALLBACK_SIGNALS_MANAGE = "signals_manage"
-CALLBACK_MENU_ANALYSE = "menu_analyse"
-CALLBACK_MENU_SIGNALS = "menu_signals"
-
-# States
-MENU = 0
-CHOOSE_ANALYSIS = 1
-CHOOSE_SIGNALS = 2
-CHOOSE_MARKET = 3
-CHOOSE_INSTRUMENT = 4
-CHOOSE_STYLE = 5
-SHOW_RESULT = 6
-CHOOSE_TIMEFRAME = 7
-SIGNAL_DETAILS = 8
-SIGNAL = 9
-SUBSCRIBE = 10
-BACK_TO_MENU = 11  # Add this line
-
-# Messages
-WELCOME_MESSAGE = r"""
-<b>Sigmapips AI - Main Menu</b>
-
-Choose an option to access advanced trading support:
-
-Services:
-- <b>Technical Analysis</b> - Real-time chart analysis and key levels
-
-- <b>Market Sentiment</b> - Understand market trends and sentiment
-
-- <b>Economic Calendar</b> - Stay updated on market-moving events
-
-- <b>Trading Signals</b> - Get precise entry/exit points for your favorite pairs
-
-Select your option to continue:
-"""
-
-# Abonnementsbericht voor nieuwe gebruikers
-SUBSCRIPTION_WELCOME_MESSAGE = r"""
-<b>Welcome to Sigmapips AI!</b>
-
-To access all features, you need a subscription:
-
-<b>Trading Signals Subscription - $29.99/month</b>
-- Access to all trading signals (Forex, Crypto, Commodities, Indices)
-- Advanced timeframe analysis
-- Detailed chart analysis for each signal
-
-Click the button below to subscribe:
-"""
-
-MENU_MESSAGE = r"""
-Welcome to Sigmapips AI!
-
-Choose a command:
-
-/start - Set up new trading pairs
-Add new market/instrument/timeframe combinations to receive signals
-
-/manage - Manage your preferences
-View, edit or delete your saved trading pairs
-
-Need help? Use /help to see all available commands.
-"""
-
-HELP_MESSAGE = r"""
-Available commands:
-/menu - Show main menu
-/start - Set up new trading pairs
-/help - Show this help message
-"""
-
-# Start menu keyboard
-START_KEYBOARD = [
-    [InlineKeyboardButton("Analyze Market", callback_data=CALLBACK_MENU_ANALYSE)],
-    [InlineKeyboardButton("Trading Signals", callback_data=CALLBACK_MENU_SIGNALS)]
-]
-
-# Analysis menu keyboard
-ANALYSIS_KEYBOARD = [
-    [InlineKeyboardButton("Technical Analysis", callback_data=CALLBACK_ANALYSIS_TECHNICAL)],
-    [InlineKeyboardButton("Market Sentiment", callback_data=CALLBACK_ANALYSIS_SENTIMENT)],
-    [InlineKeyboardButton("Economic Calendar", callback_data=CALLBACK_ANALYSIS_CALENDAR)],
-    [InlineKeyboardButton("Back", callback_data=CALLBACK_BACK_MENU)]
-]
-
-# Signals menu keyboard
-SIGNALS_KEYBOARD = [
-    [InlineKeyboardButton("Add New Pairs", callback_data=CALLBACK_SIGNALS_ADD)],
-    [InlineKeyboardButton("Manage Signals", callback_data=CALLBACK_SIGNALS_MANAGE)],
-    [InlineKeyboardButton("Back", callback_data=CALLBACK_BACK_MENU)]
-]
-
-# Market keyboard voor signals
-MARKET_KEYBOARD_SIGNALS = [
-    [InlineKeyboardButton("Forex", callback_data="market_forex_signals")],
-    [InlineKeyboardButton("Crypto", callback_data="market_crypto_signals")],
-    [InlineKeyboardButton("Commodities", callback_data="market_commodities_signals")],
-    [InlineKeyboardButton("Indices", callback_data="market_indices_signals")],
-    [InlineKeyboardButton("Back", callback_data="back_signals")]
-]
-
-# Market keyboard voor analyse
-MARKET_KEYBOARD = [
-    [InlineKeyboardButton("Forex", callback_data="market_forex")],
-    [InlineKeyboardButton("Crypto", callback_data="market_crypto")],
-    [InlineKeyboardButton("Commodities", callback_data="market_commodities")],
-    [InlineKeyboardButton("Indices", callback_data="market_indices")],
-    [InlineKeyboardButton("Back", callback_data="back_analysis")]
-]
-
-# Market keyboard specifiek voor sentiment analyse
-MARKET_SENTIMENT_KEYBOARD = [
-    [InlineKeyboardButton("Forex", callback_data="market_forex_sentiment")],
-    [InlineKeyboardButton("Crypto", callback_data="market_crypto_sentiment")],
-    [InlineKeyboardButton("Commodities", callback_data="market_commodities_sentiment")],
-    [InlineKeyboardButton("Indices", callback_data="market_indices_sentiment")],
-    [InlineKeyboardButton("Back", callback_data="back_analysis")]
-]
-
-# Forex keyboard voor technical analyse
-FOREX_KEYBOARD = [
-    [
-        InlineKeyboardButton("EURUSD", callback_data="instrument_EURUSD_chart"),
-        InlineKeyboardButton("GBPUSD", callback_data="instrument_GBPUSD_chart"),
-        InlineKeyboardButton("USDJPY", callback_data="instrument_USDJPY_chart")
-    ],
-    [
-        InlineKeyboardButton("AUDUSD", callback_data="instrument_AUDUSD_chart"),
-        InlineKeyboardButton("USDCAD", callback_data="instrument_USDCAD_chart"),
-        InlineKeyboardButton("EURGBP", callback_data="instrument_EURGBP_chart")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Forex keyboard voor sentiment analyse
-FOREX_SENTIMENT_KEYBOARD = [
-    [
-        InlineKeyboardButton("EURUSD", callback_data="instrument_EURUSD_sentiment"),
-        InlineKeyboardButton("GBPUSD", callback_data="instrument_GBPUSD_sentiment"),
-        InlineKeyboardButton("USDJPY", callback_data="instrument_USDJPY_sentiment")
-    ],
-    [
-        InlineKeyboardButton("AUDUSD", callback_data="instrument_AUDUSD_sentiment"),
-        InlineKeyboardButton("USDCAD", callback_data="instrument_USDCAD_sentiment"),
-        InlineKeyboardButton("EURGBP", callback_data="instrument_EURGBP_sentiment")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Forex keyboard voor kalender analyse
-FOREX_CALENDAR_KEYBOARD = [
-    [
-        InlineKeyboardButton("EURUSD", callback_data="instrument_EURUSD_calendar"),
-        InlineKeyboardButton("GBPUSD", callback_data="instrument_GBPUSD_calendar"),
-        InlineKeyboardButton("USDJPY", callback_data="instrument_USDJPY_calendar")
-    ],
-    [
-        InlineKeyboardButton("AUDUSD", callback_data="instrument_AUDUSD_calendar"),
-        InlineKeyboardButton("USDCAD", callback_data="instrument_USDCAD_calendar"),
-        InlineKeyboardButton("EURGBP", callback_data="instrument_EURGBP_calendar")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Crypto keyboard voor analyse
-CRYPTO_KEYBOARD = [
-    [
-        InlineKeyboardButton("BTCUSD", callback_data="instrument_BTCUSD_chart"),
-        InlineKeyboardButton("ETHUSD", callback_data="instrument_ETHUSD_chart"),
-        InlineKeyboardButton("XRPUSD", callback_data="instrument_XRPUSD_chart")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Signal analysis keyboard
-SIGNAL_ANALYSIS_KEYBOARD = [
-    [InlineKeyboardButton("Technical Analysis", callback_data="signal_technical")],
-    [InlineKeyboardButton("Market Sentiment", callback_data="signal_sentiment")],
-    [InlineKeyboardButton("Economic Calendar", callback_data="signal_calendar")],
-    [InlineKeyboardButton("Back", callback_data="back_to_signal")]
-]
-
-# Crypto keyboard voor sentiment analyse
-CRYPTO_SENTIMENT_KEYBOARD = [
-    [
-        InlineKeyboardButton("BTCUSD", callback_data="instrument_BTCUSD_sentiment"),
-        InlineKeyboardButton("ETHUSD", callback_data="instrument_ETHUSD_sentiment"),
-        InlineKeyboardButton("XRPUSD", callback_data="instrument_XRPUSD_sentiment")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Indices keyboard voor analyse
-INDICES_KEYBOARD = [
-    [
-        InlineKeyboardButton("US30", callback_data="instrument_US30_chart"),
-        InlineKeyboardButton("US500", callback_data="instrument_US500_chart"),
-        InlineKeyboardButton("US100", callback_data="instrument_US100_chart")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Indices keyboard voor signals - Fix de "Terug" knop naar "Back"
-INDICES_KEYBOARD_SIGNALS = [
-    [
-        InlineKeyboardButton("US30", callback_data="instrument_US30_signals"),
-        InlineKeyboardButton("US500", callback_data="instrument_US500_signals"),
-        InlineKeyboardButton("US100", callback_data="instrument_US100_signals")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Commodities keyboard voor analyse
-COMMODITIES_KEYBOARD = [
-    [
-        InlineKeyboardButton("GOLD", callback_data="instrument_XAUUSD_chart"),
-        InlineKeyboardButton("SILVER", callback_data="instrument_XAGUSD_chart"),
-        InlineKeyboardButton("OIL", callback_data="instrument_USOIL_chart")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Commodities keyboard voor signals - Fix de "Terug" knop naar "Back"
-COMMODITIES_KEYBOARD_SIGNALS = [
-    [
-        InlineKeyboardButton("XAUUSD", callback_data="instrument_XAUUSD_signals"),
-        InlineKeyboardButton("XAGUSD", callback_data="instrument_XAGUSD_signals"),
-        InlineKeyboardButton("USOIL", callback_data="instrument_USOIL_signals")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Forex keyboard for signals
-FOREX_KEYBOARD_SIGNALS = [
-    [
-        InlineKeyboardButton("EURUSD", callback_data="instrument_EURUSD_signals"),
-        InlineKeyboardButton("GBPUSD", callback_data="instrument_GBPUSD_signals"),
-        InlineKeyboardButton("USDJPY", callback_data="instrument_USDJPY_signals")
-    ],
-    [
-        InlineKeyboardButton("USDCAD", callback_data="instrument_USDCAD_signals"),
-        InlineKeyboardButton("EURGBP", callback_data="instrument_EURGBP_signals")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Crypto keyboard for signals
-CRYPTO_KEYBOARD_SIGNALS = [
-    [
-        InlineKeyboardButton("BTCUSD", callback_data="instrument_BTCUSD_signals"),
-        InlineKeyboardButton("ETHUSD", callback_data="instrument_ETHUSD_signals"),
-        InlineKeyboardButton("XRPUSD", callback_data="instrument_XRPUSD_signals")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Indices keyboard voor sentiment analyse
-INDICES_SENTIMENT_KEYBOARD = [
-    [
-        InlineKeyboardButton("US30", callback_data="instrument_US30_sentiment"),
-        InlineKeyboardButton("US500", callback_data="instrument_US500_sentiment"),
-        InlineKeyboardButton("US100", callback_data="instrument_US100_sentiment")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Commodities keyboard voor sentiment analyse
-COMMODITIES_SENTIMENT_KEYBOARD = [
-    [
-        InlineKeyboardButton("GOLD", callback_data="instrument_XAUUSD_sentiment"),
-        InlineKeyboardButton("SILVER", callback_data="instrument_XAGUSD_sentiment"),
-        InlineKeyboardButton("OIL", callback_data="instrument_USOIL_sentiment")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Style keyboard
-STYLE_KEYBOARD = [
-    [InlineKeyboardButton("‚ö° Test (one_min)", callback_data="style_test")],
-    [InlineKeyboardButton("üèÉ Scalp (fifteen_min)", callback_data="style_scalp")],
-    [InlineKeyboardButton(" Intraday (one_hour)", callback_data="style_intraday")],
-    [InlineKeyboardButton("üåä Swing (four_hour)", callback_data="style_swing")],
-    [InlineKeyboardButton("Back", callback_data="back_instrument")]
-]
-
-# Timeframe mapping
-STYLE_TIMEFRAME_MAP = {
-    "test": "one_min",
-    "scalp": "fifteen_min",
-    "intraday": "one_hour",
-    "swing": "four_hour"
-}
-
-# Mapping of instruments to their allowed timeframes - updated 2023-03-23
-INSTRUMENT_TIMEFRAME_MAP = {
-    # H1 timeframe only
-    "AUDJPY": "H1", 
-    "AUDCHF": "H1",
-    "EURCAD": "H1",
-    "EURGBP": "H1",
-    "GBPCHF": "H1",
-    "HK50": "H1",
-    "NZDJPY": "H1",
-    "USDCHF": "H1",
-    "USDJPY": "H1",  # USDJPY toegevoegd voor signaalabonnementen
-    "XRPUSD": "H1",
-    
-    # H4 timeframe only
-    "AUDCAD": "H4",
-    "AU200": "H4", 
-    "CADCHF": "H4",
-    "EURCHF": "H4",
-    "EURUSD": "H4",
-    "GBPCAD": "H4",
-    "LINKUSD": "H4",
-    "NZDCHF": "H4",
-    
-    # M15 timeframe only
-    "DOGEUSD": "M15",
-    "GBPNZD": "M15",
-    "NZDUSD": "M15",
-    "SOLUSD": "M15",
-    "UK100": "M15",
-    "XAUUSD": "M15",
-    
-    # M30 timeframe only
-    "BNBUSD": "M30",
-    "DOTUSD": "M30",
-    "ETHUSD": "M30",
-    "EURAUD": "M30",
-    "EURJPY": "M30",
-    "GBPAUD": "M30",
-    "GBPUSD": "M30",
-    "NZDCAD": "M30",
-    "US30": "M30",
-    "US500": "M30",
-    "USDCAD": "M30",
-    "XLMUSD": "M30",
-    "XTIUSD": "M30",
-    "DE40": "M30",
-    "BTCUSD": "M30",  # Added for consistency with CRYPTO_KEYBOARD_SIGNALS
-    "US100": "M30",   # Added for consistency with INDICES_KEYBOARD_SIGNALS
-    "XAGUSD": "M15",  # Added for consistency with COMMODITIES_KEYBOARD_SIGNALS
-    "USOIL": "M30"    # Added for consistency with COMMODITIES_KEYBOARD_SIGNALS
-    
-    # Removed as requested: EU50, FR40, LTCUSD
-}
-
-# Map common timeframe notations
-TIMEFRAME_DISPLAY_MAP = {
-    "M15": "15 Minutes",
-    "M30": "30 Minutes", 
-    "H1": "1 Hour",
-    "H4": "4 Hours"
-}
-
-# Voeg deze functie toe aan het begin van bot.py, na de imports
-def _detect_market(instrument: str) -> str:
-    """Detecteer market type gebaseerd op instrument"""
-    instrument = instrument.upper()
-    
-    # Commodities eerst checken
-    commodities = [
-        "XAUUSD",  # Gold
-        "XAGUSD",  # Silver
-        "WTIUSD",  # Oil WTI
-        "BCOUSD",  # Oil Brent
-        "USOIL",   # Oil WTI (alternative symbol)
-    ]
-    if instrument in commodities:
-        logger.info(f"Detected {instrument} as commodity")
-        return "commodities"
-    
-    # Crypto pairs
-    crypto_base = ["BTC", "ETH", "XRP", "SOL", "BNB", "ADA", "DOT", "LINK"]
-    if any(c in instrument for c in crypto_base):
-        logger.info(f"Detected {instrument} as crypto")
-        return "crypto"
-    
-    # Major indices
-    indices = [
-        "US30", "US500", "US100",  # US indices
-        "UK100", "DE40", "FR40",   # European indices
-        "JP225", "AU200", "HK50"   # Asian indices
-    ]
-    if instrument in indices:
-        logger.info(f"Detected {instrument} as index")
-        return "indices"
-    
-    # Forex pairs als default
-    logger.info(f"Detected {instrument} as forex")
-    return "forex"
-
-# Voeg dit toe als decorator functie bovenaan het bestand na de imports
-def require_subscription(func):
-    """Check if user has an active subscription"""
-    async def wrapper(self, update: Update, context: ContextTypes.DEFAULT_TYPE, *args, **kwargs):
-        user_id = update.effective_user.id
-        
-        # Check subscription status
-        is_subscribed = await self.db.is_user_subscribed(user_id)
-        
-        # Check if payment has failed
-        payment_failed = await self.db.has_payment_failed(user_id)
-        
-        if is_subscribed and not payment_failed:
-            # User has subscription, proceed with function
-            return await func(self, update, context, *args, **kwargs)
-        else:
-            if payment_failed:
-                # Show payment failure message
-                failed_payment_text = f"""
- <b>Subscription Payment Failed</b> 
-
-Your subscription payment could not be processed and your service has been deactivated.
-
-To continue using Sigmapips AI and receive trading signals, please reactivate your subscription by clicking the button below.
-                """
-                
-                # Use direct URL link for reactivation
-                reactivation_url = "https://buy.stripe.com/9AQcPf3j63HL5JS145"
-                
-                # Create button for reactivation
-                keyboard = [
-                    [InlineKeyboardButton("üîÑ Reactivate Subscription", url=reactivation_url)]
-                ]
-            else:
-                # Show subscription screen with the welcome message from the screenshot
-                failed_payment_text = f"""
- <b>Welcome to Sigmapips AI!</b> 
-
-<b>Discover powerful trading signals for various markets:</b>
-- <b>Forex</b> - Major and minor currency pairs
-- <b>Crypto</b> - Bitcoin, Ethereum and other top cryptocurrencies
-- <b>Indices</b> - Global market indices
-- <b>Commodities</b> - Gold, silver and oil
-
-<b>Features:</b>
- Real-time trading signals
-
- Multi-timeframe analysis (timeframes)
-
- Advanced chart analysis
-
- Sentiment indicators
-
- Economic calendar integration
-
-<b>Start today with a FREE 14-day trial!</b>
-                """
-                
-                # Use direct URL link instead of callback for the trial button
-                reactivation_url = "https://buy.stripe.com/3cs3eF9Hu9256NW9AA"
-                
-                # Create button for trial
-                keyboard = [
-                    [InlineKeyboardButton("üî• Start 14-day FREE Trial", url=reactivation_url)]
-                ]
-            
-            # Handle both message and callback query updates
-            if update.callback_query:
-                await update.callback_query.answer()
-                await update.callback_query.edit_message_text(
-                    text=failed_payment_text,
-                    reply_markup=InlineKeyboardMarkup(keyboard),
-                    parse_mode=ParseMode.HTML
-                )
-            else:
-                await update.message.reply_text(
-                    text=failed_payment_text,
-                    reply_markup=InlineKeyboardMarkup(keyboard),
-                    parse_mode=ParseMode.HTML
-                )
-            return MENU
-    
-    return wrapper
-
-# API keys with robust sanitization
-PERPLEXITY_API_KEY = os.getenv("PERPLEXITY_API_KEY", "").strip()
-OPENAI_API_KEY = os.getenv("OPENAI_API_KEY", "").strip()  # Changed from DeepSeek to OpenAI
-
-# Only using OpenAI's o4-mini now
-# No Tavily API key needed anymore
-logger.info("Using only OpenAI o4-mini for Market Sentiment service")
-
-# Log OpenAI API key (partially masked)
-if OPENAI_API_KEY:
-    # Better masking for privacy and security
-    masked_key = f"sk-p...{OPENAI_API_KEY[-4:]}" if len(OPENAI_API_KEY) > 8 else "sk-p..."
-    logger.info(f"Using OpenAI API key: {masked_key}")
-    
-    # Validate the key format
-    from trading_bot.config import validate_openai_key
-    if not validate_openai_key(OPENAI_API_KEY):
-        logger.warning("OpenAI API key format is invalid. AI services may not work correctly.")
-else:
-    logger.warning("No OpenAI API key configured. AI services will be disabled.")
-    
-# Set environment variables for the API keys with sanitization
-os.environ["PERPLEXITY_API_KEY"] = PERPLEXITY_API_KEY
-os.environ["OPENAI_API_KEY"] = OPENAI_API_KEY  # Changed from DeepSeek to OpenAI
-# No Tavily environment needed
-
-class TelegramService:
-    def __init__(self, db: Database, stripe_service=None, bot_token: Optional[str] = None, proxy_url: Optional[str] = None, lazy_init: bool = False):
-        """Initialize the bot with given database and config."""
-        # Database connection
-        self.db = db
-        
-        # Setup configuration 
-        self.stripe_service = stripe_service
-        self.user_signals = {}
-        self.signals_dir = "data/signals"
-        self.signals_enabled_val = True
-        self.polling_started = False
-        self.admin_users = [2004519703]  # Updated with correct Telegram ID from logs
-        self._signals_enabled = True  # Enable signals by default
-        
-        # Setup logger
-        self.logger = logging.getLogger(__name__)
-        
-        # GIF utilities for UI
-        self.gif_utils = gif_utils  # Initialize gif_utils as an attribute
-        
-        # Setup the bot and application
-        self.bot = None
-        self.application = None
-        
-        # Telegram Bot configuratie
-        self.bot_token = bot_token or os.getenv("TELEGRAM_BOT_TOKEN", "")
-        self.token = self.bot_token  # Aliased for backward compatibility
-        self.proxy_url = proxy_url or os.getenv("TELEGRAM_PROXY_URL", "")
-        
-        # Configure custom request handler with improved connection settings
-        request = HTTPXRequest(
-            connection_pool_size=50,  # Increase from 20 to 50
-            connect_timeout=15.0,     # Increase from 10.0 to 15.0
-            read_timeout=45.0,        # Increase from 30.0 to 45.0
-            write_timeout=30.0,       # Increase from 20.0 to 30.0
-            pool_timeout=60.0,        # Increase from 30.0 to 60.0
-        )
-        
-        # Initialize the bot directly with connection pool settings
-        self.bot = Bot(token=self.bot_token, request=request)
-        self.application = None  # Will be initialized in setup()
-        
-        # Webhook configuration
-        self.webhook_url = os.getenv("WEBHOOK_URL", "")
-        self.webhook_path = "/webhook"  # Always use this path
-        if self.webhook_url.endswith("/"):
-            self.webhook_url = self.webhook_url[:-1]  # Remove trailing slash
-            
-        logger.info(f"Bot initialized with webhook URL: {self.webhook_url} and path: {self.webhook_path}")
-        
-        # Initialize API services
-        self.chart_service = ChartService()  # Initialize chart service
-        # Lazy load services only when needed
-        self._calendar_service = None
-        self._sentiment_service = None
-        
-        # Don't use asyncio.create_task here - it requires a running event loop
-        # We'll initialize chart service later when the event loop is running
-        
-        # Bot application initialization
-        self.persistence = None
-        self.bot_started = False
-        
-        # Cache for sentiment analysis
-        self.sentiment_cache = {}
-        self.sentiment_cache_ttl = 60 * 60  # 1 hour in seconds
-        
-        # Start the bot
-    try:
-            # Check for bot token
-            if not self.bot_token:
-                raise ValueError("Missing Telegram bot token")
-            
-            # Initialize the bot
-            self.bot = Bot(token=self.bot_token)
-        
-            # Initialize the application
-            self.application = Application.builder().bot(self.bot).build()
-        
-            # Register the handlers
-            self._register_handlers(self.application)
-            
-            # Initialize signals dictionary but don't load them yet (will be done in initialize_services)
-            self.user_signals = {}
-        
-            logger.info("Telegram service initialized")
-            
-            # Keep track of processed updates
-            self.processed_updates = set()
-            
-    except Exception as e:
-        logger.error(f"Error initializing Telegram service: {str(e)}")
-        raise
-
-    async def initialize_services(self):
-        """Initialize services that require an asyncio event loop"""
-        try:
-            # Initialize chart service
-            await self.chart_service.initialize()
-            logger.info("Chart service initialized")
-            
-            # Load stored signals
-            await self._load_signals()
-            logger.info("Signals loaded")
-            
-            # Schedule periodic cleanup of old signals
-            if hasattr(self, 'db') and self.db and self.db.using_redis:
-                # Run initial cleanup
-                cleaned = await self._cleanup_old_signals(max_age_days=7)
-                logger.info(f"Initial signal cleanup completed, removed {cleaned} old signals")
-                
-                # Schedule periodic cleanup (every 24 hours)
-                async def periodic_cleanup():
-                    while True:
-                        try:
-                            # Wait for 24 hours
-                            await asyncio.sleep(24 * 60 * 60)
-                            # Run cleanup
-                            cleaned = await self._cleanup_old_signals(max_age_days=7)
-                            logger.info(f"Periodic signal cleanup completed, removed {cleaned} old signals")
-                        except Exception as e:
-                            logger.error(f"Error in periodic signal cleanup: {str(e)}")
-                
-                # Start the periodic cleanup task
-                asyncio.create_task(periodic_cleanup())
-                logger.info("Scheduled periodic signal cleanup")
-        except Exception as e:
-            logger.error(f"Error initializing services: {str(e)}")
-            raise
-
-# Calendar service helpers
-    @property
-    def signals_enabled(self):
-        """Get whether signals processing is enabled"""
-        return self._signals_enabled
-    
-    @signals_enabled.setter
-    def signals_enabled(self, value):
-        """Set whether signals processing is enabled"""
-        self._signals_enabled = bool(value)
-        logger.info(f"Signal processing is now {'enabled' if value else 'disabled'}")
-
-    async def start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE = None) -> None:
-        """Handle the /start command"""
-        user = update.effective_user
-        logger.info(f"User {user.id} ({user.username}) started the bot")
-        
-        # Check if user is subscribed
-        is_subscribed = await self.db.is_user_subscribed(user.id)
-        
-        # Create welcome message
-        welcome_text = (
-            f"üëã Welcome to SigmaPips Trading Bot, {user.first_name}!\n\n"
-            "I'm your AI-powered trading assistant. Here's what I can do for you:\n\n"
-            " <b>Market Analysis</b> - Technical and sentiment analysis for major markets\n"
-            " <b>Signal Management</b> - Receive and manage trading signals\n"
-            " <b>Economic Calendar</b> - Stay updated with important economic events\n\n"
-        )
-        
-        # Add subscription status
-        if is_subscribed:
-            welcome_text += " <b>Subscription Status:</b> Active\n\n"
-        else:
-            welcome_text += " <b>Subscription Status:</b> Inactive\n\n"
-        
-        welcome_text += "Use the /menu command to access all features."
-        
-        # Create keyboard for main menu
-        keyboard = [
-            [InlineKeyboardButton(" Analyze Markets", callback_data="menu_analyse")],
-            [InlineKeyboardButton(" Signal Management", callback_data="menu_signals")],
-            [InlineKeyboardButton("‚ùì Help", callback_data="menu_help")]
-        ]
-        reply_markup = InlineKeyboardMarkup(keyboard)
-        
-        # Send welcome message with keyboard
-        await update.message.reply_html(
-            welcome_text,
-            reply_markup=reply_markup
-        )
-        
-        # Log the user interaction
-        logger.info(f"Sent welcome message to user {user.id}")
-        
-        # Store user data if needed
-        if context:
-            context.user_data['is_signals_context'] = False
-            context.user_data['from_signal'] = False
-            context.user_data['in_signal_flow'] = False
-        
-        return MAIN_MENU
-
-# Initialize logging early in the application startup
-logger = setup_logging()
-
-import os
-import json
-import asyncio
-import traceback
-from typing import Dict, Any, List, Optional, Union, Set
-from datetime import datetime, timedelta
-import logging
-import copy
-import re
-import time
-import random
-
-from fastapi import FastAPI, Request, HTTPException, status
-from telegram import Bot, Update, BotCommand, InlineKeyboardButton, InlineKeyboardMarkup, CallbackQuery, InputMediaPhoto, InputMediaAnimation, InputMediaDocument, ReplyKeyboardMarkup, ReplyKeyboardRemove, InputFile
-from telegram.constants import ParseMode
-from telegram.request import HTTPXRequest
-from telegram.ext import (
-    Application,
-    CommandHandler,
-    CallbackQueryHandler,
-    ConversationHandler,
-    ContextTypes,
-    CallbackContext,
-    MessageHandler,
-    filters,
-    PicklePersistence
-)
-from telegram.error import TelegramError, BadRequest
-import httpx
-import telegram.error  # Add this import for BadRequest error handling
-
-from trading_bot.services.database.db import Database
-from trading_bot.services.chart_service.chart import ChartService
-from trading_bot.services.sentiment_service.sentiment import MarketSentimentService
-from trading_bot.services.calendar_service import EconomicCalendarService
-from trading_bot.services.payment_service.stripe_service import StripeService
-from trading_bot.services.payment_service.stripe_config import get_subscription_features
-from trading_bot.services.telegram_service.states import (
-    MENU, ANALYSIS, SIGNALS, CHOOSE_MARKET, CHOOSE_INSTRUMENT, CHOOSE_STYLE,
-    CHOOSE_ANALYSIS, SIGNAL_DETAILS,
-    CALLBACK_MENU_ANALYSE, CALLBACK_MENU_SIGNALS, CALLBACK_ANALYSIS_TECHNICAL,
-    CALLBACK_ANALYSIS_SENTIMENT, CALLBACK_ANALYSIS_CALENDAR, CALLBACK_SIGNALS_ADD,
-    CALLBACK_SIGNALS_MANAGE, CALLBACK_BACK_MENU
-)
-import trading_bot.services.telegram_service.gif_utils as gif_utils
-
-# Initialize logger
-logger = logging.getLogger(__name__)
-
-# Major currencies to focus on
-MAJOR_CURRENCIES = ["USD", "EUR", "GBP", "JPY", "CHF", "AUD", "NZD", "CAD"]
-
-# Currency to flag emoji mapping
-CURRENCY_FLAG = {
-    "USD": "üá∫üá∏",
-    "EUR": "üá™üá∫",
-    "GBP": "üá¨üáß",
-    "JPY": "üáØüáµ",
-    "CHF": "üá®üá≠",
-    "AUD": "üá¶üá∫",
-    "NZD": "üá≥üáø",
-    "CAD": "üá®üá¶"
-}
-
-# Map of instruments to their corresponding currencies
-INSTRUMENT_CURRENCY_MAP = {
-    # Special case for global view
-    "GLOBAL": MAJOR_CURRENCIES,
-    
-    # Forex
-    "EURUSD": ["EUR", "USD"],
-    "GBPUSD": ["GBP", "USD"],
-    "USDJPY": ["USD", "JPY"],
-    "USDCHF": ["USD", "CHF"],
-    "AUDUSD": ["AUD", "USD"],
-    "NZDUSD": ["NZD", "USD"],
-    "USDCAD": ["USD", "CAD"],
-    "EURGBP": ["EUR", "GBP"],
-    "EURJPY": ["EUR", "JPY"],
-    "GBPJPY": ["GBP", "JPY"],
-    
-    # Indices (mapped to their related currencies)
-    "US30": ["USD"],
-    "US100": ["USD"],
-    "US500": ["USD"],
-    "UK100": ["GBP"],
-    "GER40": ["EUR"],
-    "FRA40": ["EUR"],
-    "ESP35": ["EUR"],
-    "JP225": ["JPY"],
-    "AUS200": ["AUD"],
-    
-    # Commodities (mapped to USD primarily)
-    "XAUUSD": ["USD", "XAU"],  # Gold
-    "XAGUSD": ["USD", "XAG"],  # Silver
-    "USOIL": ["USD"],          # Oil (WTI)
-    "UKOIL": ["USD", "GBP"],   # Oil (Brent)
-    
-    # Crypto
-    "BTCUSD": ["USD", "BTC"],
-    "ETHUSD": ["USD", "ETH"],
-    "LTCUSD": ["USD", "LTC"],
-    "XRPUSD": ["USD", "XRP"]
-}
-
-# Callback data constants
-CALLBACK_ANALYSIS_TECHNICAL = "analysis_technical"
-CALLBACK_ANALYSIS_SENTIMENT = "analysis_sentiment"
-CALLBACK_ANALYSIS_CALENDAR = "analysis_calendar"
-CALLBACK_BACK_MENU = "back_menu"
-CALLBACK_BACK_ANALYSIS = "back_to_analysis"
-CALLBACK_BACK_MARKET = "back_market"
-CALLBACK_BACK_INSTRUMENT = "back_instrument"
-CALLBACK_BACK_SIGNALS = "back_signals"
-CALLBACK_SIGNALS_ADD = "signals_add"
-CALLBACK_SIGNALS_MANAGE = "signals_manage"
-CALLBACK_MENU_ANALYSE = "menu_analyse"
-CALLBACK_MENU_SIGNALS = "menu_signals"
-
-# States
-MENU = 0
-CHOOSE_ANALYSIS = 1
-CHOOSE_SIGNALS = 2
-CHOOSE_MARKET = 3
-CHOOSE_INSTRUMENT = 4
-CHOOSE_STYLE = 5
-SHOW_RESULT = 6
-CHOOSE_TIMEFRAME = 7
-SIGNAL_DETAILS = 8
-SIGNAL = 9
-SUBSCRIBE = 10
-BACK_TO_MENU = 11  # Add this line
-
-# Messages
-WELCOME_MESSAGE = r"""
-<b>Sigmapips AI - Main Menu</b>
-
-Choose an option to access advanced trading support:
-
-Services:
-- <b>Technical Analysis</b> - Real-time chart analysis and key levels
-
-- <b>Market Sentiment</b> - Understand market trends and sentiment
-
-- <b>Economic Calendar</b> - Stay updated on market-moving events
-
-- <b>Trading Signals</b> - Get precise entry/exit points for your favorite pairs
-
-Select your option to continue:
-"""
-
-# Abonnementsbericht voor nieuwe gebruikers
-SUBSCRIPTION_WELCOME_MESSAGE = r"""
-<b>Welcome to Sigmapips AI!</b>
-
-To access all features, you need a subscription:
-
-<b>Trading Signals Subscription - $29.99/month</b>
-- Access to all trading signals (Forex, Crypto, Commodities, Indices)
-- Advanced timeframe analysis
-- Detailed chart analysis for each signal
-
-Click the button below to subscribe:
-"""
-
-MENU_MESSAGE = r"""
-Welcome to Sigmapips AI!
-
-Choose a command:
-
-/start - Set up new trading pairs
-Add new market/instrument/timeframe combinations to receive signals
-
-/manage - Manage your preferences
-View, edit or delete your saved trading pairs
-
-Need help? Use /help to see all available commands.
-"""
-
-HELP_MESSAGE = r"""
-Available commands:
-/menu - Show main menu
-/start - Set up new trading pairs
-/help - Show this help message
-"""
-
-# Start menu keyboard
-START_KEYBOARD = [
-    [InlineKeyboardButton("Analyze Market", callback_data=CALLBACK_MENU_ANALYSE)],
-    [InlineKeyboardButton("Trading Signals", callback_data=CALLBACK_MENU_SIGNALS)]
-]
-
-# Analysis menu keyboard
-ANALYSIS_KEYBOARD = [
-    [InlineKeyboardButton("Technical Analysis", callback_data=CALLBACK_ANALYSIS_TECHNICAL)],
-    [InlineKeyboardButton("Market Sentiment", callback_data=CALLBACK_ANALYSIS_SENTIMENT)],
-    [InlineKeyboardButton("Economic Calendar", callback_data=CALLBACK_ANALYSIS_CALENDAR)],
-    [InlineKeyboardButton("Back", callback_data=CALLBACK_BACK_MENU)]
-]
-
-# Signals menu keyboard
-SIGNALS_KEYBOARD = [
-    [InlineKeyboardButton("Add New Pairs", callback_data=CALLBACK_SIGNALS_ADD)],
-    [InlineKeyboardButton("Manage Signals", callback_data=CALLBACK_SIGNALS_MANAGE)],
-    [InlineKeyboardButton("Back", callback_data=CALLBACK_BACK_MENU)]
-]
-
-# Market keyboard voor signals
-MARKET_KEYBOARD_SIGNALS = [
-    [InlineKeyboardButton("Forex", callback_data="market_forex_signals")],
-    [InlineKeyboardButton("Crypto", callback_data="market_crypto_signals")],
-    [InlineKeyboardButton("Commodities", callback_data="market_commodities_signals")],
-    [InlineKeyboardButton("Indices", callback_data="market_indices_signals")],
-    [InlineKeyboardButton("Back", callback_data="back_signals")]
-]
-
-# Market keyboard voor analyse
-MARKET_KEYBOARD = [
-    [InlineKeyboardButton("Forex", callback_data="market_forex")],
-    [InlineKeyboardButton("Crypto", callback_data="market_crypto")],
-    [InlineKeyboardButton("Commodities", callback_data="market_commodities")],
-    [InlineKeyboardButton("Indices", callback_data="market_indices")],
-    [InlineKeyboardButton("Back", callback_data="back_analysis")]
-]
-
-# Market keyboard specifiek voor sentiment analyse
-MARKET_SENTIMENT_KEYBOARD = [
-    [InlineKeyboardButton("Forex", callback_data="market_forex_sentiment")],
-    [InlineKeyboardButton("Crypto", callback_data="market_crypto_sentiment")],
-    [InlineKeyboardButton("Commodities", callback_data="market_commodities_sentiment")],
-    [InlineKeyboardButton("Indices", callback_data="market_indices_sentiment")],
-    [InlineKeyboardButton("Back", callback_data="back_analysis")]
-]
-
-# Forex keyboard voor technical analyse
-FOREX_KEYBOARD = [
-    [
-        InlineKeyboardButton("EURUSD", callback_data="instrument_EURUSD_chart"),
-        InlineKeyboardButton("GBPUSD", callback_data="instrument_GBPUSD_chart"),
-        InlineKeyboardButton("USDJPY", callback_data="instrument_USDJPY_chart")
-    ],
-    [
-        InlineKeyboardButton("AUDUSD", callback_data="instrument_AUDUSD_chart"),
-        InlineKeyboardButton("USDCAD", callback_data="instrument_USDCAD_chart"),
-        InlineKeyboardButton("EURGBP", callback_data="instrument_EURGBP_chart")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Forex keyboard voor sentiment analyse
-FOREX_SENTIMENT_KEYBOARD = [
-    [
-        InlineKeyboardButton("EURUSD", callback_data="instrument_EURUSD_sentiment"),
-        InlineKeyboardButton("GBPUSD", callback_data="instrument_GBPUSD_sentiment"),
-        InlineKeyboardButton("USDJPY", callback_data="instrument_USDJPY_sentiment")
-    ],
-    [
-        InlineKeyboardButton("AUDUSD", callback_data="instrument_AUDUSD_sentiment"),
-        InlineKeyboardButton("USDCAD", callback_data="instrument_USDCAD_sentiment"),
-        InlineKeyboardButton("EURGBP", callback_data="instrument_EURGBP_sentiment")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Forex keyboard voor kalender analyse
-FOREX_CALENDAR_KEYBOARD = [
-    [
-        InlineKeyboardButton("EURUSD", callback_data="instrument_EURUSD_calendar"),
-        InlineKeyboardButton("GBPUSD", callback_data="instrument_GBPUSD_calendar"),
-        InlineKeyboardButton("USDJPY", callback_data="instrument_USDJPY_calendar")
-    ],
-    [
-        InlineKeyboardButton("AUDUSD", callback_data="instrument_AUDUSD_calendar"),
-        InlineKeyboardButton("USDCAD", callback_data="instrument_USDCAD_calendar"),
-        InlineKeyboardButton("EURGBP", callback_data="instrument_EURGBP_calendar")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Crypto keyboard voor analyse
-CRYPTO_KEYBOARD = [
-    [
-        InlineKeyboardButton("BTCUSD", callback_data="instrument_BTCUSD_chart"),
-        InlineKeyboardButton("ETHUSD", callback_data="instrument_ETHUSD_chart"),
-        InlineKeyboardButton("XRPUSD", callback_data="instrument_XRPUSD_chart")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Signal analysis keyboard
-SIGNAL_ANALYSIS_KEYBOARD = [
-    [InlineKeyboardButton("Technical Analysis", callback_data="signal_technical")],
-    [InlineKeyboardButton("Market Sentiment", callback_data="signal_sentiment")],
-    [InlineKeyboardButton("Economic Calendar", callback_data="signal_calendar")],
-    [InlineKeyboardButton("Back", callback_data="back_to_signal")]
-]
-
-# Crypto keyboard voor sentiment analyse
-CRYPTO_SENTIMENT_KEYBOARD = [
-    [
-        InlineKeyboardButton("BTCUSD", callback_data="instrument_BTCUSD_sentiment"),
-        InlineKeyboardButton("ETHUSD", callback_data="instrument_ETHUSD_sentiment"),
-        InlineKeyboardButton("XRPUSD", callback_data="instrument_XRPUSD_sentiment")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Indices keyboard voor analyse
-INDICES_KEYBOARD = [
-    [
-        InlineKeyboardButton("US30", callback_data="instrument_US30_chart"),
-        InlineKeyboardButton("US500", callback_data="instrument_US500_chart"),
-        InlineKeyboardButton("US100", callback_data="instrument_US100_chart")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Indices keyboard voor signals - Fix de "Terug" knop naar "Back"
-INDICES_KEYBOARD_SIGNALS = [
-    [
-        InlineKeyboardButton("US30", callback_data="instrument_US30_signals"),
-        InlineKeyboardButton("US500", callback_data="instrument_US500_signals"),
-        InlineKeyboardButton("US100", callback_data="instrument_US100_signals")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Commodities keyboard voor analyse
-COMMODITIES_KEYBOARD = [
-    [
-        InlineKeyboardButton("GOLD", callback_data="instrument_XAUUSD_chart"),
-        InlineKeyboardButton("SILVER", callback_data="instrument_XAGUSD_chart"),
-        InlineKeyboardButton("OIL", callback_data="instrument_USOIL_chart")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Commodities keyboard voor signals - Fix de "Terug" knop naar "Back"
-COMMODITIES_KEYBOARD_SIGNALS = [
-    [
-        InlineKeyboardButton("XAUUSD", callback_data="instrument_XAUUSD_signals"),
-        InlineKeyboardButton("XAGUSD", callback_data="instrument_XAGUSD_signals"),
-        InlineKeyboardButton("USOIL", callback_data="instrument_USOIL_signals")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Forex keyboard for signals
-FOREX_KEYBOARD_SIGNALS = [
-    [
-        InlineKeyboardButton("EURUSD", callback_data="instrument_EURUSD_signals"),
-        InlineKeyboardButton("GBPUSD", callback_data="instrument_GBPUSD_signals"),
-        InlineKeyboardButton("USDJPY", callback_data="instrument_USDJPY_signals")
-    ],
-    [
-        InlineKeyboardButton("USDCAD", callback_data="instrument_USDCAD_signals"),
-        InlineKeyboardButton("EURGBP", callback_data="instrument_EURGBP_signals")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Crypto keyboard for signals
-CRYPTO_KEYBOARD_SIGNALS = [
-    [
-        InlineKeyboardButton("BTCUSD", callback_data="instrument_BTCUSD_signals"),
-        InlineKeyboardButton("ETHUSD", callback_data="instrument_ETHUSD_signals"),
-        InlineKeyboardButton("XRPUSD", callback_data="instrument_XRPUSD_signals")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Indices keyboard voor sentiment analyse
-INDICES_SENTIMENT_KEYBOARD = [
-    [
-        InlineKeyboardButton("US30", callback_data="instrument_US30_sentiment"),
-        InlineKeyboardButton("US500", callback_data="instrument_US500_sentiment"),
-        InlineKeyboardButton("US100", callback_data="instrument_US100_sentiment")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Commodities keyboard voor sentiment analyse
-COMMODITIES_SENTIMENT_KEYBOARD = [
-    [
-        InlineKeyboardButton("GOLD", callback_data="instrument_XAUUSD_sentiment"),
-        InlineKeyboardButton("SILVER", callback_data="instrument_XAGUSD_sentiment"),
-        InlineKeyboardButton("OIL", callback_data="instrument_USOIL_sentiment")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Style keyboard
-STYLE_KEYBOARD = [
-    [InlineKeyboardButton("‚ö° Test (one_min)", callback_data="style_test")],
-    [InlineKeyboardButton("üèÉ Scalp (fifteen_min)", callback_data="style_scalp")],
-    [InlineKeyboardButton(" Intraday (one_hour)", callback_data="style_intraday")],
-    [InlineKeyboardButton("üåä Swing (four_hour)", callback_data="style_swing")],
-    [InlineKeyboardButton("Back", callback_data="back_instrument")]
-]
-
-# Timeframe mapping
-STYLE_TIMEFRAME_MAP = {
-    "test": "one_min",
-    "scalp": "fifteen_min",
-    "intraday": "one_hour",
-    "swing": "four_hour"
-}
-
-# Mapping of instruments to their allowed timeframes - updated 2023-03-23
-INSTRUMENT_TIMEFRAME_MAP = {
-    # H1 timeframe only
-    "AUDJPY": "H1", 
-    "AUDCHF": "H1",
-    "EURCAD": "H1",
-    "EURGBP": "H1",
-    "GBPCHF": "H1",
-    "HK50": "H1",
-    "NZDJPY": "H1",
-    "USDCHF": "H1",
-    "USDJPY": "H1",  # USDJPY toegevoegd voor signaalabonnementen
-    "XRPUSD": "H1",
-    
-    # H4 timeframe only
-    "AUDCAD": "H4",
-    "AU200": "H4", 
-    "CADCHF": "H4",
-    "EURCHF": "H4",
-    "EURUSD": "H4",
-    "GBPCAD": "H4",
-    "LINKUSD": "H4",
-    "NZDCHF": "H4",
-    
-    # M15 timeframe only
-    "DOGEUSD": "M15",
-    "GBPNZD": "M15",
-    "NZDUSD": "M15",
-    "SOLUSD": "M15",
-    "UK100": "M15",
-    "XAUUSD": "M15",
-    
-    # M30 timeframe only
-    "BNBUSD": "M30",
-    "DOTUSD": "M30",
-    "ETHUSD": "M30",
-    "EURAUD": "M30",
-    "EURJPY": "M30",
-    "GBPAUD": "M30",
-    "GBPUSD": "M30",
-    "NZDCAD": "M30",
-    "US30": "M30",
-    "US500": "M30",
-    "USDCAD": "M30",
-    "XLMUSD": "M30",
-    "XTIUSD": "M30",
-    "DE40": "M30",
-    "BTCUSD": "M30",  # Added for consistency with CRYPTO_KEYBOARD_SIGNALS
-    "US100": "M30",   # Added for consistency with INDICES_KEYBOARD_SIGNALS
-    "XAGUSD": "M15",  # Added for consistency with COMMODITIES_KEYBOARD_SIGNALS
-    "USOIL": "M30"    # Added for consistency with COMMODITIES_KEYBOARD_SIGNALS
-    
-    # Removed as requested: EU50, FR40, LTCUSD
-}
-
-# Map common timeframe notations
-TIMEFRAME_DISPLAY_MAP = {
-    "M15": "15 Minutes",
-    "M30": "30 Minutes", 
-    "H1": "1 Hour",
-    "H4": "4 Hours"
-}
-
-# Voeg deze functie toe aan het begin van bot.py, na de imports
-def _detect_market(instrument: str) -> str:
-    """Detecteer market type gebaseerd op instrument"""
-    instrument = instrument.upper()
-    
-    # Commodities eerst checken
-    commodities = [
-        "XAUUSD",  # Gold
-        "XAGUSD",  # Silver
-        "WTIUSD",  # Oil WTI
-        "BCOUSD",  # Oil Brent
-        "USOIL",   # Oil WTI (alternative symbol)
-    ]
-    if instrument in commodities:
-        logger.info(f"Detected {instrument} as commodity")
-        return "commodities"
-    
-    # Crypto pairs
-    crypto_base = ["BTC", "ETH", "XRP", "SOL", "BNB", "ADA", "DOT", "LINK"]
-    if any(c in instrument for c in crypto_base):
-        logger.info(f"Detected {instrument} as crypto")
-        return "crypto"
-    
-    # Major indices
-    indices = [
-        "US30", "US500", "US100",  # US indices
-        "UK100", "DE40", "FR40",   # European indices
-        "JP225", "AU200", "HK50"   # Asian indices
-    ]
-    if instrument in indices:
-        logger.info(f"Detected {instrument} as index")
-        return "indices"
-    
-    # Forex pairs als default
-    logger.info(f"Detected {instrument} as forex")
-    return "forex"
-
-# Voeg dit toe als decorator functie bovenaan het bestand na de imports
-def require_subscription(func):
-    """Check if user has an active subscription"""
-    async def wrapper(self, update: Update, context: ContextTypes.DEFAULT_TYPE, *args, **kwargs):
-        user_id = update.effective_user.id
-        
-        # Check subscription status
-        is_subscribed = await self.db.is_user_subscribed(user_id)
-        
-        # Check if payment has failed
-        payment_failed = await self.db.has_payment_failed(user_id)
-        
-        if is_subscribed and not payment_failed:
-            # User has subscription, proceed with function
-            return await func(self, update, context, *args, **kwargs)
-        else:
-            if payment_failed:
-                # Show payment failure message
-                failed_payment_text = f"""
- <b>Subscription Payment Failed</b> 
-
-Your subscription payment could not be processed and your service has been deactivated.
-
-To continue using Sigmapips AI and receive trading signals, please reactivate your subscription by clicking the button below.
-                """
-                
-                # Use direct URL link for reactivation
-                reactivation_url = "https://buy.stripe.com/9AQcPf3j63HL5JS145"
-                
-                # Create button for reactivation
-                keyboard = [
-                    [InlineKeyboardButton("üîÑ Reactivate Subscription", url=reactivation_url)]
-                ]
-            else:
-                # Show subscription screen with the welcome message from the screenshot
-                failed_payment_text = f"""
- <b>Welcome to Sigmapips AI!</b> 
-
-<b>Discover powerful trading signals for various markets:</b>
-- <b>Forex</b> - Major and minor currency pairs
-- <b>Crypto</b> - Bitcoin, Ethereum and other top cryptocurrencies
-- <b>Indices</b> - Global market indices
-- <b>Commodities</b> - Gold, silver and oil
-
-<b>Features:</b>
- Real-time trading signals
-
- Multi-timeframe analysis (timeframes)
-
- Advanced chart analysis
-
- Sentiment indicators
-
- Economic calendar integration
-
-<b>Start today with a FREE 14-day trial!</b>
-                """
-                
-                # Use direct URL link instead of callback for the trial button
-                reactivation_url = "https://buy.stripe.com/3cs3eF9Hu9256NW9AA"
-                
-                # Create button for trial
-                keyboard = [
-                    [InlineKeyboardButton("üî• Start 14-day FREE Trial", url=reactivation_url)]
-                ]
-            
-            # Handle both message and callback query updates
-            if update.callback_query:
-                await update.callback_query.answer()
-                await update.callback_query.edit_message_text(
-                    text=failed_payment_text,
-                    reply_markup=InlineKeyboardMarkup(keyboard),
-                    parse_mode=ParseMode.HTML
-                )
-            else:
-                await update.message.reply_text(
-                    text=failed_payment_text,
-                    reply_markup=InlineKeyboardMarkup(keyboard),
-                    parse_mode=ParseMode.HTML
-                )
-            return MENU
-    
-    return wrapper
-
-# API keys with robust sanitization
-PERPLEXITY_API_KEY = os.getenv("PERPLEXITY_API_KEY", "").strip()
-OPENAI_API_KEY = os.getenv("OPENAI_API_KEY", "").strip()  # Changed from DeepSeek to OpenAI
-
-# Only using OpenAI's o4-mini now
-# No Tavily API key needed anymore
-logger.info("Using only OpenAI o4-mini for Market Sentiment service")
-
-# Log OpenAI API key (partially masked)
-if OPENAI_API_KEY:
-    # Better masking for privacy and security
-    masked_key = f"sk-p...{OPENAI_API_KEY[-4:]}" if len(OPENAI_API_KEY) > 8 else "sk-p..."
-    logger.info(f"Using OpenAI API key: {masked_key}")
-    
-    # Validate the key format
-    from trading_bot.config import validate_openai_key
-    if not validate_openai_key(OPENAI_API_KEY):
-        logger.warning("OpenAI API key format is invalid. AI services may not work correctly.")
-else:
-    logger.warning("No OpenAI API key configured. AI services will be disabled.")
-    
-# Set environment variables for the API keys with sanitization
-os.environ["PERPLEXITY_API_KEY"] = PERPLEXITY_API_KEY
-os.environ["OPENAI_API_KEY"] = OPENAI_API_KEY  # Changed from DeepSeek to OpenAI
-# No Tavily environment needed
-
-class TelegramService:
-    def __init__(self, db: Database, stripe_service=None, bot_token: Optional[str] = None, proxy_url: Optional[str] = None, lazy_init: bool = False):
-        """Initialize the bot with given database and config."""
-        # Database connection
-        self.db = db
-        
-        # Setup configuration 
-        self.stripe_service = stripe_service
-        self.user_signals = {}
-        self.signals_dir = "data/signals"
-        self.signals_enabled_val = True
-        self.polling_started = False
-        self.admin_users = [2004519703]  # Updated with correct Telegram ID from logs
-        self._signals_enabled = True  # Enable signals by default
-        
-        # Setup logger
-        self.logger = logging.getLogger(__name__)
-        
-        # GIF utilities for UI
-        self.gif_utils = gif_utils  # Initialize gif_utils as an attribute
-        
-        # Setup the bot and application
-        self.bot = None
-        self.application = None
-        
-        # Telegram Bot configuratie
-        self.bot_token = bot_token or os.getenv("TELEGRAM_BOT_TOKEN", "")
-        self.token = self.bot_token  # Aliased for backward compatibility
-        self.proxy_url = proxy_url or os.getenv("TELEGRAM_PROXY_URL", "")
-        
-        # Configure custom request handler with improved connection settings
-        request = HTTPXRequest(
-            connection_pool_size=50,  # Increase from 20 to 50
-            connect_timeout=15.0,     # Increase from 10.0 to 15.0
-            read_timeout=45.0,        # Increase from 30.0 to 45.0
-            write_timeout=30.0,       # Increase from 20.0 to 30.0
-            pool_timeout=60.0,        # Increase from 30.0 to 60.0
-        )
-        
-        # Initialize the bot directly with connection pool settings
-        self.bot = Bot(token=self.bot_token, request=request)
-        self.application = None  # Will be initialized in setup()
-        
-        # Webhook configuration
-        self.webhook_url = os.getenv("WEBHOOK_URL", "")
-        self.webhook_path = "/webhook"  # Always use this path
-        if self.webhook_url.endswith("/"):
-            self.webhook_url = self.webhook_url[:-1]  # Remove trailing slash
-            
-        logger.info(f"Bot initialized with webhook URL: {self.webhook_url} and path: {self.webhook_path}")
-        
-        # Initialize API services
-        self.chart_service = ChartService()  # Initialize chart service
-        # Lazy load services only when needed
-        self._calendar_service = None
-        self._sentiment_service = None
-        
-        # Don't use asyncio.create_task here - it requires a running event loop
-        # We'll initialize chart service later when the event loop is running
-        
-        # Bot application initialization
-        self.persistence = None
-        self.bot_started = False
-        
-        # Cache for sentiment analysis
-        self.sentiment_cache = {}
-        self.sentiment_cache_ttl = 60 * 60  # 1 hour in seconds
-        
-        # Start the bot
-    try:
-            # Check for bot token
-            if not self.bot_token:
-                raise ValueError("Missing Telegram bot token")
-            
-            # Initialize the bot
-            self.bot = Bot(token=self.bot_token)
-        
-            # Initialize the application
-            self.application = Application.builder().bot(self.bot).build()
-        
-            # Register the handlers
-            self._register_handlers(self.application)
-            
-            # Initialize signals dictionary but don't load them yet (will be done in initialize_services)
-            self.user_signals = {}
-        
-            logger.info("Telegram service initialized")
-            
-            # Keep track of processed updates
-            self.processed_updates = set()
-            
-    except Exception as e:
-        logger.error(f"Error initializing Telegram service: {str(e)}")
-        raise
-
-    async def initialize_services(self):
-        """Initialize services that require an asyncio event loop"""
-        try:
-            # Initialize chart service
-            await self.chart_service.initialize()
-            logger.info("Chart service initialized")
-            
-            # Load stored signals
-            await self._load_signals()
-            logger.info("Signals loaded")
-            
-            # Schedule periodic cleanup of old signals
-            if hasattr(self, 'db') and self.db and self.db.using_redis:
-                # Run initial cleanup
-                cleaned = await self._cleanup_old_signals(max_age_days=7)
-                logger.info(f"Initial signal cleanup completed, removed {cleaned} old signals")
-                
-                # Schedule periodic cleanup (every 24 hours)
-                async def periodic_cleanup():
-                    while True:
-                        try:
-                            # Wait for 24 hours
-                            await asyncio.sleep(24 * 60 * 60)
-                            # Run cleanup
-                            cleaned = await self._cleanup_old_signals(max_age_days=7)
-                            logger.info(f"Periodic signal cleanup completed, removed {cleaned} old signals")
-                        except Exception as e:
-                            logger.error(f"Error in periodic signal cleanup: {str(e)}")
-                
-                # Start the periodic cleanup task
-                asyncio.create_task(periodic_cleanup())
-                logger.info("Scheduled periodic signal cleanup")
-        except Exception as e:
-            logger.error(f"Error initializing services: {str(e)}")
-            raise
-            
-    # Calendar service helpers
-    @property
-    def calendar_service(self):
-        """Lazy loaded calendar service"""
-        if self._calendar_service is None:
-            # Only initialize the calendar service when it's first accessed
-            self.logger.info("Lazy loading calendar service")
-            self._calendar_service = EconomicCalendarService()
-        return self._calendar_service
-        
-    def _get_calendar_service(self):
-        """Get the calendar service instance"""
-        self.logger.info("Getting calendar service")
-        return self.calendar_service
-
-    async def _format_calendar_events(self, calendar_data):
-        """Format the calendar data into a readable HTML message"""
-        self.logger.info(f"Formatting calendar data with {len(calendar_data)} events")
-        if not calendar_data:
-            return "<b>Economic Calendar</b>\n\nNo economic events found for today."
-        
-        # Sort events by time
-        try:
-            # Try to parse time for sorting
-            def parse_time_for_sorting(event):
-                time_str = event.get('time', '')
-                try:
-                    # Extract hour and minute if in format like "08:30 EST"
-                    if ':' in time_str:
-                        parts = time_str.split(' ')[0].split(':')
-                        hour = int(parts[0])
-                        minute = int(parts[1])
-                        return hour * 60 + minute
-                    return 0
-                except:
-                    return 0
-            
-            # Sort the events by time
-            sorted_events = sorted(calendar_data, key=parse_time_for_sorting)
-        except Exception as e:
-            self.logger.error(f"Error sorting calendar events: {str(e)}")
-            sorted_events = calendar_data
-        
-        # Format the message
-        message = "<b>Economic Calendar</b>\n\n"
-        
-        # Get current date
-        current_date = datetime.now().strftime("%B %d, %Y")
-        message += f"<b>Date:</b> {current_date}\n\n"
-        
-        # Add impact legend
-        message += "<b>Impact:</b> üî¥ High   üü† Medium   üü¢ Low\n\n"
-        
-        # Group events by country
-        events_by_country = {}
-        for event in sorted_events:
-            country = event.get('country', 'Unknown')
-            if country not in events_by_country:
-                events_by_country[country] = []
-            events_by_country[country].append(event)
-        
-        # Format events by country
-        for country, events in events_by_country.items():
-            country_flag = CURRENCY_FLAG.get(country, '')
-            message += f"<b>{country_flag} {country}</b>\n"
-            
-            for event in events:
-                time = event.get('time', 'TBA')
-                title = event.get('title', 'Unknown Event')
-                impact = event.get('impact', 'Low')
-                impact_emoji = {'High': 'üî¥', 'Medium': 'üü†', 'Low': 'üü¢'}.get(impact, 'üü¢')
-                
-                message += f"{time} - {impact_emoji} {title}\n"
-            
-            message += "\n"  # Add extra newline between countries
-        
-        return message
-        
-    # Utility functions that might be missing
-    async def update_message(self, query, text, keyboard=None, parse_mode=ParseMode.HTML):
-        """Utility to update a message with error handling"""
-        try:
-            # Check if the message is too long for Telegram caption limits (1024 chars)
-            MAX_CAPTION_LENGTH = 1000  # Slightly under the 1024 limit for safety
-            MAX_MESSAGE_LENGTH = 4000  # Telegram message limit
-            
-            # Log message length for debugging
-            logger.info(f"Updating message (length: {len(text)} chars)")
-            
-            # If message is too long for a caption but ok for a text message
-            if len(text) > MAX_CAPTION_LENGTH and len(text) <= MAX_MESSAGE_LENGTH:
-                logger.info("Message too long for caption but ok for text message")
-                # Try to edit message text first
-                await query.edit_message_text(
-                    text=text,
-                    reply_markup=keyboard,
-                    parse_mode=parse_mode
-                )
-                return True
-            # If message is too long even for a text message
-            elif len(text) > MAX_MESSAGE_LENGTH:
-                logger.warning(f"Message too long ({len(text)} chars), truncating")
-                # Find a good breaking point
-                truncated = text[:MAX_MESSAGE_LENGTH-100]
-                
-                # Try to break at a paragraph
-                last_newline = truncated.rfind('\n\n')
-                if last_newline > MAX_MESSAGE_LENGTH * 0.8:  # If we can keep at least 80% of the text
-                    truncated = truncated[:last_newline]
-                    
-                # Add indicator that text was truncated
-                truncated += "\n\n<i>... (message truncated)</i>"
-                
-                # Try to edit message text with truncated content
-                await query.edit_message_text(
-                    text=truncated,
-                    reply_markup=keyboard,
-                    parse_mode=parse_mode
-                )
-                return True
-            else:
-                # Normal case - message is within limits
-                # Try to edit message text first
-                await query.edit_message_text(
-                    text=text,
-                    reply_markup=keyboard,
-                    parse_mode=parse_mode
-                )
-                return True
-        except Exception as e:
-            logger.warning(f"Could not update message text: {str(e)}")
-            
-            # If text update fails, try to edit caption
-            try:
-                # Check if caption is too long
-                MAX_CAPTION_LENGTH = 1000  # Slightly under the 1024 limit for safety
-                
-                if len(text) > MAX_CAPTION_LENGTH:
-                    logger.warning(f"Caption too long ({len(text)} chars), truncating")
-                    # Find a good breaking point
-                    truncated = text[:MAX_CAPTION_LENGTH-100]
-                    
-                    # Try to break at a paragraph
-                    last_newline = truncated.rfind('\n\n')
-                    if last_newline > MAX_CAPTION_LENGTH * 0.8:  # If we can keep at least 80% of the text
-                        truncated = truncated[:last_newline]
-                        
-                    # Add indicator that text was truncated
-                    truncated += "\n\n<i>... (message truncated)</i>"
-                    
-                    # Use truncated text for caption
-                    await query.edit_message_caption(
-                        caption=truncated,
-                        reply_markup=keyboard,
-                        parse_mode=parse_mode
-                    )
-                else:
-                    # Caption is within limits
-                    await query.edit_message_caption(
-                        caption=text,
-                        reply_markup=keyboard,
-                        parse_mode=parse_mode
-                    )
-                return True
-            except Exception as e2:
-                logger.error(f"Could not update caption either: {str(e2)}")
-                
-                # As a last resort, send a new message
-                try:
-                    chat_id = query.message.chat_id
-                    
-                    # Check if message is too long
-                    MAX_MESSAGE_LENGTH = 4000  # Telegram message limit
-                    
-                    if len(text) > MAX_MESSAGE_LENGTH:
-                        logger.warning(f"New message too long ({len(text)} chars), truncating")
-                        # Find a good breaking point
-                        truncated = text[:MAX_MESSAGE_LENGTH-100]
-                        
-                        # Try to break at a paragraph
-                        last_newline = truncated.rfind('\n\n')
-                        if last_newline > MAX_MESSAGE_LENGTH * 0.8:  # If we can keep at least 80% of the text
-                            truncated = truncated[:last_newline]
-                            
-                        # Add indicator that text was truncated
-                        truncated += "\n\n<i>... (message truncated)</i>"
-                        
-                        # Use truncated text for new message
-                        await query.bot.send_message(
-                            chat_id=chat_id,
-                            text=truncated,
-                            reply_markup=keyboard,
-                            parse_mode=parse_mode
-                        )
-                    else:
-                        # Message is within limits
-                        await query.bot.send_message(
-                            chat_id=chat_id,
-                            text=text,
-                            reply_markup=keyboard,
-                            parse_mode=parse_mode
-                        )
-                    return True
-                except Exception as e3:
-                    logger.error(f"Failed to send new message: {str(e3)}")
-                    return False
-    
-    # Missing handler implementations
-    async def back_signals_callback(self, update: Update, context=None) -> int:
-        """Handle back_signals button press"""
-        query = update.callback_query
-        await query.answer()
-        
-        logger.info("back_signals_callback called")
-        
-        # Make sure we're in the signals flow context
-        if context and hasattr(context, 'user_data'):
-            # Reset signal flow flags
-            context.user_data['from_signal'] = False
-            context.user_data['in_signal_flow'] = False
-            logger.info(f"Reset signal flow flags: from_signal=False, in_signal_flow=False")
-            # Keep is_signals_context flag but reset from_signal flag
-            context.user_data['is_signals_context'] = True
-            context.user_data['from_signal'] = False
-            
-            # Clear other specific analysis keys but maintain signals context
-            keys_to_remove = [
-                'instrument', 'market', 'analysis_type', 'timeframe', 
-                'signal_id', 'signal_instrument', 'signal_direction', 'signal_timeframe',
-                'loading_message'
-            ]
-
-            for key in keys_to_remove:
-                if key in context.user_data:
-                    del context.user_data[key]
-            logger.info(f"Updated context in back_signals_callback: {context.user_data}")
-        
-        # Create keyboard for signal menu
-        keyboard = [
-            [InlineKeyboardButton(" Add Signal", callback_data="signals_add")],
-            [InlineKeyboardButton("Manage Signals", callback_data="signals_manage")],
-            [InlineKeyboardButton("Back to Menu", callback_data="back_menu")]
-        ]
-        reply_markup = InlineKeyboardMarkup(keyboard)
-        
-        # Get the signals GIF URL for better UX
-        signals_gif_url = "https://media.giphy.com/media/gSzIKNrqtotEYrZv7i/giphy.gif"
-        
-        # Update the message
-        await self.update_message(
-            query=query,            text="<b> Signal Management</b>\n\nManage your trading signals",
-
-
-            keyboard=reply_markup
-        )
-        
-        return SIGNALS
-        
-    async def get_subscribers_for_instrument(self, instrument: str, timeframe: str = None) -> List[int]:
-        """
-        Get a list of subscribed user IDs for a specific instrument and timeframe
-        
-        Args:
-            instrument: The trading instrument (e.g., EURUSD)
-            timeframe: Optional timeframe filter
-            
-        Returns:
-            List of subscribed user IDs
-        """
-    try:
-            logger.info(f"Getting subscribers for {instrument} timeframe: {timeframe}")
-            
-            # Get all subscribers from the database
-            # Note: Using get_signal_subscriptions instead of find_all
-            subscribers = await self.db.get_signal_subscriptions(instrument, timeframe)
-            
-            if not subscribers:
-                logger.warning(f"No subscribers found for {instrument}")
-                return []
-                
-            # Filter out subscribers that don't have an active subscription
-            active_subscribers = []
-            for subscriber in subscribers:
-                user_id = subscriber['user_id']
-                
-                # Check if user is subscribed
-                is_subscribed = await self.db.is_user_subscribed(user_id)
-                
-                # Check if payment has failed
-                payment_failed = await self.db.has_payment_failed(user_id)
-                
-                if is_subscribed and not payment_failed:
-                    active_subscribers.append(user_id)
-                else:
-                    logger.info(f"User {user_id} doesn't have an active subscription, skipping signal")
-            
-            return active_subscribers
-            
-    except Exception as e:
-        logger.error(f"Error getting subscribers: {str(e)}")
-        # FOR TESTING: Add admin users if available
-        if hasattr(self, 'admin_users') and self.admin_users:
-            logger.info(f"Returning admin users for testing: {self.admin_users}")
-            return self.admin_users
-        return []
-
-    async def process_signal(self, signal_data: Dict[str, Any]) -> bool:
-        """
-        Process a trading signal from TradingView webhook or API
-        
-        Supports two formats:
-        1. TradingView format: instrument, signal, price, sl, tp1, tp2, tp3, interval
-        2. Custom format: instrument, direction, entry, stop_loss, take_profit, timeframe
-        
-        Returns:
-            bool: True if signal was processed successfully, False otherwise
-        """
-        try:
-            # Log the incoming signal data
-            logger.info(f"Processing signal: {signal_data}")
-            
-            # Check which format we're dealing with and normalize it
-            instrument = signal_data.get('instrument')
-            
-            # Handle TradingView format (price, sl, interval)
-            if 'price' in signal_data and 'sl' in signal_data:
-                price = signal_data.get('price')
-                sl = signal_data.get('sl')
-                tp1 = signal_data.get('tp1')
-                tp2 = signal_data.get('tp2')
-                tp3 = signal_data.get('tp3')
-                interval = signal_data.get('interval', 'one_hour')
-                
-                # Determine signal direction based on price and SL relationship
-                direction = "BUY" if float(sl) < float(price) else "SELL"
-                
-                # Create normalized signal data
-                normalized_data = {
-                    'instrument': instrument,
-                    'direction': direction,
-                    'entry': price,
-                    'stop_loss': sl,
-                    'take_profit': tp1,  # Use first take profit level
-                    'timeframe': interval
-                }
-                
-                # Add optional fields if present
-                normalized_data['tp1'] = tp1
-                normalized_data['tp2'] = tp2
-                normalized_data['tp3'] = tp3
-                
-            # Handle custom format (direction, entry, stop_loss, timeframe)
-            elif 'direction' in signal_data and 'entry' in signal_data:
-                direction = signal_data.get('direction')
-                entry = signal_data.get('entry')
-                stop_loss = signal_data.get('stop_loss')
-                take_profit = signal_data.get('take_profit')
-                timeframe = signal_data.get('timeframe', 'one_hour')
-                
-                # Create normalized signal data
-                normalized_data = {
-                    'instrument': instrument,
-                    'direction': direction,
-                    'entry': entry,
-                    'stop_loss': stop_loss,
-                    'take_profit': take_profit,
-                    'timeframe': timeframe
-                }
-            else:
-                logger.error(f"Missing required signal data")
-                return False
-            
-            # Basic validation
-            if not normalized_data.get('instrument') or not normalized_data.get('direction') or not normalized_data.get('entry'):
-                logger.error(f"Missing required fields in normalized signal data: {normalized_data}")
-                return False
-                
-            # Create signal ID for tracking
-            signal_id = f"{normalized_data['instrument']}_{normalized_data['direction']}_{normalized_data['timeframe']}_{int(time.time())}"
-            
-            # Format the signal message
-            message = self._format_signal_message(normalized_data)
-            
-            # Determine market type for the instrument
-            market_type = _detect_market(instrument)
-            
-            # Store the full signal data for reference
-            normalized_data['id'] = signal_id
-            normalized_data['timestamp'] = datetime.now().isoformat()
-            normalized_data['message'] = message
-            normalized_data['market'] = market_type
-            
-            # Save signal for history tracking
-            if not os.path.exists(self.signals_dir):
-                os.makedirs(self.signals_dir, exist_ok=True)
-                
-            # Save to signals directory
-            with open(f"{self.signals_dir}/{signal_id}.json", 'w') as f:
-                json.dump(normalized_data, f)
-            
-            # FOR TESTING: Always send to admin for testing
-            if hasattr(self, 'admin_users') and self.admin_users:
-                try:
-                    logger.info(f"Sending signal to admin users for testing: {self.admin_users}")
-                    for admin_id in self.admin_users:
-                        # Prepare keyboard with analysis options
-                        keyboard = [
-                            [InlineKeyboardButton("Analyze Market", callback_data=f"analyze_from_signal_{instrument}_{signal_id}")]
-                        ]
-                        
-                        # Send the signal
-                        await self.bot.send_message(
-                            chat_id=admin_id,
-                            text=message,
-                            parse_mode=ParseMode.HTML,
-                            reply_markup=InlineKeyboardMarkup(keyboard)
-                        )
-                        logger.info(f"Test signal sent to admin {admin_id}")
-                        
-                        # Store signal reference for quick access
-                        if not hasattr(self, 'user_signals'):
-                            self.user_signals = {}
-                            
-                        admin_str_id = str(admin_id)
-                        if admin_str_id not in self.user_signals:
-                            self.user_signals[admin_str_id] = {}
-                        
-                        self.user_signals[admin_str_id][signal_id] = normalized_data
-            except Exception as e:
-                logger.error(f"Error sending test signal to admin: {str(e)}")
-            
-            # Get subscribers for this instrument
-            timeframe = normalized_data.get('timeframe', 'one_hour')
-            subscribers = await self.get_subscribers_for_instrument(instrument, timeframe)
-            
-            if not subscribers:
-                logger.warning(f"No subscribers found for {instrument}")
-                return True  # Successfully processed, just no subscribers
-            
-            # Send signal to all subscribers
-            logger.info(f"Sending signal {signal_id} to {len(subscribers)} subscribers")
-            
-            sent_count = 0
-            for user_id in subscribers:
-                try:
-                    # Prepare keyboard with analysis options
-                    keyboard = [
-                        [InlineKeyboardButton("Analyze Market", callback_data=f"analyze_from_signal_{instrument}_{signal_id}")]
-                    ]
-                    
-                    # Send the signal
-                    await self.bot.send_message(
-                        chat_id=user_id,
-                        text=message,
-                        parse_mode=ParseMode.HTML,
-                        reply_markup=InlineKeyboardMarkup(keyboard)
-                    )
-                    
-                    sent_count += 1
-                    
-                    # Store signal reference for quick access
-                    if not hasattr(self, 'user_signals'):
-                        self.user_signals = {}
-                        
-                    user_str_id = str(user_id)
-                    if user_str_id not in self.user_signals:
-                        self.user_signals[user_str_id] = {}
-                    
-                    self.user_signals[user_str_id][signal_id] = normalized_data
-                    
-            except Exception as e:
-                logger.error(f"Error sending signal to user {user_id}: {str(e)}")
-            
-            logger.info(f"Successfully sent signal {signal_id} to {sent_count}/{len(subscribers)} subscribers")
-            return True
-            
-    except Exception as e:
-        logger.error(f"Error processing signal: {str(e)}")
-        logger.exception(e)
-            return False
-
-    def _format_signal_message(self, signal_data: Dict[str, Any]) -> str:
-        """Format signal data into a nice message for Telegram"""
-    try:
-            # Extract fields from signal data
-            instrument = signal_data.get('instrument', 'Unknown')
-            direction = signal_data.get('direction', 'Unknown')
-            entry = signal_data.get('entry', 'Unknown')
-            stop_loss = signal_data.get('stop_loss')
-            take_profit = signal_data.get('take_profit')
-            timeframe = signal_data.get('timeframe', 'one_hour')
-            
-            # Get multiple take profit levels if available
-            tp1 = signal_data.get('tp1', take_profit)
-            tp2 = signal_data.get('tp2')
-            tp3 = signal_data.get('tp3')
-            
-            # Add emoji based on direction
-            direction_emoji = "üü¢" if direction.upper() == "BUY" else "üî¥"
-            
-            # Format the message with multiple take profits if available
-            message = "<b> New Trading Signal </b>\n"
-\n"
-            message += f"<b>Instrument:</b> {instrument}\n"
-            message += f"<b>Action:</b> {direction.upper()} {direction_emoji}
-\n"
-            message += f"<b>Entry Price:</b> {entry}\n"
-            
-            if stop_loss:
-                message += f"<b>Stop Loss:</b> {stop_loss} üî¥\n"
-            
-            # Add take profit levels
-            if tp1:
-                message += f"<b>Take Profit 1:</b> {tp1} \n"
-            if tp2:
-                message += f"<b>Take Profit 2:</b> {tp2} \n"
-            if tp3:
-                message += f"<b>Take Profit 3:</b> {tp3} \n"
-            
-            message += f"
-<b>Timeframe:</b> {timeframe}\n"
-            message += f"<b>Strategy:</b> TradingView Signal
-\n"
-            
-            message += "‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
-
-"
-            message += "<b>Risk Management:</b>\n"
-            message += "- Position size: 1-2% max\n"
-            message += "- Use proper stop loss\n"
-            message += "- Follow your trading plan
-
-"
-            
-            message += "‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
-
-"
-            
-            # Generate AI verdict
-            ai_verdict = f"The {instrument} {direction.lower()} signal shows a promising setup with defined entry at {entry} and stop loss at {stop_loss}. Multiple take profit levels provide opportunities for partial profit taking."
-            message += f"<b>ü§ñ SigmaPips AI Verdict:</b>\n{ai_verdict}"
-            
-            return message
-            
-    except Exception as e:
-        logger.error(f"Error formatting signal message: {str(e)}")
-            # Return simple message on error
-            return f"New {signal_data.get('instrument', 'Unknown')} {signal_data.get('direction', 'Unknown')} Signal"
-
-    def _register_handlers(self, application):
-        """Register event handlers for bot commands and callback queries"""
-    try:
-            logger.info("Registering command handlers")
-            
-            # Initialize the application without using run_until_complete
-        try:
-                # Instead of using loop.run_until_complete, directly call initialize 
-                # which will be properly awaited by the caller
-                self.init_task = application.initialize()
-                logger.info("Telegram application initialization ready to be awaited")
-            except Exception as init_e:
-            logger.error(f"Error during application initialization: {str(init_e)}")
-            logger.exception(init_e)
-                
-            # Set bot commands for menu
-            commands = [
-                BotCommand("start", "Start the bot and get the welcome message"),
-                BotCommand("menu", "Show the main menu"),
-                BotCommand("help", "Show available commands and how to use the bot")
-            ]
-            
-            # Store the set_commands_task to be awaited later
-        try:
-                # Instead of asyncio.create_task, we will await this in the startup event
-                self.set_commands_task = self.bot.set_my_commands(commands)
-                logger.info("Bot commands ready to be set")
-            except Exception as cmd_e:
-            logger.error(f"Error preparing bot commands: {str(cmd_e)}")
-            
-            # Register command handlers
-            application.add_handler(CommandHandler("start", self.start_command))
-            application.add_handler(CommandHandler("menu", self.menu_command))
-            application.add_handler(CommandHandler("help", self.help_command))
-            
-            # Register secret admin commands
-            application.add_handler(CommandHandler("set_subscription", self.set_subscription_command))
-            application.add_handler(CommandHandler("set_payment_failed", self.set_payment_failed_command))
-            logger.info("Registered secret admin commands")
-            
-            # Register callback handlers
-            application.add_handler(CallbackQueryHandler(self.menu_analyse_callback, pattern="^menu_analyse$"))
-            application.add_handler(CallbackQueryHandler(self.menu_signals_callback, pattern="^menu_signals$"))
-            application.add_handler(CallbackQueryHandler(self.signals_add_callback, pattern="^signals_add$"))
-            application.add_handler(CallbackQueryHandler(self.signals_manage_callback, pattern="^signals_manage$"))
-            application.add_handler(CallbackQueryHandler(self.market_callback, pattern="^market_"))
-            application.add_handler(CallbackQueryHandler(self.instrument_callback, pattern="^instrument_(?!.*_signals)"))
-            application.add_handler(CallbackQueryHandler(self.instrument_signals_callback, pattern="^instrument_.*_signals$"))
-            
-            # Add handler for back buttons
-            application.add_handler(CallbackQueryHandler(self.back_market_callback, pattern="^back_market$"))
-            application.add_handler(CallbackQueryHandler(self.back_instrument_callback, pattern="^back_instrument$"))
-            application.add_handler(CallbackQueryHandler(self.back_signals_callback, pattern="^back_signals$"))
-            application.add_handler(CallbackQueryHandler(self.back_menu_callback, pattern="^back_menu$"))
-            
-            # Analysis handlers for regular flow
-            application.add_handler(CallbackQueryHandler(self.analysis_technical_callback, pattern="^analysis_technical$"))
-            application.add_handler(CallbackQueryHandler(self.analysis_sentiment_callback, pattern="^analysis_sentiment$"))
-            application.add_handler(CallbackQueryHandler(self.analysis_calendar_callback, pattern="^analysis_calendar$"))
-            
-            # Analysis handlers for signal flow - with instrument embedded in callback
-            application.add_handler(CallbackQueryHandler(self.signal_technical_callback, pattern="^signal_flow_technical_.*$"))
-            application.add_handler(CallbackQueryHandler(self.signal_sentiment_callback, pattern="^signal_flow_sentiment_.*$"))
-            application.add_handler(CallbackQueryHandler(self.signal_calendar_callback, pattern="^signal_flow_calendar_.*$"))
-            
-            # Analysis handlers for signal flow - with instrument embedded in callback
-            application.add_handler(CallbackQueryHandler(self.signal_technical_callback, pattern="^signal_flow_technical_.*$"))
-            application.add_handler(CallbackQueryHandler(self.signal_sentiment_callback, pattern="^signal_flow_sentiment_.*$"))
-            application.add_handler(CallbackQueryHandler(self.analysis_calendar_callback, pattern="^signal_flow_calendar_.*$"))
-            
-            # Signal analysis flow handlers
-            application.add_handler(CallbackQueryHandler(self.signal_technical_callback, pattern="^signal_technical$"))
-            application.add_handler(CallbackQueryHandler(self.signal_sentiment_callback, pattern="^signal_sentiment$"))
-            application.add_handler(CallbackQueryHandler(self.signal_calendar_callback, pattern="^signal_calendar$"))
-            application.add_handler(CallbackQueryHandler(self.signal_calendar_callback, pattern="^signal_flow_calendar_.*$"))
-            application.add_handler(CallbackQueryHandler(self.back_to_signal_callback, pattern="^back_to_signal$"))
-            application.add_handler(CallbackQueryHandler(self.back_to_signal_analysis_callback, pattern="^back_to_signal_analysis$"))
-            
-            # Signal from analysis
-            application.add_handler(CallbackQueryHandler(self.analyze_from_signal_callback, pattern="^analyze_from_signal_.*$"))
-            
-            # Ensure back_instrument is properly handled
-            application.add_handler(CallbackQueryHandler(self.back_instrument_callback, pattern="^back_instrument$"))
-            
-            # Catch-all handler for any other callbacks
-            application.add_handler(CallbackQueryHandler(self.button_callback))
-            
-            # Don't load signals here - it will be done in initialize_services
-            # self._load_signals()
-            
-            logger.info("Bot setup completed successfully")
-            
-    except Exception as e:
-        logger.error(f"Error setting up bot handlers: {str(e)}")
-        logger.exception(e)
-
-    @property
-    def signals_enabled(self):
-        """Get whether signals processing is enabled"""
-        return self._signals_enabled
-    
-    @signals_enabled.setter
-    def signals_enabled(self, value):
-        """Set whether signals processing is enabled"""
-        self._signals_enabled = bool(value)
-        logger.info(f"Signal processing is now {'enabled' if value else 'disabled'}")
-
-    async def _get_signal_related_trades(self, signal_id):
-    """Retrieve related trades from the database"""
-    try:
-        # Fetch the related trades data from the database
-        trades_data = await self.db.get_related_trades(signal_id)
-            
-        if trades_data:
-            return trades_data
-        else:
-            logger.warning(f"No related trades data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related trades: {str(e)}")
-        logger.exception(e)
-        return None
-
-
-from telegram.error import TelegramError, BadRequest
-import httpx
-import telegram.error  # Add this import for BadRequest error handling
-
-from trading_bot.services.database.db import Database
-from trading_bot.services.chart_service.chart import ChartService
-from trading_bot.services.sentiment_service.sentiment import MarketSentimentService
-from trading_bot.services.calendar_service import EconomicCalendarService
-from trading_bot.services.payment_service.stripe_service import StripeService
-from trading_bot.services.payment_service.stripe_config import get_subscription_features
-from trading_bot.services.telegram_service.states import (
-    MENU, ANALYSIS, SIGNALS, CHOOSE_MARKET, CHOOSE_INSTRUMENT, CHOOSE_STYLE,
-    CHOOSE_ANALYSIS, SIGNAL_DETAILS,
-    CALLBACK_MENU_ANALYSE, CALLBACK_MENU_SIGNALS, CALLBACK_ANALYSIS_TECHNICAL,
-    CALLBACK_ANALYSIS_SENTIMENT, CALLBACK_ANALYSIS_CALENDAR, CALLBACK_SIGNALS_ADD,
-    CALLBACK_SIGNALS_MANAGE, CALLBACK_BACK_MENU
-)
-import trading_bot.services.telegram_service.gif_utils as gif_utils
-
-# Initialize logger
-logger = logging.getLogger(__name__)
-
-# Major currencies to focus on
-MAJOR_CURRENCIES = ["USD", "EUR", "GBP", "JPY", "CHF", "AUD", "NZD", "CAD"]
-
-# Currency to flag emoji mapping
-CURRENCY_FLAG = {
-    "USD": "üá∫üá∏",
-    "EUR": "üá™üá∫",
-    "GBP": "üá¨üáß",
-    "JPY": "üáØüáµ",
-    "CHF": "üá®üá≠",
-    "AUD": "üá¶üá∫",
-    "NZD": "üá≥üáø",
-    "CAD": "üá®üá¶"
-}
-
-# Map of instruments to their corresponding currencies
-INSTRUMENT_CURRENCY_MAP = {
-    # Special case for global view
-    "GLOBAL": MAJOR_CURRENCIES,
-    
-    # Forex
-    "EURUSD": ["EUR", "USD"],
-    "GBPUSD": ["GBP", "USD"],
-    "USDJPY": ["USD", "JPY"],
-    "USDCHF": ["USD", "CHF"],
-    "AUDUSD": ["AUD", "USD"],
-    "NZDUSD": ["NZD", "USD"],
-    "USDCAD": ["USD", "CAD"],
-    "EURGBP": ["EUR", "GBP"],
-    "EURJPY": ["EUR", "JPY"],
-    "GBPJPY": ["GBP", "JPY"],
-    
-    # Indices (mapped to their related currencies)
-    "US30": ["USD"],
-    "US100": ["USD"],
-    "US500": ["USD"],
-    "UK100": ["GBP"],
-    "GER40": ["EUR"],
-    "FRA40": ["EUR"],
-    "ESP35": ["EUR"],
-    "JP225": ["JPY"],
-    "AUS200": ["AUD"],
-    
-    # Commodities (mapped to USD primarily)
-    "XAUUSD": ["USD", "XAU"],  # Gold
-    "XAGUSD": ["USD", "XAG"],  # Silver
-    "USOIL": ["USD"],          # Oil (WTI)
-    "UKOIL": ["USD", "GBP"],   # Oil (Brent)
-    
-    # Crypto
-    "BTCUSD": ["USD", "BTC"],
-    "ETHUSD": ["USD", "ETH"],
-    "LTCUSD": ["USD", "LTC"],
-    "XRPUSD": ["USD", "XRP"]
-}
-
-# Callback data constants
-CALLBACK_ANALYSIS_TECHNICAL = "analysis_technical"
-CALLBACK_ANALYSIS_SENTIMENT = "analysis_sentiment"
-CALLBACK_ANALYSIS_CALENDAR = "analysis_calendar"
-CALLBACK_BACK_MENU = "back_menu"
-CALLBACK_BACK_ANALYSIS = "back_to_analysis"
-CALLBACK_BACK_MARKET = "back_market"
-CALLBACK_BACK_INSTRUMENT = "back_instrument"
-CALLBACK_BACK_SIGNALS = "back_signals"
-CALLBACK_SIGNALS_ADD = "signals_add"
-CALLBACK_SIGNALS_MANAGE = "signals_manage"
-CALLBACK_MENU_ANALYSE = "menu_analyse"
-CALLBACK_MENU_SIGNALS = "menu_signals"
-
-# States
-MENU = 0
-CHOOSE_ANALYSIS = 1
-CHOOSE_SIGNALS = 2
-CHOOSE_MARKET = 3
-CHOOSE_INSTRUMENT = 4
-CHOOSE_STYLE = 5
-SHOW_RESULT = 6
-CHOOSE_TIMEFRAME = 7
-SIGNAL_DETAILS = 8
-SIGNAL = 9
-SUBSCRIBE = 10
-BACK_TO_MENU = 11  # Add this line
-
-# Messages
-WELCOME_MESSAGE = r"""
-<b>Sigmapips AI - Main Menu</b>
-
-Choose an option to access advanced trading support:
-
-Services:
-- <b>Technical Analysis</b> - Real-time chart analysis and key levels
-
-- <b>Market Sentiment</b> - Understand market trends and sentiment
-
-- <b>Economic Calendar</b> - Stay updated on market-moving events
-
-- <b>Trading Signals</b> - Get precise entry/exit points for your favorite pairs
-
-Select your option to continue:
-"""
-
-# Abonnementsbericht voor nieuwe gebruikers
-SUBSCRIPTION_WELCOME_MESSAGE = r"""
-<b>Welcome to Sigmapips AI!</b>
-
-To access all features, you need a subscription:
-
-<b>Trading Signals Subscription - $29.99/month</b>
-- Access to all trading signals (Forex, Crypto, Commodities, Indices)
-- Advanced timeframe analysis
-- Detailed chart analysis for each signal
-
-Click the button below to subscribe:
-"""
-
-MENU_MESSAGE = r"""
-Welcome to Sigmapips AI!
-
-Choose a command:
-
-/start - Set up new trading pairs
-Add new market/instrument/timeframe combinations to receive signals
-
-/manage - Manage your preferences
-View, edit or delete your saved trading pairs
-
-Need help? Use /help to see all available commands.
-"""
-
-HELP_MESSAGE = r"""
-Available commands:
-/menu - Show main menu
-/start - Set up new trading pairs
-/help - Show this help message
-"""
-
-# Start menu keyboard
-START_KEYBOARD = [
-    [InlineKeyboardButton("Analyze Market", callback_data=CALLBACK_MENU_ANALYSE)],
-    [InlineKeyboardButton("Trading Signals", callback_data=CALLBACK_MENU_SIGNALS)]
-]
-
-# Analysis menu keyboard
-ANALYSIS_KEYBOARD = [
-    [InlineKeyboardButton("Technical Analysis", callback_data=CALLBACK_ANALYSIS_TECHNICAL)],
-    [InlineKeyboardButton("Market Sentiment", callback_data=CALLBACK_ANALYSIS_SENTIMENT)],
-    [InlineKeyboardButton("Economic Calendar", callback_data=CALLBACK_ANALYSIS_CALENDAR)],
-    [InlineKeyboardButton("Back", callback_data=CALLBACK_BACK_MENU)]
-]
-
-# Signals menu keyboard
-SIGNALS_KEYBOARD = [
-    [InlineKeyboardButton("Add New Pairs", callback_data=CALLBACK_SIGNALS_ADD)],
-    [InlineKeyboardButton("Manage Signals", callback_data=CALLBACK_SIGNALS_MANAGE)],
-    [InlineKeyboardButton("Back", callback_data=CALLBACK_BACK_MENU)]
-]
-
-# Market keyboard voor signals
-MARKET_KEYBOARD_SIGNALS = [
-    [InlineKeyboardButton("Forex", callback_data="market_forex_signals")],
-    [InlineKeyboardButton("Crypto", callback_data="market_crypto_signals")],
-    [InlineKeyboardButton("Commodities", callback_data="market_commodities_signals")],
-    [InlineKeyboardButton("Indices", callback_data="market_indices_signals")],
-    [InlineKeyboardButton("Back", callback_data="back_signals")]
-]
-
-# Market keyboard voor analyse
-MARKET_KEYBOARD = [
-    [InlineKeyboardButton("Forex", callback_data="market_forex")],
-    [InlineKeyboardButton("Crypto", callback_data="market_crypto")],
-    [InlineKeyboardButton("Commodities", callback_data="market_commodities")],
-    [InlineKeyboardButton("Indices", callback_data="market_indices")],
-    [InlineKeyboardButton("Back", callback_data="back_analysis")]
-]
-
-# Market keyboard specifiek voor sentiment analyse
-MARKET_SENTIMENT_KEYBOARD = [
-    [InlineKeyboardButton("Forex", callback_data="market_forex_sentiment")],
-    [InlineKeyboardButton("Crypto", callback_data="market_crypto_sentiment")],
-    [InlineKeyboardButton("Commodities", callback_data="market_commodities_sentiment")],
-    [InlineKeyboardButton("Indices", callback_data="market_indices_sentiment")],
-    [InlineKeyboardButton("Back", callback_data="back_analysis")]
-]
-
-# Forex keyboard voor technical analyse
-FOREX_KEYBOARD = [
-    [
-        InlineKeyboardButton("EURUSD", callback_data="instrument_EURUSD_chart"),
-        InlineKeyboardButton("GBPUSD", callback_data="instrument_GBPUSD_chart"),
-        InlineKeyboardButton("USDJPY", callback_data="instrument_USDJPY_chart")
-    ],
-    [
-        InlineKeyboardButton("AUDUSD", callback_data="instrument_AUDUSD_chart"),
-        InlineKeyboardButton("USDCAD", callback_data="instrument_USDCAD_chart"),
-        InlineKeyboardButton("EURGBP", callback_data="instrument_EURGBP_chart")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Forex keyboard voor sentiment analyse
-FOREX_SENTIMENT_KEYBOARD = [
-    [
-        InlineKeyboardButton("EURUSD", callback_data="instrument_EURUSD_sentiment"),
-        InlineKeyboardButton("GBPUSD", callback_data="instrument_GBPUSD_sentiment"),
-        InlineKeyboardButton("USDJPY", callback_data="instrument_USDJPY_sentiment")
-    ],
-    [
-        InlineKeyboardButton("AUDUSD", callback_data="instrument_AUDUSD_sentiment"),
-        InlineKeyboardButton("USDCAD", callback_data="instrument_USDCAD_sentiment"),
-        InlineKeyboardButton("EURGBP", callback_data="instrument_EURGBP_sentiment")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Forex keyboard voor kalender analyse
-FOREX_CALENDAR_KEYBOARD = [
-    [
-        InlineKeyboardButton("EURUSD", callback_data="instrument_EURUSD_calendar"),
-        InlineKeyboardButton("GBPUSD", callback_data="instrument_GBPUSD_calendar"),
-        InlineKeyboardButton("USDJPY", callback_data="instrument_USDJPY_calendar")
-    ],
-    [
-        InlineKeyboardButton("AUDUSD", callback_data="instrument_AUDUSD_calendar"),
-        InlineKeyboardButton("USDCAD", callback_data="instrument_USDCAD_calendar"),
-        InlineKeyboardButton("EURGBP", callback_data="instrument_EURGBP_calendar")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Crypto keyboard voor analyse
-CRYPTO_KEYBOARD = [
-    [
-        InlineKeyboardButton("BTCUSD", callback_data="instrument_BTCUSD_chart"),
-        InlineKeyboardButton("ETHUSD", callback_data="instrument_ETHUSD_chart"),
-        InlineKeyboardButton("XRPUSD", callback_data="instrument_XRPUSD_chart")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Signal analysis keyboard
-SIGNAL_ANALYSIS_KEYBOARD = [
-    [InlineKeyboardButton("Technical Analysis", callback_data="signal_technical")],
-    [InlineKeyboardButton("Market Sentiment", callback_data="signal_sentiment")],
-    [InlineKeyboardButton("Economic Calendar", callback_data="signal_calendar")],
-    [InlineKeyboardButton("Back", callback_data="back_to_signal")]
-]
-
-# Crypto keyboard voor sentiment analyse
-CRYPTO_SENTIMENT_KEYBOARD = [
-    [
-        InlineKeyboardButton("BTCUSD", callback_data="instrument_BTCUSD_sentiment"),
-        InlineKeyboardButton("ETHUSD", callback_data="instrument_ETHUSD_sentiment"),
-        InlineKeyboardButton("XRPUSD", callback_data="instrument_XRPUSD_sentiment")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Indices keyboard voor analyse
-INDICES_KEYBOARD = [
-    [
-        InlineKeyboardButton("US30", callback_data="instrument_US30_chart"),
-        InlineKeyboardButton("US500", callback_data="instrument_US500_chart"),
-        InlineKeyboardButton("US100", callback_data="instrument_US100_chart")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Indices keyboard voor signals - Fix de "Terug" knop naar "Back"
-INDICES_KEYBOARD_SIGNALS = [
-    [
-        InlineKeyboardButton("US30", callback_data="instrument_US30_signals"),
-        InlineKeyboardButton("US500", callback_data="instrument_US500_signals"),
-        InlineKeyboardButton("US100", callback_data="instrument_US100_signals")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Commodities keyboard voor analyse
-COMMODITIES_KEYBOARD = [
-    [
-        InlineKeyboardButton("GOLD", callback_data="instrument_XAUUSD_chart"),
-        InlineKeyboardButton("SILVER", callback_data="instrument_XAGUSD_chart"),
-        InlineKeyboardButton("OIL", callback_data="instrument_USOIL_chart")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Commodities keyboard voor signals - Fix de "Terug" knop naar "Back"
-COMMODITIES_KEYBOARD_SIGNALS = [
-    [
-        InlineKeyboardButton("XAUUSD", callback_data="instrument_XAUUSD_signals"),
-        InlineKeyboardButton("XAGUSD", callback_data="instrument_XAGUSD_signals"),
-        InlineKeyboardButton("USOIL", callback_data="instrument_USOIL_signals")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Forex keyboard for signals
-FOREX_KEYBOARD_SIGNALS = [
-    [
-        InlineKeyboardButton("EURUSD", callback_data="instrument_EURUSD_signals"),
-        InlineKeyboardButton("GBPUSD", callback_data="instrument_GBPUSD_signals"),
-        InlineKeyboardButton("USDJPY", callback_data="instrument_USDJPY_signals")
-    ],
-    [
-        InlineKeyboardButton("USDCAD", callback_data="instrument_USDCAD_signals"),
-        InlineKeyboardButton("EURGBP", callback_data="instrument_EURGBP_signals")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Crypto keyboard for signals
-CRYPTO_KEYBOARD_SIGNALS = [
-    [
-        InlineKeyboardButton("BTCUSD", callback_data="instrument_BTCUSD_signals"),
-        InlineKeyboardButton("ETHUSD", callback_data="instrument_ETHUSD_signals"),
-        InlineKeyboardButton("XRPUSD", callback_data="instrument_XRPUSD_signals")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Indices keyboard voor sentiment analyse
-INDICES_SENTIMENT_KEYBOARD = [
-    [
-        InlineKeyboardButton("US30", callback_data="instrument_US30_sentiment"),
-        InlineKeyboardButton("US500", callback_data="instrument_US500_sentiment"),
-        InlineKeyboardButton("US100", callback_data="instrument_US100_sentiment")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Commodities keyboard voor sentiment analyse
-COMMODITIES_SENTIMENT_KEYBOARD = [
-    [
-        InlineKeyboardButton("GOLD", callback_data="instrument_XAUUSD_sentiment"),
-        InlineKeyboardButton("SILVER", callback_data="instrument_XAGUSD_sentiment"),
-        InlineKeyboardButton("OIL", callback_data="instrument_USOIL_sentiment")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Style keyboard
-STYLE_KEYBOARD = [
-    [InlineKeyboardButton("‚ö° Test (one_min)", callback_data="style_test")],
-    [InlineKeyboardButton("üèÉ Scalp (fifteen_min)", callback_data="style_scalp")],
-    [InlineKeyboardButton(" Intraday (one_hour)", callback_data="style_intraday")],
-    [InlineKeyboardButton("üåä Swing (four_hour)", callback_data="style_swing")],
-    [InlineKeyboardButton("Back", callback_data="back_instrument")]
-]
-
-# Timeframe mapping
-STYLE_TIMEFRAME_MAP = {
-    "test": "one_min",
-    "scalp": "fifteen_min",
-    "intraday": "one_hour",
-    "swing": "four_hour"
-}
-
-# Mapping of instruments to their allowed timeframes - updated 2023-03-23
-INSTRUMENT_TIMEFRAME_MAP = {
-    # H1 timeframe only
-    "AUDJPY": "H1", 
-    "AUDCHF": "H1",
-    "EURCAD": "H1",
-    "EURGBP": "H1",
-    "GBPCHF": "H1",
-    "HK50": "H1",
-    "NZDJPY": "H1",
-    "USDCHF": "H1",
-    "USDJPY": "H1",  # USDJPY toegevoegd voor signaalabonnementen
-    "XRPUSD": "H1",
-    
-    # H4 timeframe only
-    "AUDCAD": "H4",
-    "AU200": "H4", 
-    "CADCHF": "H4",
-    "EURCHF": "H4",
-    "EURUSD": "H4",
-    "GBPCAD": "H4",
-    "LINKUSD": "H4",
-    "NZDCHF": "H4",
-    
-    # M15 timeframe only
-    "DOGEUSD": "M15",
-    "GBPNZD": "M15",
-    "NZDUSD": "M15",
-    "SOLUSD": "M15",
-    "UK100": "M15",
-    "XAUUSD": "M15",
-    
-    # M30 timeframe only
-    "BNBUSD": "M30",
-    "DOTUSD": "M30",
-    "ETHUSD": "M30",
-    "EURAUD": "M30",
-    "EURJPY": "M30",
-    "GBPAUD": "M30",
-    "GBPUSD": "M30",
-    "NZDCAD": "M30",
-    "US30": "M30",
-    "US500": "M30",
-    "USDCAD": "M30",
-    "XLMUSD": "M30",
-    "XTIUSD": "M30",
-    "DE40": "M30",
-    "BTCUSD": "M30",  # Added for consistency with CRYPTO_KEYBOARD_SIGNALS
-    "US100": "M30",   # Added for consistency with INDICES_KEYBOARD_SIGNALS
-    "XAGUSD": "M15",  # Added for consistency with COMMODITIES_KEYBOARD_SIGNALS
-    "USOIL": "M30"    # Added for consistency with COMMODITIES_KEYBOARD_SIGNALS
-    
-    # Removed as requested: EU50, FR40, LTCUSD
-}
-
-# Map common timeframe notations
-TIMEFRAME_DISPLAY_MAP = {
-    "M15": "15 Minutes",
-    "M30": "30 Minutes", 
-    "H1": "1 Hour",
-    "H4": "4 Hours"
-}
-
-# Voeg deze functie toe aan het begin van bot.py, na de imports
-def _detect_market(instrument: str) -> str:
-    """Detecteer market type gebaseerd op instrument"""
-    instrument = instrument.upper()
-    
-    # Commodities eerst checken
-    commodities = [
-        "XAUUSD",  # Gold
-        "XAGUSD",  # Silver
-        "WTIUSD",  # Oil WTI
-        "BCOUSD",  # Oil Brent
-        "USOIL",   # Oil WTI (alternative symbol)
-    ]
-    if instrument in commodities:
-        logger.info(f"Detected {instrument} as commodity")
-        return "commodities"
-    
-    # Crypto pairs
-    crypto_base = ["BTC", "ETH", "XRP", "SOL", "BNB", "ADA", "DOT", "LINK"]
-    if any(c in instrument for c in crypto_base):
-        logger.info(f"Detected {instrument} as crypto")
-        return "crypto"
-    
-    # Major indices
-    indices = [
-        "US30", "US500", "US100",  # US indices
-        "UK100", "DE40", "FR40",   # European indices
-        "JP225", "AU200", "HK50"   # Asian indices
-    ]
-    if instrument in indices:
-        logger.info(f"Detected {instrument} as index")
-        return "indices"
-    
-    # Forex pairs als default
-    logger.info(f"Detected {instrument} as forex")
-    return "forex"
-
-# Voeg dit toe als decorator functie bovenaan het bestand na de imports
-def require_subscription(func):
-    """Check if user has an active subscription"""
-    async def wrapper(self, update: Update, context: ContextTypes.DEFAULT_TYPE, *args, **kwargs):
-        user_id = update.effective_user.id
-        
-        # Check subscription status
-        is_subscribed = await self.db.is_user_subscribed(user_id)
-        
-        # Check if payment has failed
-        payment_failed = await self.db.has_payment_failed(user_id)
-        
-        if is_subscribed and not payment_failed:
-            # User has subscription, proceed with function
-            return await func(self, update, context, *args, **kwargs)
-        else:
-            if payment_failed:
-                # Show payment failure message
-                failed_payment_text = f"""
- <b>Subscription Payment Failed</b> 
-
-Your subscription payment could not be processed and your service has been deactivated.
-
-To continue using Sigmapips AI and receive trading signals, please reactivate your subscription by clicking the button below.
-                """
-                
-                # Use direct URL link for reactivation
-                reactivation_url = "https://buy.stripe.com/9AQcPf3j63HL5JS145"
-                
-                # Create button for reactivation
-                keyboard = [
-                    [InlineKeyboardButton("üîÑ Reactivate Subscription", url=reactivation_url)]
-                ]
-            else:
-                # Show subscription screen with the welcome message from the screenshot
-                failed_payment_text = f"""
- <b>Welcome to Sigmapips AI!</b> 
-
-<b>Discover powerful trading signals for various markets:</b>
-- <b>Forex</b> - Major and minor currency pairs
-- <b>Crypto</b> - Bitcoin, Ethereum and other top cryptocurrencies
-- <b>Indices</b> - Global market indices
-- <b>Commodities</b> - Gold, silver and oil
-
-<b>Features:</b>
- Real-time trading signals
-
- Multi-timeframe analysis (timeframes)
-
- Advanced chart analysis
-
- Sentiment indicators
-
- Economic calendar integration
-
-<b>Start today with a FREE 14-day trial!</b>
-                """
-                
-                # Use direct URL link instead of callback for the trial button
-                reactivation_url = "https://buy.stripe.com/3cs3eF9Hu9256NW9AA"
-                
-                # Create button for trial
-                keyboard = [
-                    [InlineKeyboardButton("üî• Start 14-day FREE Trial", url=reactivation_url)]
-                ]
-            
-            # Handle both message and callback query updates
-            if update.callback_query:
-                await update.callback_query.answer()
-                await update.callback_query.edit_message_text(
-                    text=failed_payment_text,
-                    reply_markup=InlineKeyboardMarkup(keyboard),
-                    parse_mode=ParseMode.HTML
-                )
-            else:
-                await update.message.reply_text(
-                    text=failed_payment_text,
-                    reply_markup=InlineKeyboardMarkup(keyboard),
-                    parse_mode=ParseMode.HTML
-                )
-            return MENU
-    
-    return wrapper
-
-# API keys with robust sanitization
-PERPLEXITY_API_KEY = os.getenv("PERPLEXITY_API_KEY", "").strip()
-OPENAI_API_KEY = os.getenv("OPENAI_API_KEY", "").strip()  # Changed from DeepSeek to OpenAI
-
-# Only using OpenAI's o4-mini now
-# No Tavily API key needed anymore
-logger.info("Using only OpenAI o4-mini for Market Sentiment service")
-
-# Log OpenAI API key (partially masked)
-if OPENAI_API_KEY:
-    # Better masking for privacy and security
-    masked_key = f"sk-p...{OPENAI_API_KEY[-4:]}" if len(OPENAI_API_KEY) > 8 else "sk-p..."
-    logger.info(f"Using OpenAI API key: {masked_key}")
-    
-    # Validate the key format
-    from trading_bot.config import validate_openai_key
-    if not validate_openai_key(OPENAI_API_KEY):
-        logger.warning("OpenAI API key format is invalid. AI services may not work correctly.")
-else:
-    logger.warning("No OpenAI API key configured. AI services will be disabled.")
-    
-# Set environment variables for the API keys with sanitization
-os.environ["PERPLEXITY_API_KEY"] = PERPLEXITY_API_KEY
-os.environ["OPENAI_API_KEY"] = OPENAI_API_KEY  # Changed from DeepSeek to OpenAI
-# No Tavily environment needed
-
-class TelegramService:
-    def __init__(self, db: Database, stripe_service=None, bot_token: Optional[str] = None, proxy_url: Optional[str] = None, lazy_init: bool = False):
-        """Initialize the bot with given database and config."""
-        # Database connection
-        self.db = db
-        
-        # Setup configuration 
-        self.stripe_service = stripe_service
-        self.user_signals = {}
-        self.signals_dir = "data/signals"
-        self.signals_enabled_val = True
-        self.polling_started = False
-        self.admin_users = [2004519703]  # Updated with correct Telegram ID from logs
-        self._signals_enabled = True  # Enable signals by default
-        
-        # Setup logger
-        self.logger = logging.getLogger(__name__)
-        
-        # GIF utilities for UI
-        self.gif_utils = gif_utils  # Initialize gif_utils as an attribute
-        
-        # Setup the bot and application
-        self.bot = None
-        self.application = None
-        
-        # Telegram Bot configuratie
-        self.bot_token = bot_token or os.getenv("TELEGRAM_BOT_TOKEN", "")
-        self.token = self.bot_token  # Aliased for backward compatibility
-        self.proxy_url = proxy_url or os.getenv("TELEGRAM_PROXY_URL", "")
-        
-        # Configure custom request handler with improved connection settings
-        request = HTTPXRequest(
-            connection_pool_size=50,  # Increase from 20 to 50
-            connect_timeout=15.0,     # Increase from 10.0 to 15.0
-            read_timeout=45.0,        # Increase from 30.0 to 45.0
-            write_timeout=30.0,       # Increase from 20.0 to 30.0
-            pool_timeout=60.0,        # Increase from 30.0 to 60.0
-        )
-        
-        # Initialize the bot directly with connection pool settings
-        self.bot = Bot(token=self.bot_token, request=request)
-        self.application = None  # Will be initialized in setup()
-        
-        # Webhook configuration
-        self.webhook_url = os.getenv("WEBHOOK_URL", "")
-        self.webhook_path = "/webhook"  # Always use this path
-        if self.webhook_url.endswith("/"):
-            self.webhook_url = self.webhook_url[:-1]  # Remove trailing slash
-            
-        logger.info(f"Bot initialized with webhook URL: {self.webhook_url} and path: {self.webhook_path}")
-        
-        # Initialize API services
-        self.chart_service = ChartService()  # Initialize chart service
-        # Lazy load services only when needed
-        self._calendar_service = None
-        self._sentiment_service = None
-        
-        # Don't use asyncio.create_task here - it requires a running event loop
-        # We'll initialize chart service later when the event loop is running
-        
-        # Bot application initialization
-        self.persistence = None
-        self.bot_started = False
-        
-        # Cache for sentiment analysis
-        self.sentiment_cache = {}
-        self.sentiment_cache_ttl = 60 * 60  # 1 hour in seconds
-        
-        # Start the bot
-    try:
-            # Check for bot token
-            if not self.bot_token:
-                raise ValueError("Missing Telegram bot token")
-            
-            # Initialize the bot
-            self.bot = Bot(token=self.bot_token)
-        
-            # Initialize the application
-            self.application = Application.builder().bot(self.bot).build()
-        
-            # Register the handlers
-            self._register_handlers(self.application)
-            
-            # Initialize signals dictionary but don't load them yet (will be done in initialize_services)
-            self.user_signals = {}
-        
-            logger.info("Telegram service initialized")
-            
-            # Keep track of processed updates
-            self.processed_updates = set()
-            
-    except Exception as e:
-        logger.error(f"Error initializing Telegram service: {str(e)}")
-        raise
-
-    async def initialize_services(self):
-        """Initialize services that require an asyncio event loop"""
-        try:
-            # Initialize chart service
-            await self.chart_service.initialize()
-            logger.info("Chart service initialized")
-            
-            # Load stored signals
-            await self._load_signals()
-            logger.info("Signals loaded")
-            
-            # Schedule periodic cleanup of old signals
-            if hasattr(self, 'db') and self.db and self.db.using_redis:
-                # Run initial cleanup
-                cleaned = await self._cleanup_old_signals(max_age_days=7)
-                logger.info(f"Initial signal cleanup completed, removed {cleaned} old signals")
-                
-                # Schedule periodic cleanup (every 24 hours)
-                async def periodic_cleanup():
-                    while True:
-                        try:
-                            # Wait for 24 hours
-                            await asyncio.sleep(24 * 60 * 60)
-                            # Run cleanup
-                            cleaned = await self._cleanup_old_signals(max_age_days=7)
-                            logger.info(f"Periodic signal cleanup completed, removed {cleaned} old signals")
-                        except Exception as e:
-                            logger.error(f"Error in periodic signal cleanup: {str(e)}")
-                
-                # Start the periodic cleanup task
-                asyncio.create_task(periodic_cleanup())
-                logger.info("Scheduled periodic signal cleanup")
-        except Exception as e:
-            logger.error(f"Error initializing services: {str(e)}")
-            raise
-            
-    # Calendar service helpers
-    @property
-    def calendar_service(self):
-        """Lazy loaded calendar service"""
-        if self._calendar_service is None:
-            # Only initialize the calendar service when it's first accessed
-            self.logger.info("Lazy loading calendar service")
-            self._calendar_service = EconomicCalendarService()
-        return self._calendar_service
-        
-    def _get_calendar_service(self):
-        """Get the calendar service instance"""
-        self.logger.info("Getting calendar service")
-        return self.calendar_service
-
-    async def _format_calendar_events(self, calendar_data):
-        """Format the calendar data into a readable HTML message"""
-        self.logger.info(f"Formatting calendar data with {len(calendar_data)} events")
-        if not calendar_data:
-            return "<b>Economic Calendar</b>\n\nNo economic events found for today."
-        
-        # Sort events by time
-        try:
-            # Try to parse time for sorting
-            def parse_time_for_sorting(event):
-                time_str = event.get('time', '')
-                try:
-                    # Extract hour and minute if in format like "08:30 EST"
-                    if ':' in time_str:
-                        parts = time_str.split(' ')[0].split(':')
-                        hour = int(parts[0])
-                        minute = int(parts[1])
-                        return hour * 60 + minute
-                    return 0
-                except:
-                    return 0
-            
-            # Sort the events by time
-            sorted_events = sorted(calendar_data, key=parse_time_for_sorting)
-        except Exception as e:
-            self.logger.error(f"Error sorting calendar events: {str(e)}")
-            sorted_events = calendar_data
-        
-        # Format the message
-        message = "<b>Economic Calendar</b>\n\n"
-        
-        # Get current date
-        current_date = datetime.now().strftime("%B %d, %Y")
-        message += f"<b>Date:</b> {current_date}\n\n"
-        
-        # Add impact legend
-        message += "<b>Impact:</b> üî¥ High   üü† Medium   üü¢ Low\n\n"
-        
-        # Group events by country
-        events_by_country = {}
-        for event in sorted_events:
-            country = event.get('country', 'Unknown')
-            if country not in events_by_country:
-                events_by_country[country] = []
-            events_by_country[country].append(event)
-        
-        # Format events by country
-        for country, events in events_by_country.items():
-            country_flag = CURRENCY_FLAG.get(country, '')
-            message += f"<b>{country_flag} {country}</b>\n"
-            
-            for event in events:
-                time = event.get('time', 'TBA')
-                title = event.get('title', 'Unknown Event')
-                impact = event.get('impact', 'Low')
-                impact_emoji = {'High': 'üî¥', 'Medium': 'üü†', 'Low': 'üü¢'}.get(impact, 'üü¢')
-                
-                message += f"{time} - {impact_emoji} {title}\n"
-            
-            message += "\n"  # Add extra newline between countries
-        
-        return message
-        
-    # Utility functions that might be missing
-    async def update_message(self, query, text, keyboard=None, parse_mode=ParseMode.HTML):
-        """Utility to update a message with error handling"""
-        try:
-            # Check if the message is too long for Telegram caption limits (1024 chars)
-            MAX_CAPTION_LENGTH = 1000  # Slightly under the 1024 limit for safety
-            MAX_MESSAGE_LENGTH = 4000  # Telegram message limit
-            
-            # Log message length for debugging
-            logger.info(f"Updating message (length: {len(text)} chars)")
-            
-            # If message is too long for a caption but ok for a text message
-            if len(text) > MAX_CAPTION_LENGTH and len(text) <= MAX_MESSAGE_LENGTH:
-                logger.info("Message too long for caption but ok for text message")
-                # Try to edit message text first
-                await query.edit_message_text(
-                    text=text,
-                    reply_markup=keyboard,
-                    parse_mode=parse_mode
-                )
-                return True
-            # If message is too long even for a text message
-            elif len(text) > MAX_MESSAGE_LENGTH:
-                logger.warning(f"Message too long ({len(text)} chars), truncating")
-                # Find a good breaking point
-                truncated = text[:MAX_MESSAGE_LENGTH-100]
-                
-                # Try to break at a paragraph
-                last_newline = truncated.rfind('\n\n')
-                if last_newline > MAX_MESSAGE_LENGTH * 0.8:  # If we can keep at least 80% of the text
-                    truncated = truncated[:last_newline]
-                    
-                # Add indicator that text was truncated
-                truncated += "\n\n<i>... (message truncated)</i>"
-                
-                # Try to edit message text with truncated content
-                await query.edit_message_text(
-                    text=truncated,
-                    reply_markup=keyboard,
-                    parse_mode=parse_mode
-                )
-                return True
-            else:
-                # Normal case - message is within limits
-                # Try to edit message text first
-                await query.edit_message_text(
-                    text=text,
-                    reply_markup=keyboard,
-                    parse_mode=parse_mode
-                )
-                return True
-        except Exception as e:
-            logger.warning(f"Could not update message text: {str(e)}")
-            
-            # If text update fails, try to edit caption
-            try:
-                # Check if caption is too long
-                MAX_CAPTION_LENGTH = 1000  # Slightly under the 1024 limit for safety
-                
-                if len(text) > MAX_CAPTION_LENGTH:
-                    logger.warning(f"Caption too long ({len(text)} chars), truncating")
-                    # Find a good breaking point
-                    truncated = text[:MAX_CAPTION_LENGTH-100]
-                    
-                    # Try to break at a paragraph
-                    last_newline = truncated.rfind('\n\n')
-                    if last_newline > MAX_CAPTION_LENGTH * 0.8:  # If we can keep at least 80% of the text
-                        truncated = truncated[:last_newline]
-                        
-                    # Add indicator that text was truncated
-                    truncated += "\n\n<i>... (message truncated)</i>"
-                    
-                    # Use truncated text for caption
-                    await query.edit_message_caption(
-                        caption=truncated,
-                        reply_markup=keyboard,
-                        parse_mode=parse_mode
-                    )
-                else:
-                    # Caption is within limits
-                    await query.edit_message_caption(
-                        caption=text,
-                        reply_markup=keyboard,
-                        parse_mode=parse_mode
-                    )
-                return True
-            except Exception as e2:
-                logger.error(f"Could not update caption either: {str(e2)}")
-                
-                # As a last resort, send a new message
-                try:
-                    chat_id = query.message.chat_id
-                    
-                    # Check if message is too long
-                    MAX_MESSAGE_LENGTH = 4000  # Telegram message limit
-                    
-                    if len(text) > MAX_MESSAGE_LENGTH:
-                        logger.warning(f"New message too long ({len(text)} chars), truncating")
-                        # Find a good breaking point
-                        truncated = text[:MAX_MESSAGE_LENGTH-100]
-                        
-                        # Try to break at a paragraph
-                        last_newline = truncated.rfind('\n\n')
-                        if last_newline > MAX_MESSAGE_LENGTH * 0.8:  # If we can keep at least 80% of the text
-                            truncated = truncated[:last_newline]
-                            
-                        # Add indicator that text was truncated
-                        truncated += "\n\n<i>... (message truncated)</i>"
-                        
-                        # Use truncated text for new message
-                        await query.bot.send_message(
-                            chat_id=chat_id,
-                            text=truncated,
-                            reply_markup=keyboard,
-                            parse_mode=parse_mode
-                        )
-                    else:
-                        # Message is within limits
-                        await query.bot.send_message(
-                            chat_id=chat_id,
-                            text=text,
-                            reply_markup=keyboard,
-                            parse_mode=parse_mode
-                        )
-                    return True
-                except Exception as e3:
-                    logger.error(f"Failed to send new message: {str(e3)}")
-                    return False
-    
-    # Missing handler implementations
-    async def back_signals_callback(self, update: Update, context=None) -> int:
-        """Handle back_signals button press"""
-        query = update.callback_query
-        await query.answer()
-        
-        logger.info("back_signals_callback called")
-        
-        # Make sure we're in the signals flow context
-        if context and hasattr(context, 'user_data'):
-            # Reset signal flow flags
-            context.user_data['from_signal'] = False
-            context.user_data['in_signal_flow'] = False
-            logger.info(f"Reset signal flow flags: from_signal=False, in_signal_flow=False")
-            # Keep is_signals_context flag but reset from_signal flag
-            context.user_data['is_signals_context'] = True
-            context.user_data['from_signal'] = False
-            
-            # Clear other specific analysis keys but maintain signals context
-            keys_to_remove = [
-                'instrument', 'market', 'analysis_type', 'timeframe', 
-                'signal_id', 'signal_instrument', 'signal_direction', 'signal_timeframe',
-                'loading_message'
-            ]
-
-            for key in keys_to_remove:
-                if key in context.user_data:
-                    del context.user_data[key]
-            logger.info(f"Updated context in back_signals_callback: {context.user_data}")
-        
-        # Create keyboard for signal menu
-        keyboard = [
-            [InlineKeyboardButton(" Add Signal", callback_data="signals_add")],
-            [InlineKeyboardButton("Manage Signals", callback_data="signals_manage")],
-            [InlineKeyboardButton("Back to Menu", callback_data="back_menu")]
-        ]
-        reply_markup = InlineKeyboardMarkup(keyboard)
-        
-        # Get the signals GIF URL for better UX
-        signals_gif_url = "https://media.giphy.com/media/gSzIKNrqtotEYrZv7i/giphy.gif"
-        
-        # Update the message
-        await self.update_message(
-            query=query,\n            text="<b> Signal Management</b>\n\nManage your trading signals",
-            keyboard=reply_markup
-        )
-        
-        return SIGNALS
-        
-    async def get_subscribers_for_instrument(self, instrument: str, timeframe: str = None) -> List[int]:
-        """
-        Get a list of subscribed user IDs for a specific instrument and timeframe
-        
-        Args:
-            instrument: The trading instrument (e.g., EURUSD)
-            timeframe: Optional timeframe filter
-            
-        Returns:
-            List of subscribed user IDs
-        """
-    try:
-            logger.info(f"Getting subscribers for {instrument} timeframe: {timeframe}")
-            
-            # Get all subscribers from the database
-            # Note: Using get_signal_subscriptions instead of find_all
-            subscribers = await self.db.get_signal_subscriptions(instrument, timeframe)
-            
-            if not subscribers:
-                logger.warning(f"No subscribers found for {instrument}")
-                return []
-                
-            # Filter out subscribers that don't have an active subscription
-            active_subscribers = []
-            for subscriber in subscribers:
-                user_id = subscriber['user_id']
-                
-                # Check if user is subscribed
-                is_subscribed = await self.db.is_user_subscribed(user_id)
-                
-                # Check if payment has failed
-                payment_failed = await self.db.has_payment_failed(user_id)
-                
-                if is_subscribed and not payment_failed:
-                    active_subscribers.append(user_id)
-                else:
-                    logger.info(f"User {user_id} doesn't have an active subscription, skipping signal")
-            
-            return active_subscribers
-            
-    except Exception as e:
-        logger.error(f"Error getting subscribers: {str(e)}")
-            # FOR TESTING: Add admin users if available
-            if hasattr(self, 'admin_users') and self.admin_users:
-                logger.info(f"Returning admin users for testing: {self.admin_users}")
-                return self.admin_users
-            return []
-
-    async def process_signal(self, signal_data: Dict[str, Any]) -> bool:
-        """
-        Process a trading signal from TradingView webhook or API
-        
-        Supports two formats:
-        1. TradingView format: instrument, signal, price, sl, tp1, tp2, tp3, interval
-        2. Custom format: instrument, direction, entry, stop_loss, take_profit, timeframe
-        
-        Returns:
-            bool: True if signal was processed successfully, False otherwise
-        """
-        try:
-            # Log the incoming signal data
-            logger.info(f"Processing signal: {signal_data}")
-            
-            # Check which format we're dealing with and normalize it
-            instrument = signal_data.get('instrument')
-            
-            # Handle TradingView format (price, sl, interval)
-            if 'price' in signal_data and 'sl' in signal_data:
-                price = signal_data.get('price')
-                sl = signal_data.get('sl')
-                tp1 = signal_data.get('tp1')
-                tp2 = signal_data.get('tp2')
-                tp3 = signal_data.get('tp3')
-                interval = signal_data.get('interval', 'one_hour')
-                
-                # Determine signal direction based on price and SL relationship
-                direction = "BUY" if float(sl) < float(price) else "SELL"
-                
-                # Create normalized signal data
-                normalized_data = {
-                    'instrument': instrument,
-                    'direction': direction,
-                    'entry': price,
-                    'stop_loss': sl,
-                    'take_profit': tp1,  # Use first take profit level
-                    'timeframe': interval
-                }
-                
-                # Add optional fields if present
-                normalized_data['tp1'] = tp1
-                normalized_data['tp2'] = tp2
-                normalized_data['tp3'] = tp3
-                
-            # Handle custom format (direction, entry, stop_loss, timeframe)
-            elif 'direction' in signal_data and 'entry' in signal_data:
-                direction = signal_data.get('direction')
-                entry = signal_data.get('entry')
-                stop_loss = signal_data.get('stop_loss')
-                take_profit = signal_data.get('take_profit')
-                timeframe = signal_data.get('timeframe', 'one_hour')
-                
-                # Create normalized signal data
-                normalized_data = {
-                    'instrument': instrument,
-                    'direction': direction,
-                    'entry': entry,
-                    'stop_loss': stop_loss,
-                    'take_profit': take_profit,
-                    'timeframe': timeframe
-                }
-            else:
-                logger.error(f"Missing required signal data")
-                return False
-            
-            # Basic validation
-            if not normalized_data.get('instrument') or not normalized_data.get('direction') or not normalized_data.get('entry'):
-                logger.error(f"Missing required fields in normalized signal data: {normalized_data}")
-                return False
-                
-            # Create signal ID for tracking
-            signal_id = f"{normalized_data['instrument']}_{normalized_data['direction']}_{normalized_data['timeframe']}_{int(time.time())}"
-            
-            # Format the signal message
-            message = self._format_signal_message(normalized_data)
-            
-            # Determine market type for the instrument
-            market_type = _detect_market(instrument)
-            
-            # Store the full signal data for reference
-            normalized_data['id'] = signal_id
-            normalized_data['timestamp'] = datetime.now().isoformat()
-            normalized_data['message'] = message
-            normalized_data['market'] = market_type
-            
-            # Save signal for history tracking
-            if not os.path.exists(self.signals_dir):
-                os.makedirs(self.signals_dir, exist_ok=True)
-                
-            # Save to signals directory
-            with open(f"{self.signals_dir}/{signal_id}.json", 'w') as f:
-                json.dump(normalized_data, f)
-            
-            # FOR TESTING: Always send to admin for testing
-            if hasattr(self, 'admin_users') and self.admin_users:
-                try:
-                    logger.info(f"Sending signal to admin users for testing: {self.admin_users}")
-                    for admin_id in self.admin_users:
-                        # Prepare keyboard with analysis options
-                        keyboard = [
-                            [InlineKeyboardButton("Analyze Market", callback_data=f"analyze_from_signal_{instrument}_{signal_id}")]
-                        ]
-                        
-                        # Send the signal
-                        await self.bot.send_message(
-                            chat_id=admin_id,
-                            text=message,
-                            parse_mode=ParseMode.HTML,
-                            reply_markup=InlineKeyboardMarkup(keyboard)
-                        )
-                        logger.info(f"Test signal sent to admin {admin_id}")
-                        
-                        # Store signal reference for quick access
-                        if not hasattr(self, 'user_signals'):
-                            self.user_signals = {}
-                            
-                        admin_str_id = str(admin_id)
-                        if admin_str_id not in self.user_signals:
-                            self.user_signals[admin_str_id] = {}
-                        
-                        self.user_signals[admin_str_id][signal_id] = normalized_data
-            except Exception as e:
-                logger.error(f"Error sending test signal to admin: {str(e)}")
-            
-            # Get subscribers for this instrument
-            timeframe = normalized_data.get('timeframe', 'one_hour')
-            subscribers = await self.get_subscribers_for_instrument(instrument, timeframe)
-            
-            if not subscribers:
-                logger.warning(f"No subscribers found for {instrument}")
-                return True  # Successfully processed, just no subscribers
-            
-            # Send signal to all subscribers
-            logger.info(f"Sending signal {signal_id} to {len(subscribers)} subscribers")
-            
-            sent_count = 0
-            for user_id in subscribers:
-                try:
-                    # Prepare keyboard with analysis options
-                    keyboard = [
-                        [InlineKeyboardButton("Analyze Market", callback_data=f"analyze_from_signal_{instrument}_{signal_id}")]
-                    ]
-                    
-                    # Send the signal
-                    await self.bot.send_message(
-                        chat_id=user_id,
-                        text=message,
-                        parse_mode=ParseMode.HTML,
-                        reply_markup=InlineKeyboardMarkup(keyboard)
-                    )
-                    
-                    sent_count += 1
-                    
-                    # Store signal reference for quick access
-                    if not hasattr(self, 'user_signals'):
-                        self.user_signals = {}
-                        
-                    user_str_id = str(user_id)
-                    if user_str_id not in self.user_signals:
-                        self.user_signals[user_str_id] = {}
-                    
-                    self.user_signals[user_str_id][signal_id] = normalized_data
-                    
-            except Exception as e:
-                logger.error(f"Error sending signal to user {user_id}: {str(e)}")
-            
-            logger.info(f"Successfully sent signal {signal_id} to {sent_count}/{len(subscribers)} subscribers")
-            return True
-            
-    except Exception as e:
-        logger.error(f"Error processing signal: {str(e)}")
-        logger.exception(e)
-            return False
-
-    def _format_signal_message(self, signal_data: Dict[str, Any]) -> str:
-        """Format signal data into a nice message for Telegram"""
-    try:
-            # Extract fields from signal data
-            instrument = signal_data.get('instrument', 'Unknown')
-            direction = signal_data.get('direction', 'Unknown')
-            entry = signal_data.get('entry', 'Unknown')
-            stop_loss = signal_data.get('stop_loss')
-            take_profit = signal_data.get('take_profit')
-            timeframe = signal_data.get('timeframe', 'one_hour')
-            
-            # Get multiple take profit levels if available
-            tp1 = signal_data.get('tp1', take_profit)
-            tp2 = signal_data.get('tp2')
-            tp3 = signal_data.get('tp3')
-            
-            # Add emoji based on direction
-            direction_emoji = "üü¢" if direction.upper() == "BUY" else "üî¥"
-            
-            # Format the message with multiple take profits if available
-            message = "<b> New Trading Signal </b>\n"\n\n"
-            message += f"<b>Instrument:</b> {instrument}\n"
-            message += f"<b>Action:</b> {direction.upper()} {direction_emoji}\n\n"
-            message += f"<b>Entry Price:</b> {entry}\n"
-            
-            if stop_loss:
-                message += f"<b>Stop Loss:</b> {stop_loss} üî¥\n"
-            
-            # Add take profit levels
-            if tp1:
-                message += f"<b>Take Profit 1:</b> {tp1} \n"
-            if tp2:
-                message += f"<b>Take Profit 2:</b> {tp2} \n"
-            if tp3:
-                message += f"<b>Take Profit 3:</b> {tp3} \n"
-            
-            message += f"\n<b>Timeframe:</b> {timeframe}\n"
-            message += f"<b>Strategy:</b> TradingView Signal\n\n"
-            
-            message += "‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî\n\n"
-            message += "<b>Risk Management:</b>\n"
-            message += "- Position size: 1-2% max\n"
-            message += "- Use proper stop loss\n"
-            message += "- Follow your trading plan\n\n"
-            
-            message += "‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî\n\n"
-            
-            # Generate AI verdict
-            ai_verdict = f"The {instrument} {direction.lower()} signal shows a promising setup with defined entry at {entry} and stop loss at {stop_loss}. Multiple take profit levels provide opportunities for partial profit taking."
-            message += f"<b>ü§ñ SigmaPips AI Verdict:</b>\n{ai_verdict}"
-            
-            return message
-            
-    except Exception as e:
-        logger.error(f"Error formatting signal message: {str(e)}")
-            # Return simple message on error
-            return f"New {signal_data.get('instrument', 'Unknown')} {signal_data.get('direction', 'Unknown')} Signal"
-
-    def _register_handlers(self, application):
-        """Register event handlers for bot commands and callback queries"""
-    try:
-            logger.info("Registering command handlers")
-            
-            # Initialize the application without using run_until_complete
-        try:
-                # Instead of using loop.run_until_complete, directly call initialize 
-                # which will be properly awaited by the caller
-                self.init_task = application.initialize()
-                logger.info("Telegram application initialization ready to be awaited")
-            except Exception as init_e:
-            logger.error(f"Error during application initialization: {str(init_e)}")
-            logger.exception(init_e)
-                
-            # Set bot commands for menu
-            commands = [
-                BotCommand("start", "Start the bot and get the welcome message"),
-                BotCommand("menu", "Show the main menu"),
-                BotCommand("help", "Show available commands and how to use the bot")
-            ]
-            
-            # Store the set_commands_task to be awaited later
-        try:
-                # Instead of asyncio.create_task, we will await this in the startup event
-                self.set_commands_task = self.bot.set_my_commands(commands)
-                logger.info("Bot commands ready to be set")
-            except Exception as cmd_e:
-            logger.error(f"Error preparing bot commands: {str(cmd_e)}")
-            
-            # Register command handlers
-            application.add_handler(CommandHandler("start", self.start_command))
-            application.add_handler(CommandHandler("menu", self.menu_command))
-            application.add_handler(CommandHandler("help", self.help_command))
-            
-            # Register secret admin commands
-            application.add_handler(CommandHandler("set_subscription", self.set_subscription_command))
-            application.add_handler(CommandHandler("set_payment_failed", self.set_payment_failed_command))
-            logger.info("Registered secret admin commands")
-            
-            # Register callback handlers
-            application.add_handler(CallbackQueryHandler(self.menu_analyse_callback, pattern="^menu_analyse$"))
-            application.add_handler(CallbackQueryHandler(self.menu_signals_callback, pattern="^menu_signals$"))
-            application.add_handler(CallbackQueryHandler(self.signals_add_callback, pattern="^signals_add$"))
-            application.add_handler(CallbackQueryHandler(self.signals_manage_callback, pattern="^signals_manage$"))
-            application.add_handler(CallbackQueryHandler(self.market_callback, pattern="^market_"))
-            application.add_handler(CallbackQueryHandler(self.instrument_callback, pattern="^instrument_(?!.*_signals)"))
-            application.add_handler(CallbackQueryHandler(self.instrument_signals_callback, pattern="^instrument_.*_signals$"))
-            
-            # Add handler for back buttons
-            application.add_handler(CallbackQueryHandler(self.back_market_callback, pattern="^back_market$"))
-            application.add_handler(CallbackQueryHandler(self.back_instrument_callback, pattern="^back_instrument$"))
-            application.add_handler(CallbackQueryHandler(self.back_signals_callback, pattern="^back_signals$"))
-            application.add_handler(CallbackQueryHandler(self.back_menu_callback, pattern="^back_menu$"))
-            
-            # Analysis handlers for regular flow
-            application.add_handler(CallbackQueryHandler(self.analysis_technical_callback, pattern="^analysis_technical$"))
-            application.add_handler(CallbackQueryHandler(self.analysis_sentiment_callback, pattern="^analysis_sentiment$"))
-            application.add_handler(CallbackQueryHandler(self.analysis_calendar_callback, pattern="^analysis_calendar$"))
-            
-            # Analysis handlers for signal flow - with instrument embedded in callback
-            application.add_handler(CallbackQueryHandler(self.signal_technical_callback, pattern="^signal_flow_technical_.*$"))
-            application.add_handler(CallbackQueryHandler(self.signal_sentiment_callback, pattern="^signal_flow_sentiment_.*$"))
-            application.add_handler(CallbackQueryHandler(self.signal_calendar_callback, pattern="^signal_flow_calendar_.*$"))
-            
-            # Analysis handlers for signal flow - with instrument embedded in callback
-            application.add_handler(CallbackQueryHandler(self.signal_technical_callback, pattern="^signal_flow_technical_.*$"))
-            application.add_handler(CallbackQueryHandler(self.signal_sentiment_callback, pattern="^signal_flow_sentiment_.*$"))
-            application.add_handler(CallbackQueryHandler(self.analysis_calendar_callback, pattern="^signal_flow_calendar_.*$"))
-            
-            # Signal analysis flow handlers
-            application.add_handler(CallbackQueryHandler(self.signal_technical_callback, pattern="^signal_technical$"))
-            application.add_handler(CallbackQueryHandler(self.signal_sentiment_callback, pattern="^signal_sentiment$"))
-            application.add_handler(CallbackQueryHandler(self.signal_calendar_callback, pattern="^signal_calendar$"))
-            application.add_handler(CallbackQueryHandler(self.signal_calendar_callback, pattern="^signal_flow_calendar_.*$"))
-            application.add_handler(CallbackQueryHandler(self.back_to_signal_callback, pattern="^back_to_signal$"))
-            application.add_handler(CallbackQueryHandler(self.back_to_signal_analysis_callback, pattern="^back_to_signal_analysis$"))
-            
-            # Signal from analysis
-            application.add_handler(CallbackQueryHandler(self.analyze_from_signal_callback, pattern="^analyze_from_signal_.*$"))
-            
-            # Ensure back_instrument is properly handled
-            application.add_handler(CallbackQueryHandler(self.back_instrument_callback, pattern="^back_instrument$"))
-            
-            # Catch-all handler for any other callbacks
-            application.add_handler(CallbackQueryHandler(self.button_callback))
-            
-            # Don't load signals here - it will be done in initialize_services
-            # self._load_signals()
-            
-            logger.info("Bot setup completed successfully")
-            
-    except Exception as e:
-        logger.error(f"Error setting up bot handlers: {str(e)}")
-        logger.exception(e)
-
-    @property
-    def signals_enabled(self):
-        """Get whether signals processing is enabled"""
-        return self._signals_enabled
-    
-    @signals_enabled.setter
-    def signals_enabled(self, value):
-        """Set whether signals processing is enabled"""
-        self._signals_enabled = bool(value)
-        logger.info(f"Signal processing is now {'enabled' if value else 'disabled'}")
-
-        async def start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE = None) -> None:
-        """Send a welcome message when the bot is started."""
-        user = update.effective_user
-        user_id = user.id
-        first_name = user.first_name
-        
-        # Try to add the user to the database if they don't exist yet
-    try:
-            # Get user subscription since we can't check if user exists directly
-            existing_subscription = await self.db.get_user_subscription(user_id)
-            
-            if not existing_subscription:
-                # Add new user
-                logger.info(f"New user started: {user_id}, {first_name}")
-                await self.db.save_user(user_id, first_name, None, user.username)
-        else:
-                logger.info(f"Existing user started: {user_id}, {first_name}")
-                
-    except Exception as e:
-        logger.error(f"Error registering user: {str(e)}")
-        
-        # Check if the user has a subscription 
-        is_subscribed = await self.db.is_user_subscribed(user_id)
-        
-        # Check if payment has failed
-        payment_failed = await self.db.has_payment_failed(user_id)
-        
-        if is_subscribed and not payment_failed:
-            # For subscribed users, direct them to use the /menu command instead
-            await update.message.reply_text(
-                text="Welcome back! Please use the /menu command to access all features.",
-                parse_mode=ParseMode.HTML
-            )
-            return
-        elif payment_failed:
-            # Show payment failure message
-            failed_payment_text = f"""
- <b>Subscription Payment Failed</b> 
-
-Your subscription payment could not be processed and your service has been deactivated.
-
-To continue using Sigmapips AI and receive trading signals, please reactivate your subscription by clicking the button below.
-            """
-            
-            # Use direct URL link for reactivation
-            reactivation_url = "https://buy.stripe.com/9AQcPf3j63HL5JS145"
-            
-            # Create button for reactivation
-            keyboard = [
-                [InlineKeyboardButton("üîÑ Reactivate Subscription", url=reactivation_url)]
-            ]
-            
-            await update.message.reply_text(
-                text=failed_payment_text,
-                reply_markup=InlineKeyboardMarkup(keyboard),
-                parse_mode=ParseMode.HTML
-            )
-    else:
-            # Show the welcome message with trial option from the screenshot
-            welcome_text = """
- Welcome to Sigmapips AI! 
-
-Discover powerful trading signals for various markets:
-- Forex - Major and minor currency pairs
-
-- Crypto - Bitcoin, Ethereum and other top
- cryptocurrencies
-
-- Indices - Global market indices
-
-- Commodities - Gold, silver and oil
-
-Features:
- Real-time trading signals
-
- Multi-timeframe analysis (timeframes)
-
- Advanced chart analysis
-
- Sentiment indicators
-
- Economic calendar integration
-
-Start today with a FREE 14-day trial!
-            """
-            
-            # Use direct URL link instead of callback for the trial button
-            checkout_url = "https://buy.stripe.com/3cs3eF9Hu9256NW9AA"
-            
-            # Create buttons - Trial button goes straight to Stripe checkout
-            keyboard = [
-                [InlineKeyboardButton("üî• Start 14-day FREE Trial", url=checkout_url)]
-            ]
-            
-            # Gebruik de juiste welkomst-GIF URL
-            welcome_gif_url = "https://media.giphy.com/media/gSzIKNrqtotEYrZv7i/giphy.gif"
-            
-        try:
-                # Send the GIF with caption containing the welcome message
-                await update.message.reply_animation(
-                    animation=welcome_gif_url,
-                    caption=welcome_text,
-                    parse_mode=ParseMode.HTML,
-                    reply_markup=InlineKeyboardMarkup(keyboard)
-                )
-        except Exception as e:\n            logger.error(f"Error sending welcome GIF with caption: {str(e)}")
-                # Fallback to text-only message if GIF fails
-                await update.message.reply_text(
-                    text=welcome_text,
-                    parse_mode=ParseMode.HTML,
-                    reply_markup=InlineKeyboardMarkup(keyboard)
-                )
-            
-    async def set_subscription_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE = None) -> None:
-        """S  # Use direct URL link for reactivation
-                reactivation_url = "https://buy.stripe.com/9AQcPf3j63HL5JS145"
-                
-                # Create button for reactivation
-                keyboard = [
-                    [InlineKeyboardButton("üîÑ Reactivate Subscription", url=reactivation_url)]
-                ]
-                
-                # First send success message
-                await update.message.reply_text(message)
-                
-                # Then show payment failed interface
-                await update.message.reply_text(
-                    text=failed_payment_text,
-                    reply_markup=InlineKeyboardMarkup(keyboard),
-                    parse_mode=ParseMode.HTML
-                )
-            else:
-                message = f" Could not set payment failed status for user {chat_id}"
-            logger.error("Database returned failure")
-                await update.message.reply_text(message)
-                
-        except ValueError as e:
-            error_msg = f"Invalid argument. Chat ID must be a number. Error: {str(e)}"
-        logger.error(error_msg)
-            await update.message.reply_text(error_msg)
-    except Exception as e:
-            error_msg = f"Error setting payment failed status: {str(e)}"
-        logger.error(error_msg)
-            await update.message.reply_text(error_msg)
-
-    async def menu_analyse_callback(self, update: Update, context=None) -> int:
-        """Handle menu_analyse button press"""
-        query = update.callback_query
-        await query.answer()
-        
-        # Gebruik de juiste analyse GIF URL
-        gif_url = "https://media.giphy.com/media/gSzIKNrqtotEYrZv7i/giphy.gif"
-        
-        # Probeer eerst het huidige bericht te verwijderen en een nieuw bericht te sturen met de analyse GIF
-    try:
-            await query.message.delete()
-            await context.bot.send_animation(
-                chat_id=update.effective_chat.id,
-                animation=gif_url,\n                caption="Select your analysis type:",
-                reply_markup=InlineKeyboardMarkup(ANALYSIS_KEYBOARD),
-                parse_mode=ParseMode.HTML
-            )
-            return CHOOSE_ANALYSIS
-        except Exception as delete_error:
-        logger.warning(f"Could not delete message: {str(delete_error)}")
-            
-            # Als verwijderen mislukt, probeer de media te updaten
-        try:
-                await query.edit_message_media(
-                    media=InputMediaAnimation(
-                        media=gif_url,
-                        caption="Select your analysis type:"
-                    ),
-                    reply_markup=InlineKeyboardMarkup(ANALYSIS_KEYBOARD)
-                )
-                return CHOOSE_ANALYSIS
-            except Exception as media_error:
-            logger.warning(f"Could not update media: {str(media_error)}")
-                
-                # Als media update mislukt, probeer tekst te updaten
-            try:
-                    await query.edit_message_text(
-                        text="Select your analysis type:",
-                        reply_markup=InlineKeyboardMarkup(ANALYSIS_KEYBOARD),
-                        parse_mode=ParseMode.HTML
-                    )
-                except Exception as text_error:
-                    # Als tekst updaten mislukt, probeer bijschrift te updaten
-                    if "There is no text in the message to edit" in str(text_error):
-                    try:
-                            await query.edit_message_caption(
-                                caption="Select your analysis type:",
-                                reply_markup=InlineKeyboardMarkup(ANALYSIS_KEYBOARD),
-                                parse_mode=ParseMode.HTML
-                            )
-                        except Exception as caption_error:
-                        logger.error(f"Failed to update caption: {str(caption_error)}")
-                            # Laatste redmiddel: stuur een nieuw bericht
-                            await context.bot.send_animation(
-                                chat_id=update.effective_chat.id,
-                                animation=gif_url,
-                                caption="Select your analysis type:",
-                                reply_markup=InlineKeyboardMarkup(ANALYSIS_KEYBOARD),
-                                parse_mode=ParseMode.HTML
-                            )
-                    else:
-                    logger.error(f"Failed to update message: {str(text_error)}")
-                        # Laatste redmiddel: stuur een nieuw bericht
-                        await context.bot.send_animation(
-                            chat_id=update.effective_chat.id,
-                            animation=gif_url,
-                            caption="Select your analysis type:",
-                            reply_markup=InlineKeyboardMarkup(ANALYSIS_KEYBOARD),
-                            parse_mode=ParseMode.HTML
-                        )
-        
-        return CHOOSE_ANALYSIS
-
-    async def show_main_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE = None, skip_gif=False) -> None:
-        """Show the main menu when /menu command is used"""
-        # Use context.bot if available, otherwise use self.bot
-        bot = context.bot if context is not None else self.bot
-        
-        # Check if the user has a subscription
-        user_id = update.effective_user.id
-        is_subscribed = await self.db.is_user_subscribed(user_id)
-        payment_failed = await self.db.has_payment_failed(user_id)
-        
-        if is_subscribed and not payment_failed:
-            # Show the main menu for subscribed users
-            reply_markup = InlineKeyboardMarkup(START_KEYBOARD)
-            
-            # Forceer altijd de welkomst GIF
-            gif_url = "https://media.giphy.com/media/gSzIKNrqtotEYrZv7i/giphy.gif"
-            
-            # If we should show the GIF
-            if not skip_gif:
-            try:
-                    # For message commands we can use reply_animation
-                    if hasattr(update, 'message') and update.message:
-                        # Verwijder eventuele vorige berichten met callback query
-                        if hasattr(update, 'callback_query') and update.callback_query:
-                        try:
-                                await update.callback_query.message.delete()
-                            except Exception:
-                                pass
-                        
-                        # Send the GIF using regular animation method
-                        await update.message.reply_animation(
-                            animation=gif_url,
-                            caption=WELCOME_MESSAGE,
-                            parse_mode=ParseMode.HTML,
-                            reply_markup=reply_markup
-                        )
-                    else:
-                        # Voor callback_query, verwijder huidige bericht en stuur nieuw bericht
-                        if hasattr(update, 'callback_query') and update.callback_query:
-                        try:
-                                # Verwijder het huidige bericht
-                                await update.callback_query.message.delete()
-                                
-                                # Stuur nieuw bericht met de welkomst GIF
-                                await bot.send_animation(
-                                    chat_id=update.effective_chat.id,
-                                    animation=gif_url,
-                                    caption=WELCOME_MESSAGE,
-                                    parse_mode=ParseMode.HTML,
-                                    reply_markup=reply_markup
-                                )
-                        except Exception as e:\n                            logger.error(f"Failed to handle callback query: {str(e)}")
-                                # Valt terug op tekstwijziging als verwijderen niet lukt
-                                await update.callback_query.edit_message_text(
-                                    text=WELCOME_MESSAGE,
-                                    parse_mode=ParseMode.HTML,
-                                    reply_markup=reply_markup
-                                )
-                    else:
-                            # Final fallback - try to send a new message
-                            await bot.send_animation(
-                                chat_id=update.effective_chat.id,
-                                animation=gif_url,
-                                caption=WELCOME_MESSAGE,
-                                parse_mode=ParseMode.HTML,
-                                reply_markup=reply_markup
-                            )
-            except Exception as e:
-                logger.error(f"Failed to send menu GIF: {str(e)}")
-                    # Fallback to text-only approach
-                    if hasattr(update, 'message') and update.message:
-                        await update.message.reply_text(
-                            text=WELCOME_MESSAGE,
-                            parse_mode=ParseMode.HTML,
-                            reply_markup=reply_markup
-                        )
-                    else:
-                        await bot.send_message(
-                            chat_id=update.effective_chat.id,
-                            text=WELCOME_MESSAGE,
-                            parse_mode=ParseMode.HTML,
-                            reply_markup=reply_markup
-                        )
-                    else:
-                # Skip GIF mode - just send text
-                if hasattr(update, 'message') and update.message:
-                    await update.message.reply_text(
-                        text=WELCOME_MESSAGE,
-                        parse_mode=ParseMode.HTML,
-                        reply_markup=reply_markup
-                    )
-                else:
-                    await bot.send_message(
-                        chat_id=update.effective_chat.id,
-                        text=WELCOME_MESSAGE,
-                        parse_mode=ParseMode.HTML,
-                        reply_markup=reply_markup
-                    )
-    else:
-            # Handle non-subscribed users similar to start command
-            await self.start_command(update, context)
-            
-    async def help_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE = None) -> None:
-        """Send a message when the command /help is issued."""
-        await self.show_main_menu(update, context)
-        
-    async def menu_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE = None) -> None:
-        """Send a message when the command /menu is issued."""
-        await self.show_main_menu(update, context)
-        
-    async def analysis_technical_callback(self, update: Update, context=None) -> int:
-        """Handle analysis_technical button press"""
-        query = update.callback_query
-        await query.answer()
-        
-        # Check if signal-specific data is present in callback data
-        if context and hasattr(context, 'user_data'):
-            # Reset signal flow flags
-            context.user_data['from_signal'] = False
-            context.user_data['in_signal_flow'] = False
-            logger.info(f"Reset signal flow flags: from_signal=False, in_signal_flow=False")
-            context.user_data['analysis_type'] = 'technical'
-        
-        # Set the callback data
-        callback_data = query.data
-        
-        # Set the instrument if it was passed in the callback data
-        if callback_data.startswith("signal_flow_technical_"):
-            # Extract instrument from the callback data
-            instrument = callback_data.replace("signal_flow_technical_", "")
-            if context and hasattr(context, 'user_data'):
-                # Reset signal flow flags
-                context.user_data['from_signal'] = False
-                context.user_data['in_signal_flow'] = False
-                logger.info(f"Reset signal flow flags: from_signal=False, in_signal_flow=False")
-                context.user_data['instrument'] = instrument
-            
-                logger.info(f"Technical analysis for specific instrument: {instrument}")
-            
-            # Show analysis directly for this instrument
-            return await self.show_technical_analysis(update, context, instrument=instrument)
-        
-        # Show the market selection menu
-    try:
-            # First try to edit message text
-            await query.edit_message_text(
-                text="Select market for technical analysis:",
-                reply_markup=InlineKeyboardMarkup(MARKET_KEYBOARD)
-            )
-        except Exception as text_error:
-            # If that fails due to caption, try editing caption
-            if "There is no text in the message to edit" in str(text_error):
-            try:
-                    await query.edit_message_caption(
-                        caption="Select market for technical analysis:",
-                        reply_markup=InlineKeyboardMarkup(MARKET_KEYBOARD),
-                        parse_mode=ParseMode.HTML
-                    )
-            except Exception as e:
-                logger.error(f"Failed to update caption in analysis_technical_callback: {str(e)}")
-                    # Try to send a new message as last resort
-                    await query.message.reply_text(
-                        text="Select market for technical analysis:",
-                        reply_markup=InlineKeyboardMarkup(MARKET_KEYBOARD),
-                        parse_mode=ParseMode.HTML
-                    )
-                else:
-                # Re-raise for other errors
-                raise
-        
-        return CHOOSE_MARKET
-        
-    async def analysis_sentiment_callback(self, update: Update, context=None) -> int:
-        """Handle analysis_sentiment button press"""
-        query = update.callback_query
-        await query.answer()
-        
-        if context and hasattr(context, 'user_data'):
-            # Reset signal flow flags
-            context.user_data['from_signal'] = False
-            context.user_data['in_signal_flow'] = False
-            logger.info(f"Reset signal flow flags: from_signal=False, in_signal_flow=False")
-            context.user_data['analysis_type'] = 'sentiment'
-        
-        # Set the callback data
-        callback_data = query.data
-        
-        # Set the instrument if it was passed in the callback data
-        if callback_data.startswith("signal_flow_sentiment_"):
-            # Extract instrument from the callback data
-            instrument = callback_data.replace("signal_flow_sentiment_", "")
-            if context and hasattr(context, 'user_data'):
-                # Reset signal flow flags
-                context.user_data['from_signal'] = False
-                context.user_data['in_signal_flow'] = False
-                logger.info(f"Reset signal flow flags: from_signal=False, in_signal_flow=False")
-                context.user_data['instrument'] = instrument
-            
-                logger.info(f"Sentiment analysis for specific instrument: {instrument}")
-            
-            # Show analysis directly for this instrument
-            return await self.show_sentiment_analysis(update, context, instrument=instrument)
-            
-        # Show the market selection menu
-    try:
-            # First try to edit message text
-            await query.edit_message_text(
-                text="Select market for sentiment analysis:",
-                reply_markup=InlineKeyboardMarkup(MARKET_KEYBOARD)
-            )
-        except Exception as text_error:
-            # If that fails due to caption, try editing caption
-            if "There is no text in the message to edit" in str(text_error):
-            try:
-                    await query.edit_message_caption(
-                        caption="Select market for sentiment analysis:",
-                        reply_markup=InlineKeyboardMarkup(MARKET_KEYBOARD),
-                        parse_mode=ParseMode.HTML
-                    )
-            except Exception as e:
-                logger.error(f"Failed to update caption in analysis_sentiment_callback: {str(e)}")
-                    # Try to send a new message as last resort
-                    await query.message.reply_text(
-                        text="Select market for sentiment analysis:",
-                        reply_markup=InlineKeyboardMarkup(MARKET_KEYBOARD),
-                        parse_mode=ParseMode.HTML
-                    )
-                else:
-                # Re-raise for other errors
-                raise
-        
-        return CHOOSE_MARKET
-        
-    async def analysis_calendar_callback(self, update: Update, context=None) -> int:
-        """Handle analysis_calendar button press"""
-        query = update.callback_query
-        await query.answer()
-        
-        if context and hasattr(context, 'user_data'):
-            # Reset signal flow flags
-            context.user_data['from_signal'] = False
-            context.user_data['in_signal_flow'] = False
-            logger.info(f"Reset signal flow flags: from_signal=False, in_signal_flow=False")
-            context.user_data['analysis_type'] = 'calendar'
-            
-        # Set the callback data
-        callback_data = query.data
-        
-        # Set the instrument if it was passed in the callback data
-        if callback_data.startswith("signal_flow_calendar_"):
-            # Extract instrument from the callback data
-            instrument = callback_data.replace("signal_flow_calendar_", "")
-            if context and hasattr(context, 'user_data'):
-                # Reset signal flow flags
-                context.user_data['from_signal'] = False
-                context.user_data['in_signal_flow'] = False
-                logger.info(f"Reset signal flow flags: from_signal=False, in_signal_flow=False")
-                context.user_data['instrument'] = instrument
-            
-                logger.info(f"Calendar analysis for specific instrument: {instrument}")
-            
-            # Show analysis directly for this instrument
-            return await self.show_calendar_analysis(update, context, instrument=instrument)
-        
-        # Skip market selection and go directly to calendar analysis
-        logger.info("Showing economic calendar without market selection")
-        return await self.show_calendar_analysis(update, context)
-
-    async def show_economic_calendar(self, update: Update, context: CallbackContext, currency=None, loading_message=None):
-        """Show the economic calendar for a specific currency"""
-    try:
-            # VERIFICATION MARKER: SIGMAPIPS_CALENDAR_FIX_APPLIED
-            self.logger.info("VERIFICATION MARKER: SIGMAPIPS_CALENDAR_FIX_APPLIED")
-            
-            chat_id = update.effective_chat.id
-            query = update.callback_query
-            
-            # Log that we're showing the calendar
-            self.logger.info(f"Showing economic calendar for all major currencies")
-            
-            # Initialize the calendar service
-            calendar_service = self._get_calendar_service()
-            cache_size = len(getattr(calendar_service, 'cache', {}))
-            self.logger.info(f"Calendar service initialized, cache size: {cache_size}")
-            
-            # Check if API key is available
-            tavily_api_key = os.environ.get("TAVILY_API_KEY", "")
-            if tavily_api_key:
-                masked_key = f"{tavily_api_key[:4]}..." if len(tavily_api_key) > 7 else "***"
-                self.logger.info(f"Tavily API key is available: {masked_key}")
-        else:
-                self.logger.warning("No Tavily API key found, will use mock data")
-            
-            # Get calendar data for ALL major currencies, regardless of the supplied parameter
-            self.logger.info(f"Requesting calendar data for all major currencies")
-            
-            calendar_data = []
-            
-            # Get all currencies data
-        try:
-                if hasattr(calendar_service, 'get_calendar'):
-                    calendar_data = await calendar_service.get_calendar()
-            else:
-                    self.logger.warning("calendar_service.get_calendar method not available, using mock data")
-                    calendar_data = []
-        except Exception as e:
-                self.logger.warning(f"Error getting calendar data: {str(e)}")
-                calendar_data = []
-            
-            # Check if data is empty
-            if not calendar_data or len(calendar_data) == 0:
-                self.logger.warning("Calendar data is empty, using mock data...")
-                # Generate mock data
-                today_date = datetime.now().strftime("%B %d, %Y")
-                
-                # Use the mock data generator from the calendar service if available
-                if hasattr(calendar_service, '_generate_mock_calendar_data'):
-                    mock_data = calendar_service._generate_mock_calendar_data(MAJOR_CURRENCIES, today_date)
-            else:
-                    # Otherwise use our own implementation
-                    mock_data = self._generate_mock_calendar_data(MAJOR_CURRENCIES, today_date)
-                
-                # Flatten the mock data
-                flattened_mock = []
-                for currency_code, events in mock_data.items():
-                    for event in events:
-                        flattened_mock.append({
-                            "time": event.get("time", ""),
-                            "country": currency_code,
-                            "country_flag": CURRENCY_FLAG.get(currency_code, ""),
-                            "title": event.get("event", ""),
-                            "impact": event.get("impact", "Low")
-                        })
-                
-                calendar_data = flattened_mock
-                self.logger.info(f"Generated {len(flattened_mock)} mock calendar events")
-            
-            # Format the calendar data in chronological order
-            if hasattr(self, '_format_calendar_events'):
-                message = await self._format_calendar_events(calendar_data)
-        else:
-                # Fallback to calendar service formatting if the method doesn't exist on TelegramService
-                if hasattr(calendar_service, '_format_calendar_response'):
-                    message = await calendar_service._format_calendar_response(calendar_data, "ALL")
-            else:
-                    # Simple formatting fallback
-                    message = "<b>Economic Calendar</b>\n\n"
-                    for event in calendar_data[:10]:  # Limit to first 10 events
-                        country = event.get('country', 'Unknown')
-                        title = event.get('title', 'Unknown Event')
-                        time = event.get('time', 'Unknown Time')
-                        message += f"{country}: {time} - {title}\n\n"
-            
-            # Create keyboard with back button if not provided from caller
-            keyboard = None
-            if context and hasattr(context, 'user_data') and context.user_data.get('from_signal', False):
-                keyboard = InlineKeyboardMarkup([[InlineKeyboardButton("Back", callback_data="back_to_signal_analysis")]])
-        else:
-                keyboard = InlineKeyboardMarkup([[InlineKeyboardButton("Back", callback_data="menu_analyse")]])
-            
-            # Try to delete loading message first if it exists
-            if loading_message:
-            try:
-                    await loading_message.delete()
-                    self.logger.info("Successfully deleted loading message")
-                except Exception as delete_error:
-                    self.logger.warning(f"Could not delete loading message: {str(delete_error)}")
-                    
-                    # If deletion fails, try to edit it
-                try:
-                        await context.bot.edit_message_text(
-                            chat_id=chat_id,
-                            message_id=loading_message.message_id,
-                            text=message,
-                            parse_mode=ParseMode.HTML,
-                            reply_markup=keyboard
-                        )
-                        self.logger.info("Edited loading message with calendar data")
-                        return  # Skip sending a new message
-                    except Exception as edit_error:
-                        self.logger.warning(f"Could not edit loading message: {str(edit_error)}")
-            
-            # Send the message as a new message
-            await context.bot.send_message(
-                chat_id=chat_id,
-                text=message,
-                parse_mode=ParseMode.HTML,
-                reply_markup=keyboard
-            )
-            self.logger.info("Sent calendar data as new message")
-        
-        except Exception as e:
-            self.logger.error(f"Error showing economic calendar: {str(e)}")
-            self.logger.exception(e)
-            
-            # Send error message
-            chat_id = update.effective_chat.id
-            await context.bot.send_message(
-                chat_id=chat_id,
-                text="<b> Error showing economic calendar</b>\n\nSorry, there was an error retrieving the economic calendar data. Please try again later.",
-                parse_mode=ParseMode.HTML
-            )
-            
-    def _generate_mock_calendar_data(self, currencies, date):
-        """Generate mock calendar data if the real service fails"""
-        self.logger.info(f"Generating mock calendar data for {len(currencies)} currencies")
-        mock_data = {}
-        
-        # Impact levels
-        impact_levels = ["High", "Medium", "Low"]
-        
-        # Possible event titles
-        events = [
-            "Interest Rate Decision",
-            "Non-Farm Payrolls",
-            "GDP Growth Rate",
-            "Inflation Rate",
-            "Unemployment Rate",
-            "Retail Sales",
-            "Manufacturing PMI",
-            "Services PMI",
-            "Trade Balance",
-            "Consumer Confidence",
-            "Building Permits",
-            "Central Bank Speech",
-            "Housing Starts",
-            "Industrial Production"
-        ]
-        
-        # Generate random events for each currency
-        for currency in currencies:
-            num_events = random.randint(1, 5)  # Random number of events per currency
-            currency_events = []
-            
-            for _ in range(num_events):
-                # Generate a random time (hour between 7-18, minute 00, 15, 30 or 45)
-                hour = random.randint(7, 18)
-                minute = random.choice([0, 15, 30, 45])
-                time_str = f"{hour:02d}:{minute:02d} EST"
-                
-                # Random event and impact
-                event = random.choice(events)
-                impact = random.choice(impact_levels)
-                
-                currency_events.append({
-                    "time": time_str,
-                    "event": event,
-                    "impact": impact
-                })
-            
-            # Sort events by time
-            mock_data[currency] = sorted(currency_events, key=lambda x: x["time"])
-        
-        return mock_data
-
-    async def signal_technical_callback(self, update: Update, context=None) -> int:
-        """Handle signal_technical button press"""
-        query = update.callback_query
-        await query.answer()
-        
-        # Add detailed debug logging
-        logger.info(f"signal_technical_callback called with query data: {query.data}")
-        
-        # Save analysis type in context
-        if context and hasattr(context, 'user_data'):
-            # Reset signal flow flags
-            context.user_data['from_signal'] = False
-            context.user_data['in_signal_flow'] = False
-            logger.info(f"Reset signal flow flags: from_signal=False, in_signal_flow=False")
-            context.user_data['analysis_type'] = 'technical'
-        
-        # Get the instrument from context
-        instrument = None
-        if context and hasattr(context, 'user_data'):
-            # Reset signal flow flags
-            context.user_data['from_signal'] = False
-            context.user_data['in_signal_flow'] = False
-            logger.info(f"Reset signal flow flags: from_signal=False, in_signal_flow=False")
-            instrument = context.user_data.get('instrument')
-            # Debug log for instrument
-            logger.info(f"Instrument from context: {instrument}")
-        
-        # Check if the callback data contains an instrument (signal_flow pattern)
-        if query.data.startswith("signal_flow_technical_"):
-            parts = query.data.split("_")
-            if len(parts) >= 4:
-                instrument = parts[3]  # Extract instrument from callback data
-                logger.info(f"Extracted instrument from callback data: {instrument}")
-                # Save to context
-                if context and hasattr(context, 'user_data'):
-                    # Reset signal flow flags
-                    context.user_data['from_signal'] = False
-                    context.user_data['in_signal_flow'] = False
-                    logger.info(f"Reset signal flow flags: from_signal=False, in_signal_flow=False")
-                    context.user_data['instrument'] = instrument
-        
-        if instrument:
-            # Set flag to indicate we're in signal flow
-            if context and hasattr(context, 'user_data'):
-                # Reset signal flow flags
-                context.user_data['from_signal'] = False
-                context.user_data['in_signal_flow'] = False
-                logger.info(f"Reset signal flow flags: from_signal=False, in_signal_flow=False")
-                context.user_data['from_signal'] = True
-                logger.info("Set from_signal flag to True")
-            
-            # Try to show loading animation first
-            loading_gif_url = "https://media.giphy.com/media/gSzIKNrqtotEYrZv7i/giphy.gif"\n            loading_text = f"Loading {instrument} chart..."
-            
-            # Store the current message ID to ensure we can find it later
-            message_id = query.message.message_id
-            chat_id = update.effective_chat.id
-            logger.info(f"Current message_id: {message_id}, chat_id: {chat_id}")
-            
-            loading_message = None
-            
-        try:
-                # Try to update with animated GIF first (best visual experience)
-                await query.edit_message_media(
-                    media=InputMediaAnimation(
-                        media=loading_gif_url,
-                        caption=loading_text
-                    )
-                )
-                logger.info(f"Successfully showed loading GIF for {instrument}")
-            except Exception as media_error:
-            logger.warning(f"Could not update with GIF: {str(media_error)}")
-                
-                # If GIF fails, try to update the text
-            try:
-                    loading_message = await query.edit_message_text(
-                        text=loading_text
-                    )
-                    if context and hasattr(context, 'user_data'):
-                        # Reset signal flow flags
-                        context.user_data['from_signal'] = False
-                        context.user_data['in_signal_flow'] = False
-                        logger.info(f"Reset signal flow flags: from_signal=False, in_signal_flow=False")
-                        context.user_data['loading_message'] = loading_message
-                except Exception as text_error:
-                logger.warning(f"Could not update text: {str(text_error)}")
-                    
-                    # If text update fails, try to update caption
-                try:
-                        await query.edit_message_caption(
-                            caption=loading_text
-                        )
-                    except Exception as caption_error:
-                    logger.warning(f"Could not update caption: {str(caption_error)}")
-                        
-                        # Last resort - send a new message with loading GIF
-                    try:
-                            from trading_bot.services.telegram_service.gif_utils import send_loading_gif
-                            await send_loading_gif(
-                                self.bot,
-                                update.effective_chat.id,
-                                caption=f"‚è≥ <b>Analyzing technical data for {instrument}...</b>"
-                            )
-                        except Exception as gif_error:
-                        logger.warning(f"Could not show loading GIF: {str(gif_error)}")
-            
-            # Show technical analysis for this instrument
-            return await self.show_technical_analysis(update, context, instrument=instrument)
-    else:
-            # Error handling - go back to signal analysis menu
-        try:
-                # First try to edit message text
-                await query.edit_message_text(
-                    text="Could not find the instrument. Please try again.",
-                    reply_markup=InlineKeyboardMarkup(SIGNAL_ANALYSIS_KEYBOARD)
-                )
-            except Exception as text_error:
-                # If that fails due to caption, try editing caption
-                if "There is no text in the message to edit" in str(text_error):
-                try:
-                        await query.edit_message_caption(
-                            caption="Could not find the instrument. Please try again.",
-                            reply_markup=InlineKeyboardMarkup(SIGNAL_ANALYSIS_KEYBOARD),
-                            parse_mode=ParseMode.HTML
-                        )
-                except Exception as e:
-                    logger.error(f"Failed to update caption in signal_technical_callback: {str(e)}")
-                        # Try to send a new message as last resort
-                        await query.message.reply_text(
-                            text="Could not find the instrument. Please try again.",
-                            reply_markup=InlineKeyboardMarkup(SIGNAL_ANALYSIS_KEYBOARD),
-                            parse_mode=ParseMode.HTML
-                        )
-                    else:
-                    # Re-raise for other errors
-                    raise
-            return CHOOSE_ANALYSIS
-
-    async def signal_sentiment_callback(self, update: Update, context=None) -> int:
-        """Handle signal_sentiment button press"""
-        query = update.callback_query
-        await query.answer()
-        
-        # Save analysis type in context
-        if context and hasattr(context, 'user_data'):
-            # Reset signal flow flags
-            context.user_data['from_signal'] = False
-            context.user_data['in_signal_flow'] = False
-            logger.info(f"Reset signal flow flags: from_signal=False, in_signal_flow=False")
-            context.user_data['analysis_type'] = 'sentiment'
-        
-        # Get the instrument from context
-        instrument = None
-        if context and hasattr(context, 'user_data'):
-            # Reset signal flow flags
-            context.user_data['from_signal'] = False
-            context.user_data['in_signal_flow'] = False
-            logger.info(f"Reset signal flow flags: from_signal=False, in_signal_flow=False")
-            instrument = context.user_data.get('instrument')
-            logger.info(f"Instrument from context: {instrument}")
-        
-        # Check if the callback data contains an instrument (signal_flow pattern)
-        if query.data.startswith("signal_flow_sentiment_"):
-            parts = query.data.split("_")
-            if len(parts) >= 4:
-                instrument = parts[3]  # Extract instrument from callback data
-                logger.info(f"Extracted instrument from callback data: {instrument}")
-                # Save to context
-                if context and hasattr(context, 'user_data'):
-                    # Reset signal flow flags
-                    context.user_data['from_signal'] = False
-                    context.user_data['in_signal_flow'] = False
-                    logger.info(f"Reset signal flow flags: from_signal=False, in_signal_flow=False")
-                    context.user_data['instrument'] = instrument
-                    logger.info(f"Instrument from context: {instrument}")
-        
-        if instrument:
-            # Set flag to indicate we're in signal flow
-            if context and hasattr(context, 'user_data'):
-                # Reset signal flow flags
-                context.user_data['from_signal'] = False
-                context.user_data['in_signal_flow'] = False
-                logger.info(f"Reset signal flow flags: from_signal=False, in_signal_flow=False")
-                context.user_data['from_signal'] = True
-            
-            # Try to show loading animation first
-            loading_gif_url = "https://media.giphy.com/media/gSzIKNrqtotEYrZv7i/giphy.gif"\n            loading_text = f"Loading sentiment analysis for {instrument}..."
-            
-        try:
-                # Try to update with animated GIF first (best visual experience)
-                await query.edit_message_media(
-                    media=InputMediaAnimation(
-                        media=loading_gif_url,
-                        caption=loading_text
-                    )
-                )
-                logger.info(f"Successfully showed loading GIF for {instrument} sentiment analysis")
-            except Exception as media_error:
-            logger.warning(f"Could not update with GIF: {str(media_error)}")
-                
-                # If GIF fails, try to update the text
-            try:
-                    loading_message = await query.edit_message_text(
-                        text=loading_text
-                    )
-                    if context and hasattr(context, 'user_data'):
-                        # Reset signal flow flags
-                        context.user_data['from_signal'] = False
-                        context.user_data['in_signal_flow'] = False
-                        logger.info(f"Reset signal flow flags: from_signal=False, in_signal_flow=False")
-                        context.user_data['loading_message'] = loading_message
-                except Exception as text_error:
-                logger.warning(f"Could not update text: {str(text_error)}")
-                    
-                    # If text update fails, try to update caption
-                try:
-                        await query.edit_message_caption(
-                            caption=loading_text
-                        )
-                    except Exception as caption_error:
-                    logger.warning(f"Could not update caption: {str(caption_error)}")
-                        
-                        # Last resort - send a new message with loading GIF
-                    try:
-                            from trading_bot.services.telegram_service.gif_utils import send_loading_gif
-                            await send_loading_gif(
-                                self.bot,
-                                update.effective_chat.id,
-                                caption=f"‚è≥ <b>Analyzing market sentiment for {instrument}...</b>"
-                            )
-                        except Exception as gif_error:
-                        logger.warning(f"Could not show loading GIF: {str(gif_error)}")
-            
-            # Show sentiment analysis for this instrument
-            return await self.show_sentiment_analysis(update, context, instrument=instrument)
-    else:
-            # Error handling - go back to signal analysis menu
-        try:
-                # First try to edit message text
-                await query.edit_message_text(
-                    text="Could not find the instrument. Please try again.",
-                    reply_markup=InlineKeyboardMarkup(SIGNAL_ANALYSIS_KEYBOARD)
-                )
-            except Exception as text_error:
-                # If that fails due to caption, try editing caption
-                if "There is no text in the message to edit" in str(text_error):
-                try:
-                        await query.edit_message_caption(
-                            caption="Could not find the instrument. Please try again.",
-                            reply_markup=InlineKeyboardMarkup(SIGNAL_ANALYSIS_KEYBOARD),
-                            parse_mode=ParseMode.HTML
-                        )
-                except Exception as e:
-                    logger.error(f"Failed to update caption in signal_sentiment_callback: {str(e)}")
-                        # Try to send a new message as last resort
-                        await query.message.reply_text(
-                            text="Could not find the instrument. Please try again.",
-                            reply_markup=InlineKeyboardMarkup(SIGNAL_ANALYSIS_KEYBOARD),
-                            parse_mode=ParseMode.HTML
-                        )
-                    else:
-                # Re-raise for other errors
-                raise
-        return CHOOSE_ANALYSIS
-
-    async def signal_calendar_callback(self, update: Update, context=None) -> int:
-        """Handle signal_calendar button press"""
-        query = update.callback_query
-        await query.answer()
-        
-        # Add detailed debug logging
-        logger.info(f"signal_calendar_callback called with data: {query.data}")
-        
-        # Save analysis type in context
-        if context and hasattr(context, 'user_data'):
-            # Reset signal flow flags
-            context.user_data['from_signal'] = False
-            context.user_data['in_signal_flow'] = False
-            logger.info(f"Reset signal flow flags: from_signal=False, in_signal_flow=False")
-            context.user_data['analysis_type'] = 'calendar'
-            # Make sure we save the original signal data to return to later
-            signal_instrument = context.user_data.get('instrument')
-            signal_direction = context.user_data.get('signal_direction')
-            signal_timeframe = context.user_data.get('signal_timeframe') 
-            
-            # Save these explicitly to ensure they're preserved
-            context.user_data['signal_instrument_backup'] = signal_instrument
-            context.user_data['signal_direction_backup'] = signal_direction
-            context.user_data['signal_timeframe_backup'] = signal_timeframe
-            
-            # Log for debugging
-            logger.info(f"Saved signal data before calendar analysis: instrument={signal_instrument}, direction={signal_direction}, timeframe={signal_timeframe}")
-        
-        # Get the instrument from context (voor tracking van context en eventuele toekomstige functionaliteit)
-        instrument = None
-        if context and hasattr(context, 'user_data'):
-            # Reset signal flow flags
-            context.user_data['from_signal'] = False
-            context.user_data['in_signal_flow'] = False
-            logger.info(f"Reset signal flow flags: from_signal=False, in_signal_flow=False")
-            instrument = context.user_data.get('instrument')
-            logger.info(f"Instrument from context: {instrument}")
-        
-        # Check if the callback data contains an instrument (signal_flow pattern)
-        if query.data.startswith("signal_flow_calendar_"):
-            parts = query.data.split("_")
-            if len(parts) >= 4:
-                instrument = parts[3]  # Extract instrument from callback data
-                logger.info(f"Extracted instrument from callback data: {instrument}")
-                # Save to context
-                if context and hasattr(context, 'user_data'):
-                    # Reset signal flow flags
-                    context.user_data['from_signal'] = False
-                    context.user_data['in_signal_flow'] = False
-                    logger.info(f"Reset signal flow flags: from_signal=False, in_signal_flow=False")
-                    context.user_data['instrument'] = instrument
-                    logger.info(f"Instrument from context: {instrument}")
-        
-        # Check if the callback data contains an instrument
-        if query.data.startswith("signal_flow_calendar_"):
-            parts = query.data.split("_")
-            if len(parts) >= 4:
-                instrument = parts[3]  # Extract instrument from callback data
-                logger.info(f"Extracted instrument from callback data: {instrument}")
-                # Save to context
-                if context and hasattr(context, 'user_data'):
-                    # Reset signal flow flags
-                    context.user_data['from_signal'] = False
-                    context.user_data['in_signal_flow'] = False
-                    logger.info(f"Reset signal flow flags: from_signal=False, in_signal_flow=False")
-                    context.user_data['instrument'] = instrument
-        
-        # Set flag to indicate we're in signal flow
-        if context and hasattr(context, 'user_data'):
-                # Reset signal flow flags
-            context.user_data['from_signal'] = False
-            context.user_data['in_signal_flow'] = False
-            logger.info(f"Reset signal flow flags: from_signal=False, in_signal_flow=False")
-            context.user_data['from_signal'] = True
-            logger.info(f"Set from_signal flag to True for calendar analysis")
-        
-        # Try to show loading animation first
-        loading_gif_url = "https://media.giphy.com/media/gSzIKNrqtotEYrZv7i/giphy.gif"\n        loading_text = f"Loading economic calendar..."
-        
-    try:
-            # Try to update with animated GIF first (best visual experience)
-            await query.edit_message_media(
-                media=InputMediaAnimation(
-                    media=loading_gif_url,
-                    caption=loading_text
-                )
-            )
-            logger.info(f"Successfully showed loading GIF for economic calendar")
-        except Exception as media_error:
-        logger.warning(f"Could not update with GIF: {str(media_error)}")
-            
-            # If GIF fails, try to update the text
-        try:
-                loading_message = await query.edit_message_text(
-                    text=loading_text
-                )
-                if context and hasattr(context, 'user_data'):
-                    # Reset signal flow flags
-                    context.user_data['from_signal'] = False
-                    context.user_data['in_signal_flow'] = False
-                    logger.info(f"Reset signal flow flags: from_signal=False, in_signal_flow=False")
-                    context.user_data['loading_message'] = loading_message
-            except Exception as text_error:
-            logger.warning(f"Could not update text: {str(text_error)}")
-                
-                # If text update fails, try to update caption
-            try:
-                    await query.edit_message_caption(
-                        caption=loading_text
-                    )
-                except Exception as caption_error:
-                logger.warning(f"Could not update caption: {str(caption_error)}")
-                    
-                    # Last resort - send a new message with loading GIF
-                try:
-                        from trading_bot.services.telegram_service.gif_utils import send_loading_gif
-                        await send_loading_gif(
-                            self.bot,
-                            update.effective_chat.id,
-                            caption=f"‚è≥ <b>Loading economic calendar...</b>"
-                        )
-                    except Exception as gif_error:
-                    logger.warning(f"Could not show loading GIF: {str(gif_error)}")
-        
-        # Show calendar analysis for ALL major currencies
-        return await self.show_calendar_analysis(update, context, instrument=None)
-
-    
-    
-    async def analyze_from_signal_callback(self, update: Update, context=None) -> int:
-        """Handle Analyze Market button from signal notifications"""
-        query = update.callback_query
-        # Add query.answer() to acknowledge the callback
-        await query.answer()
-        logger.info(f"analyze_from_signal_callback called with data: {query.data}")
-        
-    try:
-            # Extract signal information from callback data
-            parts = query.data.split('_')
-            
-            # Format: analyze_from_signal_INSTRUMENT_SIGNALID
-            if len(parts) >= 4:
-                instrument = parts[3]
-                signal_id = parts[4] if len(parts) >= 5 else None
-                
-                # Store in context for other handlers
-                if context and hasattr(context, 'user_data'):
-                    # Reset signal flow flags
-                    context.user_data['from_signal'] = False
-                    context.user_data['in_signal_flow'] = False
-                    logger.info(f"Reset signal flow flags: from_signal=False, in_signal_flow=False")
-                    context.user_data['instrument'] = instrument
-                    if signal_id:
-                        context.user_data['signal_id'] = signal_id
-                    # Set signal flow flags (only once)
-                    context.user_data['from_signal'] = True
-                    context.user_data['in_signal_flow'] = True
-                    logger.info(f"Set signal flow flags: from_signal=True, in_signal_flow=True")
-                    
-                    # Make a backup copy to ensure we can return to signal later
-                    context.user_data['signal_instrument'] = instrument
-                    context.user_data['signal_instrument_backup'] = instrument
-                    if signal_id:
-                        context.user_data['signal_id_backup'] = signal_id
-                    
-                    # Also store info from the actual signal if available
-                    if str(update.effective_user.id) in self.user_signals and signal_id in self.user_signals[str(update.effective_user.id)]:
-                        signal = self.user_signals[str(update.effective_user.id)][signal_id]
-                        if signal:
-                            context.user_data['signal_direction'] = signal.get('direction')
-                            # Use interval or timeframe, whichever is available
-                            timeframe = signal.get('interval') or signal.get('timeframe')
-                            context.user_data['signal_timeframe'] = timeframe
-                            # Backup copies
-                            context.user_data['signal_timeframe_backup'] = timeframe
-                            context.user_data['signal_direction_backup'] = signal.get('direction')
-                
-                # Store the original signal page for later retrieval
-                await self._store_original_signal_page(update, context, instrument, signal_id)
-                
-                # Show analysis options for this instrument
-                keyboard = [
-                    [InlineKeyboardButton("Technical Analysis", callback_data=f"signal_flow_technical_{instrument}")],
-                    [InlineKeyboardButton("Market Sentiment", callback_data=f"signal_flow_sentiment_{instrument}")],
-                    [InlineKeyboardButton("Economic Calendar", callback_data=f"signal_flow_calendar_{instrument}")],
-                    [InlineKeyboardButton("Back to Signal", callback_data="back_to_signal")]
-                ]
-                
-                # Update the message with the analysis options
-                await query.edit_message_text(
-                    text=f"<b> Analyze {instrument}</b>\n\nSelect the type of analysis you want to perform:",
-                    reply_markup=InlineKeyboardMarkup(keyboard),
-                    parse_mode=ParseMode.HTML
-                )
-                
-                return CHOOSE_ANALYSIS
-        else:
-                # Invalid callback data
-                await query.edit_message_text(
-                    text="Invalid signal format. Please try again from the main menu.",
-                    reply_markup=InlineKeyboardMarkup(START_KEYBOARD)
-                )
-                return MENU
-    except Exception as e:
-        logger.error(f"Error in analyze_from_signal_callback: {str(e)}")
-        logger.exception(e)
-            
-            # Error recovery
-        try:
-                await query.edit_message_text(
-                    text="An error occurred. Please try again from the main menu.",
-                    reply_markup=InlineKeyboardMarkup(START_KEYBOARD)
-                )
-            except Exception:
-                pass
-            return MENU
-    except Exception as e:
-        logger.error(f"Error in analyze_from_signal_callback: {str(e)}")
-            # Error recovery
-        try:
-                await query.edit_message_text(
-                    text="An error occurred. Please try again from the main menu.",
-                    reply_markup=InlineKeyboardMarkup(START_KEYBOARD)
-                )
-            except Exception:
-                pass
-            return MENU
-
-    async def _store_original_signal_page(self, update: Update, context: ContextTypes.DEFAULT_TYPE, instrument: str, signal_id: str):
-        """Store the original signal page data for later retrieval"""
-    try:
-        # Fetch the signal data from the database
-            signal_data = await self.db.get_user_signals(update.effective_user.id, instrument)
-            
-            if signal_data:
-                # Prepare the signal page data
-                signal_page_data = {
-                    "instrument": instrument,
-                    "signal_id": signal_id,
-                    "message": signal_data[0].get('message'),
-                    "timestamp": signal_data[0].get('timestamp')
-                }
-                
-                # Save the signal page data to the database
-                await self.db.save_signal_page(update.effective_user.id, instrument, signal_page_data)
-                
-                logger.info(f"Original signal page data stored for {instrument} with signal ID {signal_id}")
-        else:
-            logger.warning(f"No signal data found for {instrument} with signal ID {signal_id}")
-    except Exception as e:
-        logger.error(f"Error storing original signal page: {str(e)}")
-        logger.exception(e)
-
-    async def _get_original_signal_page(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
-        """Retrieve the original signal page data for a given signal"""
-    try:
-        # Fetch the signal page data from the database
-            signal_page_data = await self.db.get_signal_page(update.effective_user.id, update.callback_query.data.split('_')[3])
-            
-            if signal_page_data:
-                return signal_page_data
-        else:
-            logger.warning(f"No signal page data found for signal ID {update.callback_query.data.split('_')[3]}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving original signal page: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _load_signals(self):
-        """Load signals from the database"""
-    try:
-        # Fetch all signals from the database
-            signals = await self.db.get_all_signals()
-            
-            if signals:
-                for signal in signals:
-                    self.user_signals[str(signal['user_id'])] = {signal['id']: signal}
-                logger.info(f"Loaded {len(signals)} signals from the database")
-        else:
-                logger.info("No signals found in the database")
-    except Exception as e:
-        logger.error(f"Error loading signals: {str(e)}")
-        logger.exception(e)
-
-    async def _cleanup_old_signals(self, max_age_days):
-        """Cleanup old signals from the database"""
-    try:
-            # Calculate the date threshold
-            threshold_date = datetime.now() - timedelta(days=max_age_days)
-            
-        # Fetch signals older than the threshold date
-            signals_to_delete = await self.db.get_old_signals(threshold_date)
-            
-            if signals_to_delete:
-                for signal in signals_to_delete:
-                    await self.db.delete_signal(signal['id'])
-                logger.info(f"Deleted {len(signals_to_delete)} old signals from the database")
-        else:
-                logger.info("No old signals found to delete")
-            
-            return len(signals_to_delete)
-    except Exception as e:
-        logger.error(f"Error cleaning up old signals: {str(e)}")
-        logger.exception(e)
-            return 0
-
-    async def _format_signal_message(self, signal_data):
-        """Format the signal message for display"""
-    try:
-            # Extract fields from signal data
-            instrument = signal_data.get('instrument', 'Unknown')
-            direction = signal_data.get('direction', 'Unknown')
-            entry = signal_data.get('entry', 'Unknown')
-            stop_loss = signal_data.get('stop_loss')
-            take_profit = signal_data.get('take_profit')
-            timeframe = signal_data.get('timeframe', 'one_hour')
-            
-            # Get multiple take profit levels if available
-            tp1 = signal_data.get('tp1', take_profit)
-            tp2 = signal_data.get('tp2')
-            tp3 = signal_data.get('tp3')
-            
-            # Add emoji based on direction
-            direction_emoji = "üü¢" if direction.upper() == "BUY" else "üî¥"
-            
-            # Format the message with multiple take profits if available
-            message = "<b> New Trading Signal </b>\n"\n\n"
-            message += f"<b>Instrument:</b> {instrument}\n"
-            message += f"<b>Action:</b> {direction.upper()} {direction_emoji}\n\n"
-            message += f"<b>Entry Price:</b> {entry}\n"
-            
-            if stop_loss:
-                message += f"<b>Stop Loss:</b> {stop_loss} üî¥\n"
-            
-            # Add take profit levels
-            if tp1:
-                message += f"<b>Take Profit 1:</b> {tp1} \n"
-            if tp2:
-                message += f"<b>Take Profit 2:</b> {tp2} \n"
-            if tp3:
-                message += f"<b>Take Profit 3:</b> {tp3} \n"
-            
-            message += f"\n<b>Timeframe:</b> {timeframe}\n"
-            message += f"<b>Strategy:</b> TradingView Signal\n\n"
-            
-            message += "‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî\n\n"
-            message += "<b>Risk Management:</b>\n"
-            message += "- Position size: 1-2% max\n"
-            message += "- Use proper stop loss\n"
-            message += "- Follow your trading plan\n\n"
-            
-            message += "‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî\n\n"
-            
-            # Generate AI verdict
-            ai_verdict = f"The {instrument} {direction.lower()} signal shows a promising setup with defined entry at {entry} and stop loss at {stop_loss}. Multiple take profit levels provide opportunities for partial profit taking."
-            message += f"<b>ü§ñ SigmaPips AI Verdict:</b>\n{ai_verdict}"
-            
-            return message
-    except Exception as e:
-        logger.error(f"Error formatting signal message: {str(e)}")
-        logger.exception(e)
-            return f"New {signal_data.get('instrument', 'Unknown')} {signal_data.get('direction', 'Unknown')} Signal"
-
-    async def _get_signal_details(self, signal_id):
-        """Retrieve signal details from the database"""
-    try:
-        # Fetch the signal data from the database
-            signal_data = await self.db.get_signal(signal_id)
-            
-            if signal_data:
-                return signal_data
-        else:
-            logger.warning(f"No signal data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving signal details: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_analysis(self, signal_id):
-        """Retrieve signal analysis from the database"""
-    try:
-        # Fetch the signal analysis data from the database
-            analysis_data = await self.db.get_signal_analysis(signal_id)
-            
-            if analysis_data:
-                return analysis_data
-        else:
-            logger.warning(f"No analysis data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving signal analysis: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_sentiment(self, signal_id):
-        """Retrieve signal sentiment from the database"""
-    try:
-        # Fetch the signal sentiment data from the database
-            sentiment_data = await self.db.get_signal_sentiment(signal_id)
-            
-            if sentiment_data:
-                return sentiment_data
-        else:
-            logger.warning(f"No sentiment data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving signal sentiment: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_calendar(self, signal_id):
-        """Retrieve signal calendar data from the database"""
-    try:
-        # Fetch the signal calendar data from the database
-            calendar_data = await self.db.get_signal_calendar(signal_id)
-            
-            if calendar_data:
-                return calendar_data
-        else:
-            logger.warning(f"No calendar data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving signal calendar: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_market(self, signal_id):
-        """Retrieve signal market data from the database"""
-    try:
-        # Fetch the signal market data from the database
-            market_data = await self.db.get_signal_market(signal_id)
-            
-            if market_data:
-                return market_data
-        else:
-            logger.warning(f"No market data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving signal market: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_trades(self, signal_id):
-        """Retrieve signal trades from the database"""
-    try:
-        # Fetch the signal trades data from the database
-        trades_data = await self.db.get_signal_trades(signal_id)
-            
-        if trades_data:
-            return trades_data
-        else:
-            logger.warning(f"No trades data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving signal trades: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_comments(self, signal_id):
-        """Retrieve signal comments from the database"""
-    try:
-        # Fetch the signal comments data from the database
-            comments_data = await self.db.get_signal_comments(signal_id)
-            
-            if comments_data:
-                return comments_data
-        else:
-            logger.warning(f"No comments data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving signal comments: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_attachments(self, signal_id):
-        """Retrieve signal attachments from the database"""
-    try:
-        # Fetch the signal attachments data from the database
-            attachments_data = await self.db.get_signal_attachments(signal_id)
-            
-            if attachments_data:
-                return attachments_data
-        else:
-            logger.warning(f"No attachments data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving signal attachments: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_notes(self, signal_id):
-        """Retrieve signal notes from the database"""
-    try:
-        # Fetch the signal notes data from the database
-            notes_data = await self.db.get_signal_notes(signal_id)
-            
-            if notes_data:
-                return notes_data
-        else:
-            logger.warning(f"No notes data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving signal notes: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_tags(self, signal_id):
-        """Retrieve signal tags from the database"""
-    try:
-        # Fetch the signal tags data from the database
-            tags_data = await self.db.get_signal_tags(signal_id)
-            
-            if tags_data:
-                return tags_data
-        else:
-            logger.warning(f"No tags data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving signal tags: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_signals(self, signal_id):
-        """Retrieve related signals from the database"""
-    try:
-        # Fetch the related signals data from the database
-            related_signals_data = await self.db.get_related_signals(signal_id)
-            
-            if related_signals_data:
-                return related_signals_data
-        else:
-            logger.warning(f"No related signals data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related signals: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_articles(self, signal_id):
-        """Retrieve related articles from the database"""
-    try:
-        # Fetch the related articles data from the database
-            articles_data = await self.db.get_related_articles(signal_id)
-            
-            if articles_data:
-                return articles_data
-        else:
-            logger.warning(f"No related articles data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related articles: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_videos(self, signal_id):
-        """Retrieve related videos from the database"""
-    try:
-        # Fetch the related videos data from the database
-            videos_data = await self.db.get_related_videos(signal_id)
-            
-            if videos_data:
-                return videos_data
-        else:
-            logger.warning(f"No related videos data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related videos: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_trades(self, signal_id):
-    """Retrieve related trades from the database"""
-    try:
-        # Fetch the related trades data from the database
-        trades_data = await self.db.get_related_trades(signal_id)
-            
-        if trades_data:
-            return trades_data
-        else:
-            logger.warning(f"No related trades data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related trades: {str(e)}")
-        logger.exception(e)
-        return None
-
-
-from telegram.error import TelegramError, BadRequest
-import httpx
-import telegram.error  # Add this import for BadRequest error handling
-
-from trading_bot.services.database.db import Database
-from trading_bot.services.chart_service.chart import ChartService
-from trading_bot.services.sentiment_service.sentiment import MarketSentimentService
-from trading_bot.services.calendar_service import EconomicCalendarService
-from trading_bot.services.payment_service.stripe_service import StripeService
-from trading_bot.services.payment_service.stripe_config import get_subscription_features
-from trading_bot.services.telegram_service.states import (
-    MENU, ANALYSIS, SIGNALS, CHOOSE_MARKET, CHOOSE_INSTRUMENT, CHOOSE_STYLE,
-    CHOOSE_ANALYSIS, SIGNAL_DETAILS,
-    CALLBACK_MENU_ANALYSE, CALLBACK_MENU_SIGNALS, CALLBACK_ANALYSIS_TECHNICAL,
-    CALLBACK_ANALYSIS_SENTIMENT, CALLBACK_ANALYSIS_CALENDAR, CALLBACK_SIGNALS_ADD,
-    CALLBACK_SIGNALS_MANAGE, CALLBACK_BACK_MENU
-)
-import trading_bot.services.telegram_service.gif_utils as gif_utils
-
-# Initialize logger
-logger = logging.getLogger(__name__)
-
-# Major currencies to focus on
-MAJOR_CURRENCIES = ["USD", "EUR", "GBP", "JPY", "CHF", "AUD", "NZD", "CAD"]
-
-# Currency to flag emoji mapping
-CURRENCY_FLAG = {
-    "USD": "üá∫üá∏",
-    "EUR": "üá™üá∫",
-    "GBP": "üá¨üáß",
-    "JPY": "üáØüáµ",
-    "CHF": "üá®üá≠",
-    "AUD": "üá¶üá∫",
-    "NZD": "üá≥üáø",
-    "CAD": "üá®üá¶"
-}
-
-# Map of instruments to their corresponding currencies
-INSTRUMENT_CURRENCY_MAP = {
-    # Special case for global view
-    "GLOBAL": MAJOR_CURRENCIES,
-    
-    # Forex
-    "EURUSD": ["EUR", "USD"],
-    "GBPUSD": ["GBP", "USD"],
-    "USDJPY": ["USD", "JPY"],
-    "USDCHF": ["USD", "CHF"],
-    "AUDUSD": ["AUD", "USD"],
-    "NZDUSD": ["NZD", "USD"],
-    "USDCAD": ["USD", "CAD"],
-    "EURGBP": ["EUR", "GBP"],
-    "EURJPY": ["EUR", "JPY"],
-    "GBPJPY": ["GBP", "JPY"],
-    
-    # Indices (mapped to their related currencies)
-    "US30": ["USD"],
-    "US100": ["USD"],
-    "US500": ["USD"],
-    "UK100": ["GBP"],
-    "GER40": ["EUR"],
-    "FRA40": ["EUR"],
-    "ESP35": ["EUR"],
-    "JP225": ["JPY"],
-    "AUS200": ["AUD"],
-    
-    # Commodities (mapped to USD primarily)
-    "XAUUSD": ["USD", "XAU"],  # Gold
-    "XAGUSD": ["USD", "XAG"],  # Silver
-    "USOIL": ["USD"],          # Oil (WTI)
-    "UKOIL": ["USD", "GBP"],   # Oil (Brent)
-    
-    # Crypto
-    "BTCUSD": ["USD", "BTC"],
-    "ETHUSD": ["USD", "ETH"],
-    "LTCUSD": ["USD", "LTC"],
-    "XRPUSD": ["USD", "XRP"]
-}
-
-# Callback data constants
-CALLBACK_ANALYSIS_TECHNICAL = "analysis_technical"
-CALLBACK_ANALYSIS_SENTIMENT = "analysis_sentiment"
-CALLBACK_ANALYSIS_CALENDAR = "analysis_calendar"
-CALLBACK_BACK_MENU = "back_menu"
-CALLBACK_BACK_ANALYSIS = "back_to_analysis"
-CALLBACK_BACK_MARKET = "back_market"
-CALLBACK_BACK_INSTRUMENT = "back_instrument"
-CALLBACK_BACK_SIGNALS = "back_signals"
-CALLBACK_SIGNALS_ADD = "signals_add"
-CALLBACK_SIGNALS_MANAGE = "signals_manage"
-CALLBACK_MENU_ANALYSE = "menu_analyse"
-CALLBACK_MENU_SIGNALS = "menu_signals"
-
-# States
-MENU = 0
-CHOOSE_ANALYSIS = 1
-CHOOSE_SIGNALS = 2
-CHOOSE_MARKET = 3
-CHOOSE_INSTRUMENT = 4
-CHOOSE_STYLE = 5
-SHOW_RESULT = 6
-CHOOSE_TIMEFRAME = 7
-SIGNAL_DETAILS = 8
-SIGNAL = 9
-SUBSCRIBE = 10
-BACK_TO_MENU = 11  # Add this line
-
-# Messages
-WELCOME_MESSAGE = r"""
-<b>Sigmapips AI - Main Menu</b>
-
-Choose an option to access advanced trading support:
-
-Services:
-- <b>Technical Analysis</b> - Real-time chart analysis and key levels
-
-- <b>Market Sentiment</b> - Understand market trends and sentiment
-
-- <b>Economic Calendar</b> - Stay updated on market-moving events
-
-- <b>Trading Signals</b> - Get precise entry/exit points for your favorite pairs
-
-Select your option to continue:
-"""
-
-# Abonnementsbericht voor nieuwe gebruikers
-SUBSCRIPTION_WELCOME_MESSAGE = r"""
-<b>Welcome to Sigmapips AI!</b>
-
-To access all features, you need a subscription:
-
-<b>Trading Signals Subscription - $29.99/month</b>
-- Access to all trading signals (Forex, Crypto, Commodities, Indices)
-- Advanced timeframe analysis
-- Detailed chart analysis for each signal
-
-Click the button below to subscribe:
-"""
-
-MENU_MESSAGE = r"""
-Welcome to Sigmapips AI!
-
-Choose a command:
-
-/start - Set up new trading pairs
-Add new market/instrument/timeframe combinations to receive signals
-
-/manage - Manage your preferences
-View, edit or delete your saved trading pairs
-
-Need help? Use /help to see all available commands.
-"""
-
-HELP_MESSAGE = r"""
-Available commands:
-/menu - Show main menu
-/start - Set up new trading pairs
-/help - Show this help message
-"""
-
-# Start menu keyboard
-START_KEYBOARD = [
-    [InlineKeyboardButton("Analyze Market", callback_data=CALLBACK_MENU_ANALYSE)],
-    [InlineKeyboardButton("Trading Signals", callback_data=CALLBACK_MENU_SIGNALS)]
-]
-
-# Analysis menu keyboard
-ANALYSIS_KEYBOARD = [
-    [InlineKeyboardButton("Technical Analysis", callback_data=CALLBACK_ANALYSIS_TECHNICAL)],
-    [InlineKeyboardButton("Market Sentiment", callback_data=CALLBACK_ANALYSIS_SENTIMENT)],
-    [InlineKeyboardButton("Economic Calendar", callback_data=CALLBACK_ANALYSIS_CALENDAR)],
-    [InlineKeyboardButton("Back", callback_data=CALLBACK_BACK_MENU)]
-]
-
-# Signals menu keyboard
-SIGNALS_KEYBOARD = [
-    [InlineKeyboardButton("Add New Pairs", callback_data=CALLBACK_SIGNALS_ADD)],
-    [InlineKeyboardButton("Manage Signals", callback_data=CALLBACK_SIGNALS_MANAGE)],
-    [InlineKeyboardButton("Back", callback_data=CALLBACK_BACK_MENU)]
-]
-
-# Market keyboard voor signals
-MARKET_KEYBOARD_SIGNALS = [
-    [InlineKeyboardButton("Forex", callback_data="market_forex_signals")],
-    [InlineKeyboardButton("Crypto", callback_data="market_crypto_signals")],
-    [InlineKeyboardButton("Commodities", callback_data="market_commodities_signals")],
-    [InlineKeyboardButton("Indices", callback_data="market_indices_signals")],
-    [InlineKeyboardButton("Back", callback_data="back_signals")]
-]
-
-# Market keyboard voor analyse
-MARKET_KEYBOARD = [
-    [InlineKeyboardButton("Forex", callback_data="market_forex")],
-    [InlineKeyboardButton("Crypto", callback_data="market_crypto")],
-    [InlineKeyboardButton("Commodities", callback_data="market_commodities")],
-    [InlineKeyboardButton("Indices", callback_data="market_indices")],
-    [InlineKeyboardButton("Back", callback_data="back_analysis")]
-]
-
-# Market keyboard specifiek voor sentiment analyse
-MARKET_SENTIMENT_KEYBOARD = [
-    [InlineKeyboardButton("Forex", callback_data="market_forex_sentiment")],
-    [InlineKeyboardButton("Crypto", callback_data="market_crypto_sentiment")],
-    [InlineKeyboardButton("Commodities", callback_data="market_commodities_sentiment")],
-    [InlineKeyboardButton("Indices", callback_data="market_indices_sentiment")],
-    [InlineKeyboardButton("Back", callback_data="back_analysis")]
-]
-
-# Forex keyboard voor technical analyse
-FOREX_KEYBOARD = [
-    [
-        InlineKeyboardButton("EURUSD", callback_data="instrument_EURUSD_chart"),
-        InlineKeyboardButton("GBPUSD", callback_data="instrument_GBPUSD_chart"),
-        InlineKeyboardButton("USDJPY", callback_data="instrument_USDJPY_chart")
-    ],
-    [
-        InlineKeyboardButton("AUDUSD", callback_data="instrument_AUDUSD_chart"),
-        InlineKeyboardButton("USDCAD", callback_data="instrument_USDCAD_chart"),
-        InlineKeyboardButton("EURGBP", callback_data="instrument_EURGBP_chart")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Forex keyboard voor sentiment analyse
-FOREX_SENTIMENT_KEYBOARD = [
-    [
-        InlineKeyboardButton("EURUSD", callback_data="instrument_EURUSD_sentiment"),
-        InlineKeyboardButton("GBPUSD", callback_data="instrument_GBPUSD_sentiment"),
-        InlineKeyboardButton("USDJPY", callback_data="instrument_USDJPY_sentiment")
-    ],
-    [
-        InlineKeyboardButton("AUDUSD", callback_data="instrument_AUDUSD_sentiment"),
-        InlineKeyboardButton("USDCAD", callback_data="instrument_USDCAD_sentiment"),
-        InlineKeyboardButton("EURGBP", callback_data="instrument_EURGBP_sentiment")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Forex keyboard voor kalender analyse
-FOREX_CALENDAR_KEYBOARD = [
-    [
-        InlineKeyboardButton("EURUSD", callback_data="instrument_EURUSD_calendar"),
-        InlineKeyboardButton("GBPUSD", callback_data="instrument_GBPUSD_calendar"),
-        InlineKeyboardButton("USDJPY", callback_data="instrument_USDJPY_calendar")
-    ],
-    [
-        InlineKeyboardButton("AUDUSD", callback_data="instrument_AUDUSD_calendar"),
-        InlineKeyboardButton("USDCAD", callback_data="instrument_USDCAD_calendar"),
-        InlineKeyboardButton("EURGBP", callback_data="instrument_EURGBP_calendar")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Crypto keyboard voor analyse
-CRYPTO_KEYBOARD = [
-    [
-        InlineKeyboardButton("BTCUSD", callback_data="instrument_BTCUSD_chart"),
-        InlineKeyboardButton("ETHUSD", callback_data="instrument_ETHUSD_chart"),
-        InlineKeyboardButton("XRPUSD", callback_data="instrument_XRPUSD_chart")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Signal analysis keyboard
-SIGNAL_ANALYSIS_KEYBOARD = [
-    [InlineKeyboardButton("Technical Analysis", callback_data="signal_technical")],
-    [InlineKeyboardButton("Market Sentiment", callback_data="signal_sentiment")],
-    [InlineKeyboardButton("Economic Calendar", callback_data="signal_calendar")],
-    [InlineKeyboardButton("Back", callback_data="back_to_signal")]
-]
-
-# Crypto keyboard voor sentiment analyse
-CRYPTO_SENTIMENT_KEYBOARD = [
-    [
-        InlineKeyboardButton("BTCUSD", callback_data="instrument_BTCUSD_sentiment"),
-        InlineKeyboardButton("ETHUSD", callback_data="instrument_ETHUSD_sentiment"),
-        InlineKeyboardButton("XRPUSD", callback_data="instrument_XRPUSD_sentiment")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Indices keyboard voor analyse
-INDICES_KEYBOARD = [
-    [
-        InlineKeyboardButton("US30", callback_data="instrument_US30_chart"),
-        InlineKeyboardButton("US500", callback_data="instrument_US500_chart"),
-        InlineKeyboardButton("US100", callback_data="instrument_US100_chart")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Indices keyboard voor signals - Fix de "Terug" knop naar "Back"
-INDICES_KEYBOARD_SIGNALS = [
-    [
-        InlineKeyboardButton("US30", callback_data="instrument_US30_signals"),
-        InlineKeyboardButton("US500", callback_data="instrument_US500_signals"),
-        InlineKeyboardButton("US100", callback_data="instrument_US100_signals")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Commodities keyboard voor analyse
-COMMODITIES_KEYBOARD = [
-    [
-        InlineKeyboardButton("GOLD", callback_data="instrument_XAUUSD_chart"),
-        InlineKeyboardButton("SILVER", callback_data="instrument_XAGUSD_chart"),
-        InlineKeyboardButton("OIL", callback_data="instrument_USOIL_chart")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Commodities keyboard voor signals - Fix de "Terug" knop naar "Back"
-COMMODITIES_KEYBOARD_SIGNALS = [
-    [
-        InlineKeyboardButton("XAUUSD", callback_data="instrument_XAUUSD_signals"),
-        InlineKeyboardButton("XAGUSD", callback_data="instrument_XAGUSD_signals"),
-        InlineKeyboardButton("USOIL", callback_data="instrument_USOIL_signals")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Forex keyboard for signals
-FOREX_KEYBOARD_SIGNALS = [
-    [
-        InlineKeyboardButton("EURUSD", callback_data="instrument_EURUSD_signals"),
-        InlineKeyboardButton("GBPUSD", callback_data="instrument_GBPUSD_signals"),
-        InlineKeyboardButton("USDJPY", callback_data="instrument_USDJPY_signals")
-    ],
-    [
-        InlineKeyboardButton("USDCAD", callback_data="instrument_USDCAD_signals"),
-        InlineKeyboardButton("EURGBP", callback_data="instrument_EURGBP_signals")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Crypto keyboard for signals
-CRYPTO_KEYBOARD_SIGNALS = [
-    [
-        InlineKeyboardButton("BTCUSD", callback_data="instrument_BTCUSD_signals"),
-        InlineKeyboardButton("ETHUSD", callback_data="instrument_ETHUSD_signals"),
-        InlineKeyboardButton("XRPUSD", callback_data="instrument_XRPUSD_signals")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Indices keyboard voor sentiment analyse
-INDICES_SENTIMENT_KEYBOARD = [
-    [
-        InlineKeyboardButton("US30", callback_data="instrument_US30_sentiment"),
-        InlineKeyboardButton("US500", callback_data="instrument_US500_sentiment"),
-        InlineKeyboardButton("US100", callback_data="instrument_US100_sentiment")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Commodities keyboard voor sentiment analyse
-COMMODITIES_SENTIMENT_KEYBOARD = [
-    [
-        InlineKeyboardButton("GOLD", callback_data="instrument_XAUUSD_sentiment"),
-        InlineKeyboardButton("SILVER", callback_data="instrument_XAGUSD_sentiment"),
-        InlineKeyboardButton("OIL", callback_data="instrument_USOIL_sentiment")
-    ],
-    [InlineKeyboardButton("Back", callback_data="back_market")]
-]
-
-# Style keyboard
-STYLE_KEYBOARD = [
-    [InlineKeyboardButton("‚ö° Test (one_min)", callback_data="style_test")],
-    [InlineKeyboardButton("üèÉ Scalp (fifteen_min)", callback_data="style_scalp")],
-    [InlineKeyboardButton(" Intraday (one_hour)", callback_data="style_intraday")],
-    [InlineKeyboardButton("üåä Swing (four_hour)", callback_data="style_swing")],
-    [InlineKeyboardButton("Back", callback_data="back_instrument")]
-]
-
-# Timeframe mapping
-STYLE_TIMEFRAME_MAP = {
-    "test": "one_min",
-    "scalp": "fifteen_min",
-    "intraday": "one_hour",
-    "swing": "four_hour"
-}
-
-# Mapping of instruments to their allowed timeframes - updated 2023-03-23
-INSTRUMENT_TIMEFRAME_MAP = {
-    # H1 timeframe only
-    "AUDJPY": "H1", 
-    "AUDCHF": "H1",
-    "EURCAD": "H1",
-    "EURGBP": "H1",
-    "GBPCHF": "H1",
-    "HK50": "H1",
-    "NZDJPY": "H1",
-    "USDCHF": "H1",
-    "USDJPY": "H1",  # USDJPY toegevoegd voor signaalabonnementen
-    "XRPUSD": "H1",
-    
-    # H4 timeframe only
-    "AUDCAD": "H4",
-    "AU200": "H4", 
-    "CADCHF": "H4",
-    "EURCHF": "H4",
-    "EURUSD": "H4",
-    "GBPCAD": "H4",
-    "LINKUSD": "H4",
-    "NZDCHF": "H4",
-    
-    # M15 timeframe only
-    "DOGEUSD": "M15",
-    "GBPNZD": "M15",
-    "NZDUSD": "M15",
-    "SOLUSD": "M15",
-    "UK100": "M15",
-    "XAUUSD": "M15",
-    
-    # M30 timeframe only
-    "BNBUSD": "M30",
-    "DOTUSD": "M30",
-    "ETHUSD": "M30",
-    "EURAUD": "M30",
-    "EURJPY": "M30",
-    "GBPAUD": "M30",
-    "GBPUSD": "M30",
-    "NZDCAD": "M30",
-    "US30": "M30",
-    "US500": "M30",
-    "USDCAD": "M30",
-    "XLMUSD": "M30",
-    "XTIUSD": "M30",
-    "DE40": "M30",
-    "BTCUSD": "M30",  # Added for consistency with CRYPTO_KEYBOARD_SIGNALS
-    "US100": "M30",   # Added for consistency with INDICES_KEYBOARD_SIGNALS
-    "XAGUSD": "M15",  # Added for consistency with COMMODITIES_KEYBOARD_SIGNALS
-    "USOIL": "M30"    # Added for consistency with COMMODITIES_KEYBOARD_SIGNALS
-    
-    # Removed as requested: EU50, FR40, LTCUSD
-}
-
-# Map common timeframe notations
-TIMEFRAME_DISPLAY_MAP = {
-    "M15": "15 Minutes",
-    "M30": "30 Minutes", 
-    "H1": "1 Hour",
-    "H4": "4 Hours"
-}
-
-# Voeg deze functie toe aan het begin van bot.py, na de imports
-def _detect_market(instrument: str) -> str:
-    """Detecteer market type gebaseerd op instrument"""
-    instrument = instrument.upper()
-    
-    # Commodities eerst checken
-    commodities = [
-        "XAUUSD",  # Gold
-        "XAGUSD",  # Silver
-        "WTIUSD",  # Oil WTI
-        "BCOUSD",  # Oil Brent
-        "USOIL",   # Oil WTI (alternative symbol)
-    ]
-    if instrument in commodities:
-        logger.info(f"Detected {instrument} as commodity")
-        return "commodities"
-    
-    # Crypto pairs
-    crypto_base = ["BTC", "ETH", "XRP", "SOL", "BNB", "ADA", "DOT", "LINK"]
-    if any(c in instrument for c in crypto_base):
-        logger.info(f"Detected {instrument} as crypto")
-        return "crypto"
-    
-    # Major indices
-    indices = [
-        "US30", "US500", "US100",  # US indices
-        "UK100", "DE40", "FR40",   # European indices
-        "JP225", "AU200", "HK50"   # Asian indices
-    ]
-    if instrument in indices:
-        logger.info(f"Detected {instrument} as index")
-        return "indices"
-    
-    # Forex pairs als default
-    logger.info(f"Detected {instrument} as forex")
-    return "forex"
-
-# Voeg dit toe als decorator functie bovenaan het bestand na de imports
-def require_subscription(func):
-    """Check if user has an active subscription"""
-    async def wrapper(self, update: Update, context: ContextTypes.DEFAULT_TYPE, *args, **kwargs):
-        user_id = update.effective_user.id
-        
-        # Check subscription status
-        is_subscribed = await self.db.is_user_subscribed(user_id)
-        
-        # Check if payment has failed
-        payment_failed = await self.db.has_payment_failed(user_id)
-        
-        if is_subscribed and not payment_failed:
-            # User has subscription, proceed with function
-            return await func(self, update, context, *args, **kwargs)
-        else:
-            if payment_failed:
-                # Show payment failure message
-                failed_payment_text = f"""
- <b>Subscription Payment Failed</b> 
-
-Your subscription payment could not be processed and your service has been deactivated.
-
-To continue using Sigmapips AI and receive trading signals, please reactivate your subscription by clicking the button below.
-                """
-                
-                # Use direct URL link for reactivation
-                reactivation_url = "https://buy.stripe.com/9AQcPf3j63HL5JS145"
-                
-                # Create button for reactivation
-                keyboard = [
-                    [InlineKeyboardButton("üîÑ Reactivate Subscription", url=reactivation_url)]
-                ]
-            else:
-                # Show subscription screen with the welcome message from the screenshot
-                failed_payment_text = f"""
- <b>Welcome to Sigmapips AI!</b> 
-
-<b>Discover powerful trading signals for various markets:</b>
-- <b>Forex</b> - Major and minor currency pairs
-- <b>Crypto</b> - Bitcoin, Ethereum and other top cryptocurrencies
-- <b>Indices</b> - Global market indices
-- <b>Commodities</b> - Gold, silver and oil
-
-<b>Features:</b>
- Real-time trading signals
-
- Multi-timeframe analysis (timeframes)
-
- Advanced chart analysis
-
- Sentiment indicators
-
- Economic calendar integration
-
-<b>Start today with a FREE 14-day trial!</b>
-                """
-                
-                # Use direct URL link instead of callback for the trial button
-                reactivation_url = "https://buy.stripe.com/3cs3eF9Hu9256NW9AA"
-                
-                # Create button for trial
-                keyboard = [
-                    [InlineKeyboardButton("üî• Start 14-day FREE Trial", url=reactivation_url)]
-                ]
-            
-            # Handle both message and callback query updates
-            if update.callback_query:
-                await update.callback_query.answer()
-                await update.callback_query.edit_message_text(
-                    text=failed_payment_text,
-                    reply_markup=InlineKeyboardMarkup(keyboard),
-                    parse_mode=ParseMode.HTML
-                )
-            else:
-                await update.message.reply_text(
-                    text=failed_payment_text,
-                    reply_markup=InlineKeyboardMarkup(keyboard),
-                    parse_mode=ParseMode.HTML
-                )
-            return MENU
-    
-    return wrapper
-
-# API keys with robust sanitization
-PERPLEXITY_API_KEY = os.getenv("PERPLEXITY_API_KEY", "").strip()
-OPENAI_API_KEY = os.getenv("OPENAI_API_KEY", "").strip()  # Changed from DeepSeek to OpenAI
-
-# Only using OpenAI's o4-mini now
-# No Tavily API key needed anymore
-logger.info("Using only OpenAI o4-mini for Market Sentiment service")
-
-# Log OpenAI API key (partially masked)
-if OPENAI_API_KEY:
-    # Better masking for privacy and security
-    masked_key = f"sk-p...{OPENAI_API_KEY[-4:]}" if len(OPENAI_API_KEY) > 8 else "sk-p..."
-    logger.info(f"Using OpenAI API key: {masked_key}")
-    
-    # Validate the key format
-    from trading_bot.config import validate_openai_key
-    if not validate_openai_key(OPENAI_API_KEY):
-        logger.warning("OpenAI API key format is invalid. AI services may not work correctly.")
-else:
-    logger.warning("No OpenAI API key configured. AI services will be disabled.")
-    
-# Set environment variables for the API keys with sanitization
-os.environ["PERPLEXITY_API_KEY"] = PERPLEXITY_API_KEY
-os.environ["OPENAI_API_KEY"] = OPENAI_API_KEY  # Changed from DeepSeek to OpenAI
-# No Tavily environment needed
-
-class TelegramService:
-    def __init__(self, db: Database, stripe_service=None, bot_token: Optional[str] = None, proxy_url: Optional[str] = None, lazy_init: bool = False):
-        """Initialize the bot with given database and config."""
-        # Database connection
-        self.db = db
-        
-        # Setup configuration 
-        self.stripe_service = stripe_service
-        self.user_signals = {}
-        self.signals_dir = "data/signals"
-        self.signals_enabled_val = True
-        self.polling_started = False
-        self.admin_users = [2004519703]  # Updated with correct Telegram ID from logs
-        self._signals_enabled = True  # Enable signals by default
-        
-        # Setup logger
-        self.logger = logging.getLogger(__name__)
-        
-        # GIF utilities for UI
-        self.gif_utils = gif_utils  # Initialize gif_utils as an attribute
-        
-        # Setup the bot and application
-        self.bot = None
-        self.application = None
-        
-        # Telegram Bot configuratie
-        self.bot_token = bot_token or os.getenv("TELEGRAM_BOT_TOKEN", "")
-        self.token = self.bot_token  # Aliased for backward compatibility
-        self.proxy_url = proxy_url or os.getenv("TELEGRAM_PROXY_URL", "")
-        
-        # Configure custom request handler with improved connection settings
-        request = HTTPXRequest(
-            connection_pool_size=50,  # Increase from 20 to 50
-            connect_timeout=15.0,     # Increase from 10.0 to 15.0
-            read_timeout=45.0,        # Increase from 30.0 to 45.0
-            write_timeout=30.0,       # Increase from 20.0 to 30.0
-            pool_timeout=60.0,        # Increase from 30.0 to 60.0
-        )
-        
-        # Initialize the bot directly with connection pool settings
-        self.bot = Bot(token=self.bot_token, request=request)
-        self.application = None  # Will be initialized in setup()
-        
-        # Webhook configuration
-        self.webhook_url = os.getenv("WEBHOOK_URL", "")
-        self.webhook_path = "/webhook"  # Always use this path
-        if self.webhook_url.endswith("/"):
-            self.webhook_url = self.webhook_url[:-1]  # Remove trailing slash
-            
-        logger.info(f"Bot initialized with webhook URL: {self.webhook_url} and path: {self.webhook_path}")
-        
-        # Initialize API services
-        self.chart_service = ChartService()  # Initialize chart service
-        # Lazy load services only when needed
-        self._calendar_service = None
-        self._sentiment_service = None
-        
-        # Don't use asyncio.create_task here - it requires a running event loop
-        # We'll initialize chart service later when the event loop is running
-        
-        # Bot application initialization
-        self.persistence = None
-        self.bot_started = False
-        
-        # Cache for sentiment analysis
-        self.sentiment_cache = {}
-        self.sentiment_cache_ttl = 60 * 60  # 1 hour in seconds
-        
-        # Start the bot
-    try:
-            # Check for bot token
-            if not self.bot_token:
-                raise ValueError("Missing Telegram bot token")
-            
-            # Initialize the bot
-            self.bot = Bot(token=self.bot_token)
-        
-            # Initialize the application
-            self.application = Application.builder().bot(self.bot).build()
-        
-            # Register the handlers
-            self._register_handlers(self.application)
-            
-            # Initialize signals dictionary but don't load them yet (will be done in initialize_services)
-            self.user_signals = {}
-        
-            logger.info("Telegram service initialized")
-            
-            # Keep track of processed updates
-            self.processed_updates = set()
-            
-    except Exception as e:
-        logger.error(f"Error initializing Telegram service: {str(e)}")
-        raise
-
-    async def initialize_services(self):
-        """Initialize services that require an asyncio event loop"""
-        try:
-            # Initialize chart service
-            await self.chart_service.initialize()
-            logger.info("Chart service initialized")
-            
-            # Load stored signals
-            await self._load_signals()
-            logger.info("Signals loaded")
-            
-            # Schedule periodic cleanup of old signals
-            if hasattr(self, 'db') and self.db and self.db.using_redis:
-                # Run initial cleanup
-                cleaned = await self._cleanup_old_signals(max_age_days=7)
-                logger.info(f"Initial signal cleanup completed, removed {cleaned} old signals")
-                
-                # Schedule periodic cleanup (every 24 hours)
-                async def periodic_cleanup():
-                    while True:
-                        try:
-                            # Wait for 24 hours
-                            await asyncio.sleep(24 * 60 * 60)
-                            # Run cleanup
-                            cleaned = await self._cleanup_old_signals(max_age_days=7)
-                            logger.info(f"Periodic signal cleanup completed, removed {cleaned} old signals")
-                        except Exception as e:
-                            logger.error(f"Error in periodic signal cleanup: {str(e)}")
-                
-                # Start the periodic cleanup task
-                asyncio.create_task(periodic_cleanup())
-                logger.info("Scheduled periodic signal cleanup")
-        except Exception as e:
-            logger.error(f"Error initializing services: {str(e)}")
-            raise
-            
-    # Calendar service helpers
-    @property
-    def calendar_service(self):
-        """Lazy loaded calendar service"""
-        if self._calendar_service is None:
-            # Only initialize the calendar service when it's first accessed
-            self.logger.info("Lazy loading calendar service")
-            self._calendar_service = EconomicCalendarService()
-        return self._calendar_service
-        
-    def _get_calendar_service(self):
-        """Get the calendar service instance"""
-        self.logger.info("Getting calendar service")
-        return self.calendar_service
-
-    async def _format_calendar_events(self, calendar_data):
-        """Format the calendar data into a readable HTML message"""
-        self.logger.info(f"Formatting calendar data with {len(calendar_data)} events")
-        if not calendar_data:
-            return "<b>Economic Calendar</b>\n\nNo economic events found for today."
-        
-        # Sort events by time
-        try:
-            # Try to parse time for sorting
-            def parse_time_for_sorting(event):
-                time_str = event.get('time', '')
-                try:
-                    # Extract hour and minute if in format like "08:30 EST"
-                    if ':' in time_str:
-                        parts = time_str.split(' ')[0].split(':')
-                        hour = int(parts[0])
-                        minute = int(parts[1])
-                        return hour * 60 + minute
-                    return 0
-                except:
-                    return 0
-            
-            # Sort the events by time
-            sorted_events = sorted(calendar_data, key=parse_time_for_sorting)
-        except Exception as e:
-            self.logger.error(f"Error sorting calendar events: {str(e)}")
-            sorted_events = calendar_data
-        
-        # Format the message
-        message = "<b>Economic Calendar</b>\n\n"
-        
-        # Get current date
-        current_date = datetime.now().strftime("%B %d, %Y")
-        message += f"<b>Date:</b> {current_date}\n\n"
-        
-        # Add impact legend
-        message += "<b>Impact:</b> üî¥ High   üü† Medium   üü¢ Low\n\n"
-        
-        # Group events by country
-        events_by_country = {}
-        for event in sorted_events:
-            country = event.get('country', 'Unknown')
-            if country not in events_by_country:
-                events_by_country[country] = []
-            events_by_country[country].append(event)
-        
-        # Format events by country
-        for country, events in events_by_country.items():
-            country_flag = CURRENCY_FLAG.get(country, '')
-            message += f"<b>{country_flag} {country}</b>\n"
-            
-            for event in events:
-                time = event.get('time', 'TBA')
-                title = event.get('title', 'Unknown Event')
-                impact = event.get('impact', 'Low')
-                impact_emoji = {'High': 'üî¥', 'Medium': 'üü†', 'Low': 'üü¢'}.get(impact, 'üü¢')
-                
-                message += f"{time} - {impact_emoji} {title}\n"
-            
-            message += "\n"  # Add extra newline between countries
-        
-        return message
+        return message
         
     # Utility functions that might be missing
     async def update_message(self, query, text, keyboard=None, parse_mode=ParseMode.HTML):
@@ -16896,10 +1032,6 @@ class TelegramService:
         
         # Make sure we're in the signals flow context
         if context and hasattr(context, 'user_data'):
-            # Reset signal flow flags
-            context.user_data['from_signal'] = False
-            context.user_data['in_signal_flow'] = False
-            logger.info(f"Reset signal flow flags: from_signal=False, in_signal_flow=False")
             # Keep is_signals_context flag but reset from_signal flag
             context.user_data['is_signals_context'] = True
             context.user_data['from_signal'] = False
@@ -16910,17 +1042,18 @@ class TelegramService:
                 'signal_id', 'signal_instrument', 'signal_direction', 'signal_timeframe',
                 'loading_message'
             ]
-
+            
             for key in keys_to_remove:
                 if key in context.user_data:
                     del context.user_data[key]
+            
             logger.info(f"Updated context in back_signals_callback: {context.user_data}")
         
         # Create keyboard for signal menu
         keyboard = [
-            [InlineKeyboardButton(" Add Signal", callback_data="signals_add")],
-            [InlineKeyboardButton("Manage Signals", callback_data="signals_manage")],
-            [InlineKeyboardButton("Back to Menu", callback_data="back_menu")]
+            [InlineKeyboardButton("üìä Add Signal", callback_data="signals_add")],
+            [InlineKeyboardButton("‚öôÔ∏è Manage Signals", callback_data="signals_manage")],
+            [InlineKeyboardButton("‚¨ÖÔ∏è Back to Menu", callback_data="back_menu")]
         ]
         reply_markup = InlineKeyboardMarkup(keyboard)
         
@@ -16929,7 +1062,8 @@ class TelegramService:
         
         # Update the message
         await self.update_message(
-            query=query,\n            text="<b> Signal Management</b>\n\nManage your trading signals",
+            query=query,
+            text="<b>üìà Signal Management</b>\n\nManage your trading signals",
             keyboard=reply_markup
         )
         
@@ -16946,7 +1080,7 @@ class TelegramService:
         Returns:
             List of subscribed user IDs
         """
-    try:
+        try:
             logger.info(f"Getting subscribers for {instrument} timeframe: {timeframe}")
             
             # Get all subscribers from the database
@@ -16975,8 +1109,8 @@ class TelegramService:
             
             return active_subscribers
             
-    except Exception as e:
-        logger.error(f"Error getting subscribers: {str(e)}")
+        except Exception as e:
+            logger.error(f"Error getting subscribers: {str(e)}")
             # FOR TESTING: Add admin users if available
             if hasattr(self, 'admin_users') and self.admin_users:
                 logger.info(f"Returning admin users for testing: {self.admin_users}")
@@ -17008,7 +1142,7 @@ class TelegramService:
                 tp1 = signal_data.get('tp1')
                 tp2 = signal_data.get('tp2')
                 tp3 = signal_data.get('tp3')
-                interval = signal_data.get('interval', 'one_hour')
+                interval = signal_data.get('interval', '1h')
                 
                 # Determine signal direction based on price and SL relationship
                 direction = "BUY" if float(sl) < float(price) else "SELL"
@@ -17027,14 +1161,14 @@ class TelegramService:
                 normalized_data['tp1'] = tp1
                 normalized_data['tp2'] = tp2
                 normalized_data['tp3'] = tp3
-                
+            
             # Handle custom format (direction, entry, stop_loss, timeframe)
             elif 'direction' in signal_data and 'entry' in signal_data:
                 direction = signal_data.get('direction')
                 entry = signal_data.get('entry')
                 stop_loss = signal_data.get('stop_loss')
                 take_profit = signal_data.get('take_profit')
-                timeframe = signal_data.get('timeframe', 'one_hour')
+                timeframe = signal_data.get('timeframe', '1h')
                 
                 # Create normalized signal data
                 normalized_data = {
@@ -17084,7 +1218,7 @@ class TelegramService:
                     for admin_id in self.admin_users:
                         # Prepare keyboard with analysis options
                         keyboard = [
-                            [InlineKeyboardButton("Analyze Market", callback_data=f"analyze_from_signal_{instrument}_{signal_id}")]
+                            [InlineKeyboardButton("üîç Analyze Market", callback_data=f"analyze_from_signal_{instrument}_{signal_id}")]
                         ]
                         
                         # Send the signal
@@ -17105,11 +1239,11 @@ class TelegramService:
                             self.user_signals[admin_str_id] = {}
                         
                         self.user_signals[admin_str_id][signal_id] = normalized_data
-            except Exception as e:
-                logger.error(f"Error sending test signal to admin: {str(e)}")
+                except Exception as e:
+                    logger.error(f"Error sending test signal to admin: {str(e)}")
             
             # Get subscribers for this instrument
-            timeframe = normalized_data.get('timeframe', 'one_hour')
+            timeframe = normalized_data.get('timeframe', '1h')
             subscribers = await self.get_subscribers_for_instrument(instrument, timeframe)
             
             if not subscribers:
@@ -17124,7 +1258,7 @@ class TelegramService:
                 try:
                     # Prepare keyboard with analysis options
                     keyboard = [
-                        [InlineKeyboardButton("Analyze Market", callback_data=f"analyze_from_signal_{instrument}_{signal_id}")]
+                        [InlineKeyboardButton("üîç Analyze Market", callback_data=f"analyze_from_signal_{instrument}_{signal_id}")]
                     ]
                     
                     # Send the signal
@@ -17147,27 +1281,27 @@ class TelegramService:
                     
                     self.user_signals[user_str_id][signal_id] = normalized_data
                     
-            except Exception as e:
-                logger.error(f"Error sending signal to user {user_id}: {str(e)}")
+                except Exception as e:
+                    logger.error(f"Error sending signal to user {user_id}: {str(e)}")
             
             logger.info(f"Successfully sent signal {signal_id} to {sent_count}/{len(subscribers)} subscribers")
             return True
             
-    except Exception as e:
-        logger.error(f"Error processing signal: {str(e)}")
-        logger.exception(e)
+        except Exception as e:
+            logger.error(f"Error processing signal: {str(e)}")
+            logger.exception(e)
             return False
 
     def _format_signal_message(self, signal_data: Dict[str, Any]) -> str:
         """Format signal data into a nice message for Telegram"""
-    try:
+        try:
             # Extract fields from signal data
             instrument = signal_data.get('instrument', 'Unknown')
             direction = signal_data.get('direction', 'Unknown')
             entry = signal_data.get('entry', 'Unknown')
             stop_loss = signal_data.get('stop_loss')
             take_profit = signal_data.get('take_profit')
-            timeframe = signal_data.get('timeframe', 'one_hour')
+            timeframe = signal_data.get('timeframe', '1h')
             
             # Get multiple take profit levels if available
             tp1 = signal_data.get('tp1', take_profit)
@@ -17178,7 +1312,7 @@ class TelegramService:
             direction_emoji = "üü¢" if direction.upper() == "BUY" else "üî¥"
             
             # Format the message with multiple take profits if available
-            message = "<b> New Trading Signal </b>\n"\n\n"
+            message = f"<b>üéØ New Trading Signal üéØ</b>\n\n"
             message += f"<b>Instrument:</b> {instrument}\n"
             message += f"<b>Action:</b> {direction.upper()} {direction_emoji}\n\n"
             message += f"<b>Entry Price:</b> {entry}\n"
@@ -17188,20 +1322,20 @@ class TelegramService:
             
             # Add take profit levels
             if tp1:
-                message += f"<b>Take Profit 1:</b> {tp1} \n"
+                message += f"<b>Take Profit 1:</b> {tp1} üéØ\n"
             if tp2:
-                message += f"<b>Take Profit 2:</b> {tp2} \n"
+                message += f"<b>Take Profit 2:</b> {tp2} üéØ\n"
             if tp3:
-                message += f"<b>Take Profit 3:</b> {tp3} \n"
+                message += f"<b>Take Profit 3:</b> {tp3} üéØ\n"
             
             message += f"\n<b>Timeframe:</b> {timeframe}\n"
             message += f"<b>Strategy:</b> TradingView Signal\n\n"
             
             message += "‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî\n\n"
             message += "<b>Risk Management:</b>\n"
-            message += "- Position size: 1-2% max\n"
-            message += "- Use proper stop loss\n"
-            message += "- Follow your trading plan\n\n"
+            message += "‚Ä¢ Position size: 1-2% max\n"
+            message += "‚Ä¢ Use proper stop loss\n"
+            message += "‚Ä¢ Follow your trading plan\n\n"
             
             message += "‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî\n\n"
             
@@ -17211,25 +1345,25 @@ class TelegramService:
             
             return message
             
-    except Exception as e:
-        logger.error(f"Error formatting signal message: {str(e)}")
+        except Exception as e:
+            logger.error(f"Error formatting signal message: {str(e)}")
             # Return simple message on error
             return f"New {signal_data.get('instrument', 'Unknown')} {signal_data.get('direction', 'Unknown')} Signal"
 
     def _register_handlers(self, application):
         """Register event handlers for bot commands and callback queries"""
-    try:
+        try:
             logger.info("Registering command handlers")
             
             # Initialize the application without using run_until_complete
-        try:
+            try:
                 # Instead of using loop.run_until_complete, directly call initialize 
                 # which will be properly awaited by the caller
                 self.init_task = application.initialize()
                 logger.info("Telegram application initialization ready to be awaited")
             except Exception as init_e:
-            logger.error(f"Error during application initialization: {str(init_e)}")
-            logger.exception(init_e)
+                logger.error(f"Error during application initialization: {str(init_e)}")
+                logger.exception(init_e)
                 
             # Set bot commands for menu
             commands = [
@@ -17239,12 +1373,12 @@ class TelegramService:
             ]
             
             # Store the set_commands_task to be awaited later
-        try:
+            try:
                 # Instead of asyncio.create_task, we will await this in the startup event
                 self.set_commands_task = self.bot.set_my_commands(commands)
                 logger.info("Bot commands ready to be set")
             except Exception as cmd_e:
-            logger.error(f"Error preparing bot commands: {str(cmd_e)}")
+                logger.error(f"Error preparing bot commands: {str(cmd_e)}")
             
             # Register command handlers
             application.add_handler(CommandHandler("start", self.start_command))
@@ -17277,21 +1411,16 @@ class TelegramService:
             application.add_handler(CallbackQueryHandler(self.analysis_calendar_callback, pattern="^analysis_calendar$"))
             
             # Analysis handlers for signal flow - with instrument embedded in callback
-            application.add_handler(CallbackQueryHandler(self.signal_technical_callback, pattern="^signal_flow_technical_.*$"))
-            application.add_handler(CallbackQueryHandler(self.signal_sentiment_callback, pattern="^signal_flow_sentiment_.*$"))
-            application.add_handler(CallbackQueryHandler(self.signal_calendar_callback, pattern="^signal_flow_calendar_.*$"))
-            
-            # Analysis handlers for signal flow - with instrument embedded in callback
-            application.add_handler(CallbackQueryHandler(self.signal_technical_callback, pattern="^signal_flow_technical_.*$"))
-            application.add_handler(CallbackQueryHandler(self.signal_sentiment_callback, pattern="^signal_flow_sentiment_.*$"))
-            application.add_handler(CallbackQueryHandler(self.analysis_calendar_callback, pattern="^signal_flow_calendar_.*$"))
+            application.add_handler(CallbackQueryHandler(self.analysis_technical_callback, pattern="^analysis_technical_signal_.*$"))
+            application.add_handler(CallbackQueryHandler(self.analysis_sentiment_callback, pattern="^analysis_sentiment_signal_.*$"))
+            application.add_handler(CallbackQueryHandler(self.analysis_calendar_callback, pattern="^analysis_calendar_signal_.*$"))
             
             # Signal analysis flow handlers
             application.add_handler(CallbackQueryHandler(self.signal_technical_callback, pattern="^signal_technical$"))
             application.add_handler(CallbackQueryHandler(self.signal_sentiment_callback, pattern="^signal_sentiment$"))
             application.add_handler(CallbackQueryHandler(self.signal_calendar_callback, pattern="^signal_calendar$"))
             application.add_handler(CallbackQueryHandler(self.signal_calendar_callback, pattern="^signal_flow_calendar_.*$"))
-            application.add_handler(CallbackQueryHandler(self.back_to_signal_callback, pattern="^back_to_signal$"))
+            application.add_handler(CallbackQueryHandler(self.back_to_signal_callback, pattern=r"^back_to_signal_([^_]+(?:_[^_]+)*)$")) # MODIFIED pattern
             application.add_handler(CallbackQueryHandler(self.back_to_signal_analysis_callback, pattern="^back_to_signal_analysis$"))
             
             # Signal from analysis
@@ -17308,9 +1437,9 @@ class TelegramService:
             
             logger.info("Bot setup completed successfully")
             
-    except Exception as e:
-        logger.error(f"Error setting up bot handlers: {str(e)}")
-        logger.exception(e)
+        except Exception as e:
+            logger.error(f"Error setting up bot handlers: {str(e)}")
+            logger.exception(e)
 
     @property
     def signals_enabled(self):
@@ -17323,14 +1452,14 @@ class TelegramService:
         self._signals_enabled = bool(value)
         logger.info(f"Signal processing is now {'enabled' if value else 'disabled'}")
 
-        async def start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE = None) -> None:
+    async def start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE = None) -> None:
         """Send a welcome message when the bot is started."""
         user = update.effective_user
         user_id = user.id
         first_name = user.first_name
         
         # Try to add the user to the database if they don't exist yet
-    try:
+        try:
             # Get user subscription since we can't check if user exists directly
             existing_subscription = await self.db.get_user_subscription(user_id)
             
@@ -17338,11 +1467,11 @@ class TelegramService:
                 # Add new user
                 logger.info(f"New user started: {user_id}, {first_name}")
                 await self.db.save_user(user_id, first_name, None, user.username)
-        else:
+            else:
                 logger.info(f"Existing user started: {user_id}, {first_name}")
                 
-    except Exception as e:
-        logger.error(f"Error registering user: {str(e)}")
+        except Exception as e:
+            logger.error(f"Error registering user: {str(e)}")
         
         # Check if the user has a subscription 
         is_subscribed = await self.db.is_user_subscribed(user_id)
@@ -17360,7 +1489,7 @@ class TelegramService:
         elif payment_failed:
             # Show payment failure message
             failed_payment_text = f"""
- <b>Subscription Payment Failed</b> 
+‚ùó <b>Subscription Payment Failed</b> ‚ùó
 
 Your subscription payment could not be processed and your service has been deactivated.
 
@@ -17380,31 +1509,31 @@ To continue using Sigmapips AI and receive trading signals, please reactivate yo
                 reply_markup=InlineKeyboardMarkup(keyboard),
                 parse_mode=ParseMode.HTML
             )
-    else:
+        else:
             # Show the welcome message with trial option from the screenshot
             welcome_text = """
- Welcome to Sigmapips AI! 
+üöÄ Welcome to Sigmapips AI! üöÄ
 
 Discover powerful trading signals for various markets:
-- Forex - Major and minor currency pairs
+‚Ä¢ Forex - Major and minor currency pairs
 
-- Crypto - Bitcoin, Ethereum and other top
+‚Ä¢ Crypto - Bitcoin, Ethereum and other top
  cryptocurrencies
 
-- Indices - Global market indices
+‚Ä¢ Indices - Global market indices
 
-- Commodities - Gold, silver and oil
+‚Ä¢ Commodities - Gold, silver and oil
 
 Features:
- Real-time trading signals
+‚úÖ Real-time trading signals
 
- Multi-timeframe analysis (timeframes)
+‚úÖ Multi-timeframe analysis (1m, 15m, 1h, 4h)
 
- Advanced chart analysis
+‚úÖ Advanced chart analysis
 
- Sentiment indicators
+‚úÖ Sentiment indicators
 
- Economic calendar integration
+‚úÖ Economic calendar integration
 
 Start today with a FREE 14-day trial!
             """
@@ -17420,7 +1549,7 @@ Start today with a FREE 14-day trial!
             # Gebruik de juiste welkomst-GIF URL
             welcome_gif_url = "https://media.giphy.com/media/gSzIKNrqtotEYrZv7i/giphy.gif"
             
-        try:
+            try:
                 # Send the GIF with caption containing the welcome message
                 await update.message.reply_animation(
                     animation=welcome_gif_url,
@@ -17428,7 +1557,8 @@ Start today with a FREE 14-day trial!
                     parse_mode=ParseMode.HTML,
                     reply_markup=InlineKeyboardMarkup(keyboard)
                 )
-        except Exception as e:\n            logger.error(f"Error sending welcome GIF with caption: {str(e)}")
+            except Exception as e:
+                logger.error(f"Error sending welcome GIF with caption: {str(e)}")
                 # Fallback to text-only message if GIF fails
                 await update.message.reply_text(
                     text=welcome_text,
@@ -17443,7 +1573,7 @@ Start today with a FREE 14-day trial!
             await update.message.reply_text("Usage: /set_subscription [chatid] [status] [days]")
             return
             
-    try:
+        try:
             # Parse arguments
             chat_id = int(context.args[0])
             status = context.args[1].lower()
@@ -17469,9 +1599,9 @@ Start today with a FREE 14-day trial!
                     start_date, 
                     end_date
                 )
-                await update.message.reply_text(f" Subscription set to ACTIVE for user {chat_id} for {days} days")
+                await update.message.reply_text(f"‚úÖ Subscription set to ACTIVE for user {chat_id} for {days} days")
                 
-        else:
+            else:
                 # Set inactive subscription by setting end date in the past
                 start_date = now - timedelta(days=30)
                 end_date = now - timedelta(days=1)
@@ -17483,36 +1613,36 @@ Start today with a FREE 14-day trial!
                     start_date, 
                     end_date
                 )
-                await update.message.reply_text(f" Subscription set to INACTIVE for user {chat_id}")
+                await update.message.reply_text(f"‚úÖ Subscription set to INACTIVE for user {chat_id}")
                 
             logger.info(f"Manually set subscription status to {status} for user {chat_id}")
             
         except ValueError:
             await update.message.reply_text("Invalid arguments. Chat ID and days must be numbers.")
-    except Exception as e:
-        logger.error(f"Error setting subscription: {str(e)}")
+        except Exception as e:
+            logger.error(f"Error setting subscription: {str(e)}")
             await update.message.reply_text(f"Error: {str(e)}")
             
     async def set_payment_failed_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE = None) -> None:
         """Secret command to set a user's subscription to the payment failed state"""
         logger.info(f"set_payment_failed command received: {update.message.text}")
         
-    try:
+        try:
             # Extract chat_id directly from the message text if present
             command_parts = update.message.text.split()
             if len(command_parts) > 1:
-            try:
+                try:
                     chat_id = int(command_parts[1])
                     logger.info(f"Extracted chat ID from message: {chat_id}")
                 except ValueError:
-                logger.error(f"Invalid chat ID format in message: {command_parts[1]}")
+                    logger.error(f"Invalid chat ID format in message: {command_parts[1]}")
                     await update.message.reply_text(f"Invalid chat ID format: {command_parts[1]}")
                     return
             # Fallback to context args if needed
             elif context and context.args and len(context.args) > 0:
                 chat_id = int(context.args[0])
                 logger.info(f"Using chat ID from context args: {chat_id}")
-        else:
+            else:
                 # Default to the user's own ID
                 chat_id = update.effective_user.id
                 logger.info(f"No chat ID provided, using sender's ID: {chat_id}")
@@ -17520,23 +1650,113 @@ Start today with a FREE 14-day trial!
             # Set payment failed status in database
             success = await self.db.set_payment_failed(chat_id)
             
-            if success:
-                message = f" Payment status set to FAILED for user {chat_id}"
-                logger.info(f"Manually set payment failed status for user {chat_id}")
-                
-                # Show the payment failed interface immediately
-                failed_payment_text = f"""
- <b>Subscription Payment Failed</b> 
-
-Your subscription payment could not be processed and your service has been deactivated.
-
-To continue using Sigmapips AI and receive trading signals, please reactivate your subscription by clicking the button below.
-                """
+            if success:
+                message = f"‚úÖ Payment status set to FAILED for user {chat_id}"
+                logger.info(f"Manually set payment failed status for user {chat_id}")
+                
+                # Show the payment failed interface immediately
+                failed_payment_text = f"""
+‚ùó <b>Subscription Payment Failed</b> ‚ùó
+
+Your subscription payment could not be processed and your service has been deactivated.
+
+To continue using Sigmapips AI and receive trading signals, please reactivate your subscription by clicking the button below.
+                """
+                
+                # Use direct URL link for reactivation
+                reactivation_url = "https://buy.stripe.com/9AQcPf3j63HL5JS145"
+                
+                # Create button for reactivation
+                keyboard = [
+                    [InlineKeyboardButton("üîÑ Reactivate Subscription", url=reactivation_url)]
+                ]
+                
+                # First send success message
+                await update.message.reply_text(message)
+                
+                # Then show payment failed interface
+                await update.message.reply_text(
+                    text=failed_payment_text,
+                    reply_markup=InlineKeyboardMarkup(keyboard),
+                    parse_mode=ParseMode.HTML
+                )
+            else:
+                message = f"‚ùå Could not set payment failed status for user {chat_id}"
+                logger.error("Database returned failure")
+                await update.message.reply_text(message)
+                
+        except ValueError as e:
+            error_msg = f"Invalid argument. Chat ID must be a number. Error: {str(e)}"
+            logger.error(error_msg)
+            await update.message.reply_text(error_msg)
+        except Exception as e:
+            error_msg = f"Error setting payment failed status: {str(e)}"
+            logger.error(error_msg)
+            await update.message.reply_text(error_msg)
+
+    async def menu_analyse_callback(self, update: Update, context=None) -> int:
+        """Handle menu_analyse button press"""
+        query = update.callback_query
+        await query.answer()
+        
+        # Gebruik de juiste analyse GIF URL
+        gif_url = "https://media.giphy.com/media/gSzIKNrqtotEYrZv7i/giphy.gif"
+        
+        # Probeer eerst het huidige bericht te verwijderen en een nieuw bericht te sturen met de analyse GIF
+        try:
+            await query.message.delete()
+            await context.bot.send_animation(
+                chat_id=update.effective_chat.id,
+                animation=gif_url,
+                caption="Select your analysis type:",
+                reply_markup=InlineKeyboardMarkup(ANALYSIS_KEYBOARD),
+                parse_mode=ParseMode.HTML
+            )
+            return CHOOSE_ANALYSIS
+        except Exception as delete_error:
+            logger.warning(f"Could not delete message: {str(delete_error)}")
+            
+            # Als verwijderen mislukt, probeer de media te updaten
+            try:
+                await query.edit_message_media(
+                    media=InputMediaAnimation(
+                        media=gif_url,
+                        caption="Select your analysis type:"
+                    ),
+                    reply_markup=InlineKeyboardMarkup(ANALYSIS_KEYBOARD)
+                )
+                return CHOOSE_ANALYSIS
+            except Exception as media_error:
+                logger.warning(f"Could not update media: {str(media_error)}")
                 
-                                  parse_mode=ParseMode.HTML
+                # Als media update mislukt, probeer tekst te updaten
+                try:
+                    await query.edit_message_text(
+                        text="Select your analysis type:",
+                        reply_markup=InlineKeyboardMarkup(ANALYSIS_KEYBOARD),
+                        parse_mode=ParseMode.HTML
+                    )
+                except Exception as text_error:
+                    # Als tekst updaten mislukt, probeer bijschrift te updaten
+                    if "There is no text in the message to edit" in str(text_error):
+                        try:
+                            await query.edit_message_caption(
+                                caption="Select your analysis type:",
+                                reply_markup=InlineKeyboardMarkup(ANALYSIS_KEYBOARD),
+                                parse_mode=ParseMode.HTML
+                            )
+                        except Exception as caption_error:
+                            logger.error(f"Failed to update caption: {str(caption_error)}")
+                            # Laatste redmiddel: stuur een nieuw bericht
+                            await context.bot.send_animation(
+                                chat_id=update.effective_chat.id,
+                                animation=gif_url,
+                                caption="Select your analysis type:",
+                                reply_markup=InlineKeyboardMarkup(ANALYSIS_KEYBOARD),
+                                parse_mode=ParseMode.HTML
                             )
                     else:
-                    logger.error(f"Failed to update message: {str(text_error)}")
+                        logger.error(f"Failed to update message: {str(text_error)}")
                         # Laatste redmiddel: stuur een nieuw bericht
                         await context.bot.send_animation(
                             chat_id=update.effective_chat.id,
@@ -17567,12 +1787,12 @@ To continue using Sigmapips AI and receive trading signals, please reactivate yo
             
             # If we should show the GIF
             if not skip_gif:
-            try:
+                try:
                     # For message commands we can use reply_animation
                     if hasattr(update, 'message') and update.message:
                         # Verwijder eventuele vorige berichten met callback query
                         if hasattr(update, 'callback_query') and update.callback_query:
-                        try:
+                            try:
                                 await update.callback_query.message.delete()
                             except Exception:
                                 pass
@@ -17587,7 +1807,7 @@ To continue using Sigmapips AI and receive trading signals, please reactivate yo
                     else:
                         # Voor callback_query, verwijder huidige bericht en stuur nieuw bericht
                         if hasattr(update, 'callback_query') and update.callback_query:
-                        try:
+                            try:
                                 # Verwijder het huidige bericht
                                 await update.callback_query.message.delete()
                                 
@@ -17599,14 +1819,15 @@ To continue using Sigmapips AI and receive trading signals, please reactivate yo
                                     parse_mode=ParseMode.HTML,
                                     reply_markup=reply_markup
                                 )
-                        except Exception as e:\n                            logger.error(f"Failed to handle callback query: {str(e)}")
+                            except Exception as e:
+                                logger.error(f"Failed to handle callback query: {str(e)}")
                                 # Valt terug op tekstwijziging als verwijderen niet lukt
                                 await update.callback_query.edit_message_text(
                                     text=WELCOME_MESSAGE,
                                     parse_mode=ParseMode.HTML,
                                     reply_markup=reply_markup
                                 )
-                    else:
+                        else:
                             # Final fallback - try to send a new message
                             await bot.send_animation(
                                 chat_id=update.effective_chat.id,
@@ -17615,8 +1836,8 @@ To continue using Sigmapips AI and receive trading signals, please reactivate yo
                                 parse_mode=ParseMode.HTML,
                                 reply_markup=reply_markup
                             )
-            except Exception as e:
-                logger.error(f"Failed to send menu GIF: {str(e)}")
+                except Exception as e:
+                    logger.error(f"Failed to send menu GIF: {str(e)}")
                     # Fallback to text-only approach
                     if hasattr(update, 'message') and update.message:
                         await update.message.reply_text(
@@ -17631,7 +1852,7 @@ To continue using Sigmapips AI and receive trading signals, please reactivate yo
                             parse_mode=ParseMode.HTML,
                             reply_markup=reply_markup
                         )
-                    else:
+            else:
                 # Skip GIF mode - just send text
                 if hasattr(update, 'message') and update.message:
                     await update.message.reply_text(
@@ -17646,7 +1867,7 @@ To continue using Sigmapips AI and receive trading signals, please reactivate yo
                         parse_mode=ParseMode.HTML,
                         reply_markup=reply_markup
                     )
-    else:
+        else:
             # Handle non-subscribed users similar to start command
             await self.start_command(update, context)
             
@@ -17665,33 +1886,25 @@ To continue using Sigmapips AI and receive trading signals, please reactivate yo
         
         # Check if signal-specific data is present in callback data
         if context and hasattr(context, 'user_data'):
-            # Reset signal flow flags
-            context.user_data['from_signal'] = False
-            context.user_data['in_signal_flow'] = False
-            logger.info(f"Reset signal flow flags: from_signal=False, in_signal_flow=False")
             context.user_data['analysis_type'] = 'technical'
         
         # Set the callback data
         callback_data = query.data
         
         # Set the instrument if it was passed in the callback data
-        if callback_data.startswith("signal_flow_technical_"):
+        if callback_data.startswith("analysis_technical_signal_"):
             # Extract instrument from the callback data
-            instrument = callback_data.replace("signal_flow_technical_", "")
+            instrument = callback_data.replace("analysis_technical_signal_", "")
             if context and hasattr(context, 'user_data'):
-                # Reset signal flow flags
-                context.user_data['from_signal'] = False
-                context.user_data['in_signal_flow'] = False
-                logger.info(f"Reset signal flow flags: from_signal=False, in_signal_flow=False")
                 context.user_data['instrument'] = instrument
             
-                logger.info(f"Technical analysis for specific instrument: {instrument}")
+            logger.info(f"Technical analysis for specific instrument: {instrument}")
             
             # Show analysis directly for this instrument
             return await self.show_technical_analysis(update, context, instrument=instrument)
         
         # Show the market selection menu
-    try:
+        try:
             # First try to edit message text
             await query.edit_message_text(
                 text="Select market for technical analysis:",
@@ -17700,21 +1913,21 @@ To continue using Sigmapips AI and receive trading signals, please reactivate yo
         except Exception as text_error:
             # If that fails due to caption, try editing caption
             if "There is no text in the message to edit" in str(text_error):
-            try:
+                try:
                     await query.edit_message_caption(
                         caption="Select market for technical analysis:",
                         reply_markup=InlineKeyboardMarkup(MARKET_KEYBOARD),
                         parse_mode=ParseMode.HTML
                     )
-            except Exception as e:
-                logger.error(f"Failed to update caption in analysis_technical_callback: {str(e)}")
+                except Exception as e:
+                    logger.error(f"Failed to update caption in analysis_technical_callback: {str(e)}")
                     # Try to send a new message as last resort
                     await query.message.reply_text(
                         text="Select market for technical analysis:",
                         reply_markup=InlineKeyboardMarkup(MARKET_KEYBOARD),
                         parse_mode=ParseMode.HTML
                     )
-                else:
+            else:
                 # Re-raise for other errors
                 raise
         
@@ -17726,33 +1939,25 @@ To continue using Sigmapips AI and receive trading signals, please reactivate yo
         await query.answer()
         
         if context and hasattr(context, 'user_data'):
-            # Reset signal flow flags
-            context.user_data['from_signal'] = False
-            context.user_data['in_signal_flow'] = False
-            logger.info(f"Reset signal flow flags: from_signal=False, in_signal_flow=False")
             context.user_data['analysis_type'] = 'sentiment'
         
         # Set the callback data
         callback_data = query.data
         
         # Set the instrument if it was passed in the callback data
-        if callback_data.startswith("signal_flow_sentiment_"):
+        if callback_data.startswith("analysis_sentiment_signal_"):
             # Extract instrument from the callback data
-            instrument = callback_data.replace("signal_flow_sentiment_", "")
+            instrument = callback_data.replace("analysis_sentiment_signal_", "")
             if context and hasattr(context, 'user_data'):
-                # Reset signal flow flags
-                context.user_data['from_signal'] = False
-                context.user_data['in_signal_flow'] = False
-                logger.info(f"Reset signal flow flags: from_signal=False, in_signal_flow=False")
                 context.user_data['instrument'] = instrument
             
-                logger.info(f"Sentiment analysis for specific instrument: {instrument}")
+            logger.info(f"Sentiment analysis for specific instrument: {instrument}")
             
             # Show analysis directly for this instrument
             return await self.show_sentiment_analysis(update, context, instrument=instrument)
             
         # Show the market selection menu
-    try:
+        try:
             # First try to edit message text
             await query.edit_message_text(
                 text="Select market for sentiment analysis:",
@@ -17761,21 +1966,21 @@ To continue using Sigmapips AI and receive trading signals, please reactivate yo
         except Exception as text_error:
             # If that fails due to caption, try editing caption
             if "There is no text in the message to edit" in str(text_error):
-            try:
+                try:
                     await query.edit_message_caption(
                         caption="Select market for sentiment analysis:",
                         reply_markup=InlineKeyboardMarkup(MARKET_KEYBOARD),
                         parse_mode=ParseMode.HTML
                     )
-            except Exception as e:
-                logger.error(f"Failed to update caption in analysis_sentiment_callback: {str(e)}")
+                except Exception as e:
+                    logger.error(f"Failed to update caption in analysis_sentiment_callback: {str(e)}")
                     # Try to send a new message as last resort
                     await query.message.reply_text(
                         text="Select market for sentiment analysis:",
                         reply_markup=InlineKeyboardMarkup(MARKET_KEYBOARD),
                         parse_mode=ParseMode.HTML
                     )
-                else:
+            else:
                 # Re-raise for other errors
                 raise
         
@@ -17787,27 +1992,19 @@ To continue using Sigmapips AI and receive trading signals, please reactivate yo
         await query.answer()
         
         if context and hasattr(context, 'user_data'):
-            # Reset signal flow flags
-            context.user_data['from_signal'] = False
-            context.user_data['in_signal_flow'] = False
-            logger.info(f"Reset signal flow flags: from_signal=False, in_signal_flow=False")
             context.user_data['analysis_type'] = 'calendar'
             
         # Set the callback data
         callback_data = query.data
         
         # Set the instrument if it was passed in the callback data
-        if callback_data.startswith("signal_flow_calendar_"):
+        if callback_data.startswith("analysis_calendar_signal_"):
             # Extract instrument from the callback data
-            instrument = callback_data.replace("signal_flow_calendar_", "")
+            instrument = callback_data.replace("analysis_calendar_signal_", "")
             if context and hasattr(context, 'user_data'):
-                # Reset signal flow flags
-                context.user_data['from_signal'] = False
-                context.user_data['in_signal_flow'] = False
-                logger.info(f"Reset signal flow flags: from_signal=False, in_signal_flow=False")
                 context.user_data['instrument'] = instrument
             
-                logger.info(f"Calendar analysis for specific instrument: {instrument}")
+            logger.info(f"Calendar analysis for specific instrument: {instrument}")
             
             # Show analysis directly for this instrument
             return await self.show_calendar_analysis(update, context, instrument=instrument)
@@ -17818,7 +2015,7 @@ To continue using Sigmapips AI and receive trading signals, please reactivate yo
 
     async def show_economic_calendar(self, update: Update, context: CallbackContext, currency=None, loading_message=None):
         """Show the economic calendar for a specific currency"""
-    try:
+        try:
             # VERIFICATION MARKER: SIGMAPIPS_CALENDAR_FIX_APPLIED
             self.logger.info("VERIFICATION MARKER: SIGMAPIPS_CALENDAR_FIX_APPLIED")
             
@@ -17838,7 +2035,7 @@ To continue using Sigmapips AI and receive trading signals, please reactivate yo
             if tavily_api_key:
                 masked_key = f"{tavily_api_key[:4]}..." if len(tavily_api_key) > 7 else "***"
                 self.logger.info(f"Tavily API key is available: {masked_key}")
-        else:
+            else:
                 self.logger.warning("No Tavily API key found, will use mock data")
             
             # Get calendar data for ALL major currencies, regardless of the supplied parameter
@@ -17847,13 +2044,13 @@ To continue using Sigmapips AI and receive trading signals, please reactivate yo
             calendar_data = []
             
             # Get all currencies data
-        try:
+            try:
                 if hasattr(calendar_service, 'get_calendar'):
                     calendar_data = await calendar_service.get_calendar()
-            else:
+                else:
                     self.logger.warning("calendar_service.get_calendar method not available, using mock data")
                     calendar_data = []
-        except Exception as e:
+            except Exception as e:
                 self.logger.warning(f"Error getting calendar data: {str(e)}")
                 calendar_data = []
             
@@ -17866,7 +2063,7 @@ To continue using Sigmapips AI and receive trading signals, please reactivate yo
                 # Use the mock data generator from the calendar service if available
                 if hasattr(calendar_service, '_generate_mock_calendar_data'):
                     mock_data = calendar_service._generate_mock_calendar_data(MAJOR_CURRENCIES, today_date)
-            else:
+                else:
                     # Otherwise use our own implementation
                     mock_data = self._generate_mock_calendar_data(MAJOR_CURRENCIES, today_date)
                 
@@ -17888,13 +2085,13 @@ To continue using Sigmapips AI and receive trading signals, please reactivate yo
             # Format the calendar data in chronological order
             if hasattr(self, '_format_calendar_events'):
                 message = await self._format_calendar_events(calendar_data)
-        else:
+            else:
                 # Fallback to calendar service formatting if the method doesn't exist on TelegramService
                 if hasattr(calendar_service, '_format_calendar_response'):
                     message = await calendar_service._format_calendar_response(calendar_data, "ALL")
-            else:
+                else:
                     # Simple formatting fallback
-                    message = "<b>Economic Calendar</b>\n\n"
+                    message = "<b>üìÖ Economic Calendar</b>\n\n"
                     for event in calendar_data[:10]:  # Limit to first 10 events
                         country = event.get('country', 'Unknown')
                         title = event.get('title', 'Unknown Event')
@@ -17904,20 +2101,20 @@ To continue using Sigmapips AI and receive trading signals, please reactivate yo
             # Create keyboard with back button if not provided from caller
             keyboard = None
             if context and hasattr(context, 'user_data') and context.user_data.get('from_signal', False):
-                keyboard = InlineKeyboardMarkup([[InlineKeyboardButton("Back", callback_data="back_to_signal_analysis")]])
-        else:
-                keyboard = InlineKeyboardMarkup([[InlineKeyboardButton("Back", callback_data="menu_analyse")]])
+                keyboard = InlineKeyboardMarkup([[InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="back_to_signal_analysis")]])
+            else:
+                keyboard = InlineKeyboardMarkup([[InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="menu_analyse")]])
             
             # Try to delete loading message first if it exists
             if loading_message:
-            try:
+                try:
                     await loading_message.delete()
                     self.logger.info("Successfully deleted loading message")
                 except Exception as delete_error:
                     self.logger.warning(f"Could not delete loading message: {str(delete_error)}")
                     
                     # If deletion fails, try to edit it
-                try:
+                    try:
                         await context.bot.edit_message_text(
                             chat_id=chat_id,
                             message_id=loading_message.message_id,
@@ -17947,7 +2144,7 @@ To continue using Sigmapips AI and receive trading signals, please reactivate yo
             chat_id = update.effective_chat.id
             await context.bot.send_message(
                 chat_id=chat_id,
-                text="<b> Error showing economic calendar</b>\n\nSorry, there was an error retrieving the economic calendar data. Please try again later.",
+                text="<b>‚ö†Ô∏è Error showing economic calendar</b>\n\nSorry, there was an error retrieving the economic calendar data. Please try again later.",
                 parse_mode=ParseMode.HTML
             )
             
@@ -18008,54 +2205,41 @@ To continue using Sigmapips AI and receive trading signals, please reactivate yo
         query = update.callback_query
         await query.answer()
         
-        # Add detailed debug logging
         logger.info(f"signal_technical_callback called with query data: {query.data}")
-        
-        # Save analysis type in context
+        signal_id = None
+        try:
+            # query.data is now signal_technical_SIGNALID
+            parts = query.data.split('_')
+            if len(parts) > 2 and query.data.startswith("signal_technical_"):
+                signal_id = "_".join(parts[2:]) # SIGNALID can contain underscores
+                if context and hasattr(context, 'user_data'):
+                    context.user_data['signal_id'] = signal_id
+                    logger.info(f"Extracted and stored signal_id: {signal_id} in signal_technical_callback")
+            else:
+                logger.warning(f"Could not extract signal_id from query.data: {query.data} in signal_technical_callback")
+                # Fallback or error handling if signal_id is crucial and not found
+
+        except Exception as e:
+            logger.error(f"Error extracting signal_id in signal_technical_callback: {e}")
+
         if context and hasattr(context, 'user_data'):
-            # Reset signal flow flags
-            context.user_data['from_signal'] = False
-            context.user_data['in_signal_flow'] = False
-            logger.info(f"Reset signal flow flags: from_signal=False, in_signal_flow=False")
             context.user_data['analysis_type'] = 'technical'
-        
-        # Get the instrument from context
-        instrument = None
-        if context and hasattr(context, 'user_data'):
-            # Reset signal flow flags
-            context.user_data['from_signal'] = False
-            context.user_data['in_signal_flow'] = False
-            logger.info(f"Reset signal flow flags: from_signal=False, in_signal_flow=False")
-            instrument = context.user_data.get('instrument')
-            # Debug log for instrument
+            instrument = context.user_data.get('instrument') # Should be set by analyze_from_signal_callback
             logger.info(f"Instrument from context: {instrument}")
-        
-        # Check if the callback data contains an instrument (signal_flow pattern)
-        if query.data.startswith("signal_flow_technical_"):
-            parts = query.data.split("_")
-            if len(parts) >= 4:
-                instrument = parts[3]  # Extract instrument from callback data
-                logger.info(f"Extracted instrument from callback data: {instrument}")
-                # Save to context
-                if context and hasattr(context, 'user_data'):
-                    # Reset signal flow flags
-                    context.user_data['from_signal'] = False
-                    context.user_data['in_signal_flow'] = False
-                    logger.info(f"Reset signal flow flags: from_signal=False, in_signal_flow=False")
-                    context.user_data['instrument'] = instrument
+        else:
+            # This should ideally not happen if flow is correct
+            logger.error("Context or user_data not found in signal_technical_callback")
+            await query.edit_message_text(text="Error: Session data lost. Please restart interaction.", reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("‚¨ÖÔ∏è Main Menu", callback_data="back_menu")]]))
+            return MENU
         
         if instrument:
-            # Set flag to indicate we're in signal flow
             if context and hasattr(context, 'user_data'):
-                # Reset signal flow flags
-                context.user_data['from_signal'] = False
-                context.user_data['in_signal_flow'] = False
-                logger.info(f"Reset signal flow flags: from_signal=False, in_signal_flow=False")
                 context.user_data['from_signal'] = True
                 logger.info("Set from_signal flag to True")
             
             # Try to show loading animation first
-            loading_gif_url = "https://media.giphy.com/media/gSzIKNrqtotEYrZv7i/giphy.gif"\n            loading_text = f"Loading {instrument} chart..."
+            loading_gif_url = "https://media.giphy.com/media/gSzIKNrqtotEYrZv7i/giphy.gif"
+            loading_text = f"Loading {instrument} chart..."
             
             # Store the current message ID to ensure we can find it later
             message_id = query.message.message_id
@@ -18064,7 +2248,7 @@ To continue using Sigmapips AI and receive trading signals, please reactivate yo
             
             loading_message = None
             
-        try:
+            try:
                 # Try to update with animated GIF first (best visual experience)
                 await query.edit_message_media(
                     media=InputMediaAnimation(
@@ -18072,34 +2256,30 @@ To continue using Sigmapips AI and receive trading signals, please reactivate yo
                         caption=loading_text
                     )
                 )
-                logger.info(f"Successfully showed loading GIF for {instrument}")
+                logger.info(f"Successfully showed loading GIF for {instrument} technical analysis")
             except Exception as media_error:
-            logger.warning(f"Could not update with GIF: {str(media_error)}")
+                logger.warning(f"Could not update with GIF: {str(media_error)}")
                 
                 # If GIF fails, try to update the text
-            try:
+                try:
                     loading_message = await query.edit_message_text(
                         text=loading_text
                     )
                     if context and hasattr(context, 'user_data'):
-                        # Reset signal flow flags
-                        context.user_data['from_signal'] = False
-                        context.user_data['in_signal_flow'] = False
-                        logger.info(f"Reset signal flow flags: from_signal=False, in_signal_flow=False")
                         context.user_data['loading_message'] = loading_message
                 except Exception as text_error:
-                logger.warning(f"Could not update text: {str(text_error)}")
+                    logger.warning(f"Could not update text: {str(text_error)}")
                     
                     # If text update fails, try to update caption
-                try:
+                    try:
                         await query.edit_message_caption(
                             caption=loading_text
                         )
                     except Exception as caption_error:
-                    logger.warning(f"Could not update caption: {str(caption_error)}")
+                        logger.warning(f"Could not update caption: {str(caption_error)}")
                         
                         # Last resort - send a new message with loading GIF
-                    try:
+                        try:
                             from trading_bot.services.telegram_service.gif_utils import send_loading_gif
                             await send_loading_gif(
                                 self.bot,
@@ -18107,91 +2287,58 @@ To continue using Sigmapips AI and receive trading signals, please reactivate yo
                                 caption=f"‚è≥ <b>Analyzing technical data for {instrument}...</b>"
                             )
                         except Exception as gif_error:
-                        logger.warning(f"Could not show loading GIF: {str(gif_error)}")
+                            logger.warning(f"Could not show loading GIF: {str(gif_error)}")
             
             # Show technical analysis for this instrument
             return await self.show_technical_analysis(update, context, instrument=instrument)
-    else:
-            # Error handling - go back to signal analysis menu
-        try:
-                # First try to edit message text
-                await query.edit_message_text(
-                    text="Could not find the instrument. Please try again.",
-                    reply_markup=InlineKeyboardMarkup(SIGNAL_ANALYSIS_KEYBOARD)
-                )
-            except Exception as text_error:
-                # If that fails due to caption, try editing caption
-                if "There is no text in the message to edit" in str(text_error):
-                try:
-                        await query.edit_message_caption(
-                            caption="Could not find the instrument. Please try again.",
-                            reply_markup=InlineKeyboardMarkup(SIGNAL_ANALYSIS_KEYBOARD),
-                            parse_mode=ParseMode.HTML
-                        )
-                except Exception as e:
-                    logger.error(f"Failed to update caption in signal_technical_callback: {str(e)}")
-                        # Try to send a new message as last resort
-                        await query.message.reply_text(
-                            text="Could not find the instrument. Please try again.",
-                            reply_markup=InlineKeyboardMarkup(SIGNAL_ANALYSIS_KEYBOARD),
-                            parse_mode=ParseMode.HTML
-                        )
-                    else:
-                    # Re-raise for other errors
-                    raise
-            return CHOOSE_ANALYSIS
+        else:
+            logger.error(f"Instrument not found in context for signal_technical_callback (signal_id: {signal_id})")
+            keyboard_to_show_on_error = await self._get_keyboard_for_signal_analysis_options(context)
+            await query.edit_message_text(
+                text="Could not find the instrument for technical analysis. Please try again.",
+                reply_markup=keyboard_to_show_on_error
+            )
+            return CHOOSE_ANALYSIS # Or back to analyze_from_signal_callback state
 
     async def signal_sentiment_callback(self, update: Update, context=None) -> int:
         """Handle signal_sentiment button press"""
         query = update.callback_query
         await query.answer()
         
-        # Save analysis type in context
+        logger.info(f"signal_sentiment_callback called with query data: {query.data}")
+        signal_id = None
+        try:
+            # query.data is now signal_sentiment_SIGNALID
+            parts = query.data.split('_')
+            if len(parts) > 2 and query.data.startswith("signal_sentiment_"):
+                signal_id = "_".join(parts[2:]) # SIGNALID can contain underscores
+                if context and hasattr(context, 'user_data'):
+                    context.user_data['signal_id'] = signal_id
+                    logger.info(f"Extracted and stored signal_id: {signal_id} in signal_sentiment_callback")
+            else:
+                logger.warning(f"Could not extract signal_id from query.data: {query.data} in signal_sentiment_callback")
+
+        except Exception as e:
+            logger.error(f"Error extracting signal_id in signal_sentiment_callback: {e}")
+
         if context and hasattr(context, 'user_data'):
-            # Reset signal flow flags
-            context.user_data['from_signal'] = False
-            context.user_data['in_signal_flow'] = False
-            logger.info(f"Reset signal flow flags: from_signal=False, in_signal_flow=False")
             context.user_data['analysis_type'] = 'sentiment'
-        
-        # Get the instrument from context
-        instrument = None
-        if context and hasattr(context, 'user_data'):
-            # Reset signal flow flags
-            context.user_data['from_signal'] = False
-            context.user_data['in_signal_flow'] = False
-            logger.info(f"Reset signal flow flags: from_signal=False, in_signal_flow=False")
             instrument = context.user_data.get('instrument')
-            logger.info(f"Instrument from context: {instrument}")
-        
-        # Check if the callback data contains an instrument (signal_flow pattern)
-        if query.data.startswith("signal_flow_sentiment_"):
-            parts = query.data.split("_")
-            if len(parts) >= 4:
-                instrument = parts[3]  # Extract instrument from callback data
-                logger.info(f"Extracted instrument from callback data: {instrument}")
-                # Save to context
-                if context and hasattr(context, 'user_data'):
-                    # Reset signal flow flags
-                    context.user_data['from_signal'] = False
-                    context.user_data['in_signal_flow'] = False
-                    logger.info(f"Reset signal flow flags: from_signal=False, in_signal_flow=False")
-                    context.user_data['instrument'] = instrument
-                    logger.info(f"Instrument from context: {instrument}")
+            logger.info(f"Instrument from context: {instrument} for signal_id: {signal_id}")
+        else:
+            logger.error("Context or user_data not found in signal_sentiment_callback")
+            await query.edit_message_text(text="Error: Session data lost. Please restart interaction.", reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("‚¨ÖÔ∏è Main Menu", callback_data="back_menu")]]))
+            return MENU
         
         if instrument:
-            # Set flag to indicate we're in signal flow
             if context and hasattr(context, 'user_data'):
-                # Reset signal flow flags
-                context.user_data['from_signal'] = False
-                context.user_data['in_signal_flow'] = False
-                logger.info(f"Reset signal flow flags: from_signal=False, in_signal_flow=False")
                 context.user_data['from_signal'] = True
             
             # Try to show loading animation first
-            loading_gif_url = "https://media.giphy.com/media/gSzIKNrqtotEYrZv7i/giphy.gif"\n            loading_text = f"Loading sentiment analysis for {instrument}..."
+            loading_gif_url = "https://media.giphy.com/media/gSzIKNrqtotEYrZv7i/giphy.gif"
+            loading_text = f"Loading sentiment analysis for {instrument}..."
             
-        try:
+            try:
                 # Try to update with animated GIF first (best visual experience)
                 await query.edit_message_media(
                     media=InputMediaAnimation(
@@ -18201,32 +2348,28 @@ To continue using Sigmapips AI and receive trading signals, please reactivate yo
                 )
                 logger.info(f"Successfully showed loading GIF for {instrument} sentiment analysis")
             except Exception as media_error:
-            logger.warning(f"Could not update with GIF: {str(media_error)}")
+                logger.warning(f"Could not update with GIF: {str(media_error)}")
                 
                 # If GIF fails, try to update the text
-            try:
+                try:
                     loading_message = await query.edit_message_text(
                         text=loading_text
                     )
                     if context and hasattr(context, 'user_data'):
-                        # Reset signal flow flags
-                        context.user_data['from_signal'] = False
-                        context.user_data['in_signal_flow'] = False
-                        logger.info(f"Reset signal flow flags: from_signal=False, in_signal_flow=False")
                         context.user_data['loading_message'] = loading_message
                 except Exception as text_error:
-                logger.warning(f"Could not update text: {str(text_error)}")
+                    logger.warning(f"Could not update text: {str(text_error)}")
                     
                     # If text update fails, try to update caption
-                try:
+                    try:
                         await query.edit_message_caption(
                             caption=loading_text
                         )
                     except Exception as caption_error:
-                    logger.warning(f"Could not update caption: {str(caption_error)}")
+                        logger.warning(f"Could not update caption: {str(caption_error)}")
                         
                         # Last resort - send a new message with loading GIF
-                    try:
+                        try:
                             from trading_bot.services.telegram_service.gif_utils import send_loading_gif
                             await send_loading_gif(
                                 self.bot,
@@ -18234,2144 +2377,2142 @@ To continue using Sigmapips AI and receive trading signals, please reactivate yo
                                 caption=f"‚è≥ <b>Analyzing market sentiment for {instrument}...</b>"
                             )
                         except Exception as gif_error:
-                        logger.warning(f"Could not show loading GIF: {str(gif_error)}")
+                            logger.warning(f"Could not show loading GIF: {str(gif_error)}")
             
             # Show sentiment analysis for this instrument
             return await self.show_sentiment_analysis(update, context, instrument=instrument)
-    else:
-            # Error handling - go back to signal analysis menu
-        try:
-                # First try to edit message text
-                await query.edit_message_text(
-                    text="Could not find the instrument. Please try again.",
-                    reply_markup=InlineKeyboardMarkup(SIGNAL_ANALYSIS_KEYBOARD)
-                )
-            except Exception as text_error:
-                # If that fails due to caption, try editing caption
-                if "There is no text in the message to edit" in str(text_error):
-                try:
-                        await query.edit_message_caption(
-                            caption="Could not find the instrument. Please try again.",
-                            reply_markup=InlineKeyboardMarkup(SIGNAL_ANALYSIS_KEYBOARD),
-                            parse_mode=ParseMode.HTML
-                        )
-                except Exception as e:
-                    logger.error(f"Failed to update caption in signal_sentiment_callback: {str(e)}")
-                        # Try to send a new message as last resort
-                        await query.message.reply_text(
-                            text="Could not find the instrument. Please try again.",
-                            reply_markup=InlineKeyboardMarkup(SIGNAL_ANALYSIS_KEYBOARD),
-                            parse_mode=ParseMode.HTML
-                        )
-                    else:
-                # Re-raise for other errors
-                raise
-        return CHOOSE_ANALYSIS
+        else:
+            logger.error(f"Instrument not found in context for signal_sentiment_callback (signal_id: {signal_id})")
+            keyboard_to_show_on_error = await self._get_keyboard_for_signal_analysis_options(context)
+            await query.edit_message_text(
+                text="Could not find the instrument for sentiment analysis. Please try again.",
+                reply_markup=keyboard_to_show_on_error
+            )
+            return CHOOSE_ANALYSIS
 
     async def signal_calendar_callback(self, update: Update, context=None) -> int:
         """Handle signal_calendar button press"""
         query = update.callback_query
         await query.answer()
+
+        logger.info(f"signal_calendar_callback called with query data: {query.data}")
+        signal_id = None
+        instrument_from_context = None # Initialize
+
+        try:
+            # query.data could be signal_calendar_SIGNALID or signal_flow_calendar_INSTRUMENT_TIMEFRAME_etc
+            parts = query.data.split('_')
+            if query.data.startswith("signal_calendar_") and len(parts) > 2:
+                signal_id = "_".join(parts[2:]) # SIGNALID can contain underscores
+                if context and hasattr(context, 'user_data'):
+                    context.user_data['signal_id'] = signal_id
+                    instrument_from_context = context.user_data.get('instrument') # Instrument should be in context from analyze_from_signal
+                    logger.info(f"Extracted signal_id: {signal_id} for instrument {instrument_from_context} in signal_calendar_callback (signal_calendar_ pattern)")
+            elif query.data.startswith("signal_flow_calendar_") and len(parts) > 3:
+                 # This pattern seems to carry instrument and timeframe directly, useful if context is lost
+                 # signal_flow_calendar_INSTRUMENT_TIMEFRAME_SIGNALID_OR_OTHER
+                 instrument_from_context = parts[3]
+                 # Attempt to get signal_id if it's part of this pattern, e.g. the last part or a known structure
+                 # This is a bit ambiguous without knowing the exact structure of signal_flow_calendar_
+                 # For now, prioritize signal_id from context if available, or if it's clearly at the end of this callback
+                 # Assuming signal_id might be last if present in this callback structure
+                 potential_signal_id = parts[-1] # Example: could be the signal_id
+                 # A more robust way would be to ensure analyze_from_signal sets signal_id reliably.
+                 if context and hasattr(context, 'user_data'):
+                    if not context.user_data.get('signal_id') and "signal_" in potential_signal_id: # Basic check
+                        # context.user_data['signal_id'] = potential_signal_id
+                        # logger.info(f"Tentatively extracted signal_id: {potential_signal_id} from signal_flow_calendar_ pattern")
+                        pass # Prefer signal_id set by analyze_from_signal_callback
+                    if not context.user_data.get('instrument'):
+                        context.user_data['instrument'] = instrument_from_context
+                    signal_id = context.user_data.get('signal_id') # Rely on signal_id from previous step
+                 logger.info(f"Processing signal_flow_calendar_ for instrument {instrument_from_context}, relying on signal_id: {signal_id} from context")
+            else:
+                logger.warning(f"Could not extract signal_id reliably from query.data: {query.data} in signal_calendar_callback")
+
+        except Exception as e:
+            logger.error(f"Error extracting signal_id/instrument in signal_calendar_callback: {e}")
         
-        # Add detailed debug logging
-        logger.info(f"signal_calendar_callback called with data: {query.data}")
-        
-        # Save analysis type in context
         if context and hasattr(context, 'user_data'):
-            # Reset signal flow flags
-            context.user_data['from_signal'] = False
-            context.user_data['in_signal_flow'] = False
-            logger.info(f"Reset signal flow flags: from_signal=False, in_signal_flow=False")
             context.user_data['analysis_type'] = 'calendar'
-            # Make sure we save the original signal data to return to later
-            signal_instrument = context.user_data.get('instrument')
-            signal_direction = context.user_data.get('signal_direction')
-            signal_timeframe = context.user_data.get('signal_timeframe') 
+            # Ensure instrument is set if not already from a specific pattern like signal_flow_calendar_
+            if not instrument_from_context:
+                instrument_from_context = context.user_data.get('instrument')
+            else: # If pattern provided instrument, ensure it's in context
+                context.user_data['instrument'] = instrument_from_context
             
-            # Save these explicitly to ensure they're preserved
-            context.user_data['signal_instrument_backup'] = signal_instrument
-            context.user_data['signal_direction_backup'] = signal_direction
-            context.user_data['signal_timeframe_backup'] = signal_timeframe
+            # Ensure signal_id from context (set by analyze_from_signal) is the primary one used
+            signal_id = context.user_data.get('signal_id')
+            logger.info(f"Using instrument: {instrument_from_context} and signal_id: {signal_id} for calendar (from context)")
             
-            # Log for debugging
-            logger.info(f"Saved signal data before calendar analysis: instrument={signal_instrument}, direction={signal_direction}, timeframe={signal_timeframe}")
-        
-        # Get the instrument from context (voor tracking van context en eventuele toekomstige functionaliteit)
-        instrument = None
-        if context and hasattr(context, 'user_data'):
-            # Reset signal flow flags
-            context.user_data['from_signal'] = False
-            context.user_data['in_signal_flow'] = False
-            logger.info(f"Reset signal flow flags: from_signal=False, in_signal_flow=False")
-            instrument = context.user_data.get('instrument')
-            logger.info(f"Instrument from context: {instrument}")
-        
-        # Check if the callback data contains an instrument (signal_flow pattern)
-        if query.data.startswith("signal_flow_calendar_"):
-            parts = query.data.split("_")
-            if len(parts) >= 4:
-                instrument = parts[3]  # Extract instrument from callback data
-                logger.info(f"Extracted instrument from callback data: {instrument}")
-                # Save to context
-                if context and hasattr(context, 'user_data'):
-                    # Reset signal flow flags
-                    context.user_data['from_signal'] = False
-                    context.user_data['in_signal_flow'] = False
-                    logger.info(f"Reset signal flow flags: from_signal=False, in_signal_flow=False")
-                    context.user_data['instrument'] = instrument
-                    logger.info(f"Instrument from context: {instrument}")
-        
-        # Check if the callback data contains an instrument
-        if query.data.startswith("signal_flow_calendar_"):
-            parts = query.data.split("_")
-            if len(parts) >= 4:
-                instrument = parts[3]  # Extract instrument from callback data
-                logger.info(f"Extracted instrument from callback data: {instrument}")
-                # Save to context
-                if context and hasattr(context, 'user_data'):
-                    # Reset signal flow flags
-                    context.user_data['from_signal'] = False
-                    context.user_data['in_signal_flow'] = False
-                    logger.info(f"Reset signal flow flags: from_signal=False, in_signal_flow=False")
-                    context.user_data['instrument'] = instrument
-        
-        # Set flag to indicate we're in signal flow
-        if context and hasattr(context, 'user_data'):
-                # Reset signal flow flags
-            context.user_data['from_signal'] = False
-            context.user_data['in_signal_flow'] = False
-            logger.info(f"Reset signal flow flags: from_signal=False, in_signal_flow=False")
             context.user_data['from_signal'] = True
-            logger.info(f"Set from_signal flag to True for calendar analysis")
+            logger.info(f"Set from_signal flag to True for calendar analysis (signal_id: {signal_id})")
+        else:
+            logger.error("Context or user_data not found in signal_calendar_callback")
+            await query.edit_message_text(text="Error: Session data lost. Please restart interaction.", reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("‚¨ÖÔ∏è Main Menu", callback_data="back_menu")]]))
+            return MENU
         
-        # Try to show loading animation first
-        loading_gif_url = "https://media.giphy.com/media/gSzIKNrqtotEYrZv7i/giphy.gif"\n        loading_text = f"Loading economic calendar..."
+        # Show calendar analysis for ALL major currencies (or for instrument_from_context if applicable for show_calendar_analysis)
+        # The current show_calendar_analysis(..., instrument=None) implies global view.
+        # If it can take an instrument, pass instrument_from_context.
+        return await self.show_calendar_analysis(update, context, instrument=instrument_from_context) # Pass instrument if show_calendar_analysis can use it
+
+    async def _get_keyboard_for_signal_analysis_options(self, context: CallbackContext) -> InlineKeyboardMarkup:
+        """Helper to generate the keyboard for signal analysis options, using instrument and signal_id from context."""
+        instrument = context.user_data.get('instrument')
+        signal_id = context.user_data.get('signal_id')
+        keyboard = []
+        if instrument and signal_id:
+            keyboard.append([InlineKeyboardButton(f"üìà Technical Analysis ({instrument})", callback_data=f"signal_technical_{signal_id}")])
+            keyboard.append([InlineKeyboardButton(f"üß† Market Sentiment ({instrument})", callback_data=f"signal_sentiment_{signal_id}")])
+            keyboard.append([InlineKeyboardButton(f"üìÖ Economic Calendar (Overall)", callback_data=f"signal_calendar_{signal_id}")])
+            keyboard.append([InlineKeyboardButton("‚¨ÖÔ∏è Back to Original Signal", callback_data=f"back_to_signal_{signal_id}")])
+        else:
+            # Fallback if critical info is missing - this indicates a flow error
+            logger.error("Cannot generate signal analysis options keyboard: instrument or signal_id missing from context.")
+            keyboard.append([InlineKeyboardButton("‚¨ÖÔ∏è Error: Back to Menu", callback_data="back_menu")])
+        return InlineKeyboardMarkup(keyboard)
+
+    async def back_to_signal_callback(self, update: Update, context=None) -> int:
+        """Handle back_to_signal button press"""
+        query = update.callback_query
+        await query.answer()
         
-    try:
-            # Try to update with animated GIF first (best visual experience)
-            await query.edit_message_media(
-                media=InputMediaAnimation(
-                    media=loading_gif_url,
-                    caption=loading_text
+        user_id_str = str(update.effective_user.id)
+        signal_id = None
+
+        try:
+            # Extract signal_id from callback_data (e.g., "back_to_signal_INSTRUMENT_DIRECTION_TIMEFRAME_TIMESTAMP")
+            parts = query.data.split('_')
+            if len(parts) > 3 and query.data.startswith("back_to_signal_"):
+                # Reconstruct signal_id starting from the third part (index 3)
+                signal_id = "_".join(parts[3:]) 
+                logger.info(f"Extracted signal_id: {signal_id} from callback_data: {query.data}")
+
+            if not signal_id:
+                logger.error(f"Could not extract signal_id from callback_data: {query.data}")
+                await query.edit_message_text(
+                    text="Error: Could not identify the signal to return to. Please use the main menu.",
+                    reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("‚¨ÖÔ∏è Main Menu", callback_data="back_menu")]]) # Ensure START_KEYBOARD is defined or use a safe fallback
+                )
+                return MENU
+
+            signal_data = self.user_signals.get(user_id_str, {}).get(signal_id)
+            
+            if not signal_data:
+                logger.warning(f"Signal {signal_id} not found in user_signals for user {user_id_str}. Attempting to load from disk.")
+                # Attempt to load from disk if not in memory (optional enhancement, ensure _load_signals structure matches)
+                signal_file_path = os.path.join(self.signals_dir, f"{signal_id}.json")
+                if os.path.exists(signal_file_path):
+                    try:
+                        with open(signal_file_path, 'r') as f:
+                            signal_data = json.load(f)
+                        # Optionally, add to self.user_signals here if frequently accessed
+                        if user_id_str not in self.user_signals:
+                            self.user_signals[user_id_str] = {}
+                        self.user_signals[user_id_str][signal_id] = signal_data
+                        logger.info(f"Successfully loaded signal {signal_id} from disk.")
+                    except Exception as e:
+                        logger.error(f"Error loading signal {signal_id} from disk: {e}")
+                        signal_data = None # Ensure it's None if loading failed
+                else:
+                    logger.warning(f"Signal file {signal_file_path} does not exist.")
+
+            if not signal_data:
+                # Fallback message if signal not found even after disk check
+                await query.edit_message_text(
+                    text="Original signal data not found. It might be too old or an error occurred. Please use the main menu.",
+                    reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("‚¨ÖÔ∏è Main Menu", callback_data="back_menu")]])
                 )
+                return MENU
+            
+            # Show the signal details with analyze button
+            instrument = signal_data.get('instrument', 'UnknownInstrument') # Get instrument from signal_data
+            
+            # Prepare analyze button with signal info embedded
+            keyboard = [
+                [InlineKeyboardButton("üîç Analyze Market", callback_data=f"analyze_from_signal_{instrument}_{signal_id}")]
+            ]
+            
+            # Get the formatted message from the signal
+            signal_message = signal_data.get('message', "Signal details not available.")
+            
+            # Edit current message to show signal
+            await query.edit_message_text(
+                text=signal_message,
+                reply_markup=InlineKeyboardMarkup(keyboard),
+                parse_mode=ParseMode.HTML
             )
-            logger.info(f"Successfully showed loading GIF for economic calendar")
-        except Exception as media_error:
-        logger.warning(f"Could not update with GIF: {str(media_error)}")
             
-            # If GIF fails, try to update the text
-        try:
-                loading_message = await query.edit_message_text(
-                    text=loading_text
-                )
-                if context and hasattr(context, 'user_data'):
-                    # Reset signal flow flags
-                    context.user_data['from_signal'] = False
-                    context.user_data['in_signal_flow'] = False
-                    logger.info(f"Reset signal flow flags: from_signal=False, in_signal_flow=False")
-                    context.user_data['loading_message'] = loading_message
-            except Exception as text_error:
-            logger.warning(f"Could not update text: {str(text_error)}")
-                
-                # If text update fails, try to update caption
+            # Store necessary details in context if needed for subsequent actions
+            if context and hasattr(context, 'user_data'):
+                context.user_data['instrument'] = instrument
+                context.user_data['signal_id'] = signal_id
+                context.user_data['signal_instrument_backup'] = instrument # Keep backups if other parts of your code rely on them
+                context.user_data['signal_id_backup'] = signal_id
+                context.user_data['from_signal'] = True # Re-affirm we are in signal flow
+
+            return SIGNAL_DETAILS
+            
+        except Exception as e:
+            logger.error(f"Error in back_to_signal_callback (signal_id: {signal_id}): {str(e)}")
+            logger.exception(e)
+            
             try:
-                    await query.edit_message_caption(
-                        caption=loading_text
-                    )
-                except Exception as caption_error:
-                logger.warning(f"Could not update caption: {str(caption_error)}")
-                    
-                    # Last resort - send a new message with loading GIF
-                try:
-                        from trading_bot.services.telegram_service.gif_utils import send_loading_gif
-                        await send_loading_gif(
-                            self.bot,
-                            update.effective_chat.id,
-                            caption=f"‚è≥ <b>Loading economic calendar...</b>"
-                        )
-                    except Exception as gif_error:
-                    logger.warning(f"Could not show loading GIF: {str(gif_error)}")
-        
-        # Show calendar analysis for ALL major currencies
-        return await self.show_calendar_analysis(update, context, instrument=None)
+                await query.edit_message_text(
+                    text="An error occurred while trying to return to the signal. Please try again from the main menu.",
+                    reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("‚¨ÖÔ∏è Main Menu", callback_data="back_menu")]])
+                )
+            except Exception:
+                pass
+            
+            return MENU
 
-    
     async def analyze_from_signal_callback(self, update: Update, context=None) -> int:
         """Handle Analyze Market button from signal notifications"""
         query = update.callback_query
-        # Add query.answer() to acknowledge the callback
-        await query.answer()
+        await query.answer() # Answer callback quickly
         logger.info(f"analyze_from_signal_callback called with data: {query.data}")
         
-    try:
-            # Extract signal information from callback data
+        instrument = None
+        signal_id = None
+        user_id_str = str(update.effective_user.id)
+
+        try:
             parts = query.data.split('_')
-            
             # Format: analyze_from_signal_INSTRUMENT_SIGNALID
-            if len(parts) >= 4:
+            # analyze_from_signal_EURUSD_EURUSD_BUY_1h_1678886400
+            # parts[0] = analyze
+            # parts[1] = from
+            # parts[2] = signal
+            # parts[3] = INSTRUMENT (e.g., EURUSD)
+            # parts[4:] = SIGNAL_ID (e.g., EURUSD_BUY_1h_1678886400)
+            if len(parts) >= 4 and query.data.startswith("analyze_from_signal_"):
                 instrument = parts[3]
-                signal_id = parts[4] if len(parts) >= 5 else None
+                if len(parts) >= 5:
+                    signal_id = "_".join(parts[4:])
                 
+                logger.info(f"Extracted for analysis: instrument='{instrument}', signal_id='{signal_id}'")
+
+                if not instrument or not signal_id:
+                    logger.error(f"Could not properly extract instrument or signal_id from {query.data}")
+                    await query.edit_message_text(text="Error: Invalid signal analysis request.", reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("‚¨ÖÔ∏è Main Menu", callback_data="back_menu")]]))
+                    return MENU
+
                 # Store in context for other handlers
                 if context and hasattr(context, 'user_data'):
-                    # Reset signal flow flags
-                    context.user_data['from_signal'] = False
-                    context.user_data['in_signal_flow'] = False
-                    logger.info(f"Reset signal flow flags: from_signal=False, in_signal_flow=False")
                     context.user_data['instrument'] = instrument
-                    if signal_id:
-                        context.user_data['signal_id'] = signal_id
-                    # Set signal flow flags (only once)
-                    context.user_data['from_signal'] = True
-                    context.user_data['in_signal_flow'] = True
-                    logger.info(f"Set signal flow flags: from_signal=True, in_signal_flow=True")
-                    
-                    # Make a backup copy to ensure we can return to signal later
-                    context.user_data['signal_instrument'] = instrument
+                    context.user_data['signal_id'] = signal_id
                     context.user_data['signal_instrument_backup'] = instrument
-                    if signal_id:
-                        context.user_data['signal_id_backup'] = signal_id
-                    
-                    # Also store info from the actual signal if available
-                    if str(update.effective_user.id) in self.user_signals and signal_id in self.user_signals[str(update.effective_user.id)]:
-                        signal = self.user_signals[str(update.effective_user.id)][signal_id]
-                        if signal:
-                            context.user_data['signal_direction'] = signal.get('direction')
-                            # Use interval or timeframe, whichever is available
-                            timeframe = signal.get('interval') or signal.get('timeframe')
-                            context.user_data['signal_timeframe'] = timeframe
-                            # Backup copies
-                            context.user_data['signal_timeframe_backup'] = timeframe
-                            context.user_data['signal_direction_backup'] = signal.get('direction')
-                
-                # Store the original signal page for later retrieval
-                await self._store_original_signal_page(update, context, instrument, signal_id)
-                
-                # Show analysis options for this instrument
-                keyboard = [
-                    [InlineKeyboardButton("Technical Analysis", callback_data=f"signal_flow_technical_{instrument}")],
-                    [InlineKeyboardButton("Market Sentiment", callback_data=f"signal_flow_sentiment_{instrument}")],
-                    [InlineKeyboardButton("Economic Calendar", callback_data=f"signal_flow_calendar_{instrument}")],
-                    [InlineKeyboardButton("Back to Signal", callback_data="back_to_signal")]
-                ]
-                
-                # Update the message with the analysis options
-                await query.edit_message_text(
-                    text=f"<b> Analyze {instrument}</b>\n\nSelect the type of analysis you want to perform:",
-                    reply_markup=InlineKeyboardMarkup(keyboard),
-                    parse_mode=ParseMode.HTML
-                )
-                
-                return CHOOSE_ANALYSIS
-        else:
-                # Invalid callback data
-                await query.edit_message_text(
-                    text="Invalid signal format. Please try again from the main menu.",
-                    reply_markup=InlineKeyboardMarkup(START_KEYBOARD)
-                )
+                    context.user_data['signal_id_backup'] = signal_id
+                    context.user_data['from_signal'] = True # Explicitly set we are in signal flow
+                    context.user_data['in_signal_flow'] = True # Explicitly set we are in signal flow
+
+                    # Retrieve and store full signal details in context if needed by deeper analysis functions
+                    # This also re-verifies the signal_id is valid for the user
+                    signal_details = self.user_signals.get(user_id_str, {}).get(signal_id)
+                    if signal_details:
+                        context.user_data['current_signal_details'] = signal_details
+                        context.user_data['signal_direction'] = signal_details.get('direction')
+                        context.user_data['signal_timeframe'] = signal_details.get('timeframe') # Note: process_signal uses 'timeframe', not 'interval' for normalized_data
+                        context.user_data['signal_direction_backup'] = signal_details.get('direction')
+                        context.user_data['signal_timeframe_backup'] = signal_details.get('timeframe')
+                        logger.info(f"Stored full signal details in context: direction={signal_details.get('direction')}, timeframe={signal_details.get('timeframe')}")
+                    else:
+                        logger.warning(f"Signal {signal_id} not found in self.user_signals for user {user_id_str} during analyze_from_signal_callback. Context may be incomplete for deeper analysis.")
+                        # Don't fail here, but deeper analysis might need to handle this
+            else:
+                logger.error(f"Legacy or malformed analyze_from_signal callback: {query.data}")
+                # Try to extract instrument for legacy support if absolutely necessary, but prefer failing
+                instrument = parts[3] if len(parts) >= 4 else None
+                if instrument and context and hasattr(context, 'user_data'):
+                     context.user_data['instrument'] = instrument
+                     context.user_data['signal_instrument_backup'] = instrument
+                # No signal_id here, so we can't proceed with the new flow properly.
+                await query.edit_message_text(text="Error: Signal information is incomplete. Cannot proceed with analysis.", reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("‚¨ÖÔ∏è Main Menu", callback_data="back_menu")]]))
                 return MENU
-    except Exception as e:
-        logger.error(f"Error in analyze_from_signal_callback: {str(e)}")
-        logger.exception(e)
-            
-            # Error recovery
-        try:
-                await query.edit_message_text(
-                    text="An error occurred. Please try again from the main menu.",
-                    reply_markup=InlineKeyboardMarkup(START_KEYBOARD)
-                )
-            except Exception:
-                pass
-            return MENU
-    except Exception as e:
-        logger.error(f"Error in analyze_from_signal_callback: {str(e)}")
-            # Error recovery
-        try:
-                await query.edit_message_text(
-                    text="An error occurred. Please try again from the main menu.",
-                    reply_markup=InlineKeyboardMarkup(START_KEYBOARD)
-                )
-            except Exception:
-                pass
-            return MENU
-
-    async def _store_original_signal_page(self, update: Update, context: ContextTypes.DEFAULT_TYPE, instrument: str, signal_id: str):
-        """Store the original signal page data for later retrieval"""
-    try:
-        # Fetch the signal data from the database
-            signal_data = await self.db.get_user_signals(update.effective_user.id, instrument)
-            
-            if signal_data:
-                # Prepare the signal page data
-                signal_page_data = {
-                    "instrument": instrument,
-                    "signal_id": signal_id,
-                    "message": signal_data[0].get('message'),
-                    "timestamp": signal_data[0].get('timestamp')
-                }
-                
-                # Save the signal page data to the database
-                await self.db.save_signal_page(update.effective_user.id, instrument, signal_page_data)
-                
-                logger.info(f"Original signal page data stored for {instrument} with signal ID {signal_id}")
-        else:
-            logger.warning(f"No signal data found for {instrument} with signal ID {signal_id}")
-    except Exception as e:
-        logger.error(f"Error storing original signal page: {str(e)}")
-        logger.exception(e)
-
-    async def _get_original_signal_page(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
-        """Retrieve the original signal page data for a given signal"""
-    try:
-        # Fetch the signal page data from the database
-            signal_page_data = await self.db.get_signal_page(update.effective_user.id, update.callback_query.data.split('_')[3])
             
-            if signal_page_data:
-                return signal_page_data
-        else:
-            logger.warning(f"No signal page data found for signal ID {update.callback_query.data.split('_')[3]}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving original signal page: {str(e)}")
-        logger.exception(e)
-        return None
+            # Dynamically build the keyboard for signal analysis options
+            keyboard = []
+            analysis_message_text = f"ü§ñ Signal Analysis for <b>{instrument}</b> ({signal_id}) ü§ñ\nWhat would you like to analyze?"
 
-    async def _load_signals(self):
-        """Load signals from the database"""
-    try:
-        # Fetch all signals from the database
-            signals = await self.db.get_all_signals()
-            
-            if signals:
-                for signal in signals:
-                    self.user_signals[str(signal['user_id'])] = {signal['id']: signal}
-                logger.info(f"Loaded {len(signals)} signals from the database")
-        else:
-                logger.info("No signals found in the database")
-    except Exception as e:
-        logger.error(f"Error loading signals: {str(e)}")
-        logger.exception(e)
+            if instrument and signal_id: # Ensure we have both
+                keyboard.append([InlineKeyboardButton(f"üìà Technical Analysis ({instrument})", callback_data=f"signal_technical_{signal_id}")])
+                keyboard.append([InlineKeyboardButton(f"üß† Market Sentiment ({instrument})", callback_data=f"signal_sentiment_{signal_id}")])
+                # For calendar, it's typically broader, but we pass signal_id for back navigation context
+                keyboard.append([InlineKeyboardButton(f"üìÖ Economic Calendar (Overall)", callback_data=f"signal_calendar_{signal_id}")])
+                keyboard.append([InlineKeyboardButton("‚¨ÖÔ∏è Back to Original Signal", callback_data=f"back_to_signal_{signal_id}")])
+            else:
+                # This case should ideally be caught by the checks above
+                logger.error("Instrument or signal_id missing before keyboard generation in analyze_from_signal_callback")
+                await query.edit_message_text(text="Critical error: Missing signal details for analysis options.", reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("‚¨ÖÔ∏è Main Menu", callback_data="back_menu")]]))
+                return MENU
 
-    async def _cleanup_old_signals(self, max_age_days):
-        """Cleanup old signals from the database"""
-    try:
-            # Calculate the date threshold
-            threshold_date = datetime.now() - timedelta(days=max_age_days)
-            
-        # Fetch signals older than the threshold date
-            signals_to_delete = await self.db.get_old_signals(threshold_date)
+            await query.edit_message_text(
+                text=analysis_message_text,
+                reply_markup=InlineKeyboardMarkup(keyboard),
+                parse_mode=ParseMode.HTML
+            )
             
-            if signals_to_delete:
-                for signal in signals_to_delete:
-                    await self.db.delete_signal(signal['id'])
-                logger.info(f"Deleted {len(signals_to_delete)} old signals from the database")
-        else:
-                logger.info("No old signals found to delete")
+            return CHOOSE_ANALYSIS # This state might need to be SIGNAL_ANALYSIS_OPTIONS or similar if distinct
+        
+        except Exception as e:
+            logger.error(f"Error in analyze_from_signal_callback (Query: {query.data if query else 'No Query'}): {str(e)}")
+            logger.exception(e)
             
-            return len(signals_to_delete)
-    except Exception as e:
-        logger.error(f"Error cleaning up old signals: {str(e)}")
-        logger.exception(e)
-            return 0
+            try:
+                # Try to edit message if query object exists
+                if query:
+                    await query.edit_message_text(
+                        text="An error occurred while preparing signal analysis. Please try again from the main menu.",
+                        reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("‚¨ÖÔ∏è Main Menu", callback_data="back_menu")]]))
+                # If no query object or edit fails, and update available, send new message
+                elif update and update.effective_message:
+                    await update.effective_message.reply_text(
+                        text="An error occurred. Please use the main menu.",
+                        reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("‚¨ÖÔ∏è Main Menu", callback_data="back_menu")]])) 
 
-    async def _format_signal_message(self, signal_data):
-        """Format the signal message for display"""
-    try:
-            # Extract fields from signal data
-            instrument = signal_data.get('instrument', 'Unknown')
-            direction = signal_data.get('direction', 'Unknown')
-            entry = signal_data.get('entry', 'Unknown')
-            stop_loss = signal_data.get('stop_loss')
-            take_profit = signal_data.get('take_profit')
-            timeframe = signal_data.get('timeframe', 'one_hour')
-            
-            # Get multiple take profit levels if available
-            tp1 = signal_data.get('tp1', take_profit)
-            tp2 = signal_data.get('tp2')
-            tp3 = signal_data.get('tp3')
-            
-            # Add emoji based on direction
-            direction_emoji = "üü¢" if direction.upper() == "BUY" else "üî¥"
-            
-            # Format the message with multiple take profits if available
-            message = "<b> New Trading Signal </b>\n"\n\n"
-            message += f"<b>Instrument:</b> {instrument}\n"
-            message += f"<b>Action:</b> {direction.upper()} {direction_emoji}\n\n"
-            message += f"<b>Entry Price:</b> {entry}\n"
-            
-            if stop_loss:
-                message += f"<b>Stop Loss:</b> {stop_loss} üî¥\n"
-            
-            # Add take profit levels
-            if tp1:
-                message += f"<b>Take Profit 1:</b> {tp1} \n"
-            if tp2:
-                message += f"<b>Take Profit 2:</b> {tp2} \n"
-            if tp3:
-                message += f"<b>Take Profit 3:</b> {tp3} \n"
-            
-            message += f"\n<b>Timeframe:</b> {timeframe}\n"
-            message += f"<b>Strategy:</b> TradingView Signal\n\n"
-            
-            message += "‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî\n\n"
-            message += "<b>Risk Management:</b>\n"
-            message += "- Position size: 1-2% max\n"
-            message += "- Use proper stop loss\n"
-            message += "- Follow your trading plan\n\n"
-            
-            message += "‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî\n\n"
-            
-            # Generate AI verdict
-            ai_verdict = f"The {instrument} {direction.lower()} signal shows a promising setup with defined entry at {entry} and stop loss at {stop_loss}. Multiple take profit levels provide opportunities for partial profit taking."
-            message += f"<b>ü§ñ SigmaPips AI Verdict:</b>\n{ai_verdict}"
+            except Exception as e_reply:
+                logger.error(f"Further error sending error message in analyze_from_signal_callback: {e_reply}")
             
-            return message
-    except Exception as e:
-        logger.error(f"Error formatting signal message: {str(e)}")
-        logger.exception(e)
-            return f"New {signal_data.get('instrument', 'Unknown')} {signal_data.get('direction', 'Unknown')} Signal"
+            return MENU
 
-    async def _get_signal_details(self, signal_id):
-        """Retrieve signal details from the database"""
-    try:
-        # Fetch the signal data from the database
-            signal_data = await self.db.get_signal(signal_id)
+    async def button_callback(self, update: Update, context=None) -> int:
+        """Handle button callback queries"""
+        try:
+            query = update.callback_query
+            callback_data = query.data
             
-            if signal_data:
-                return signal_data
-        else:
-            logger.warning(f"No signal data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving signal details: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_analysis(self, signal_id):
-        """Retrieve signal analysis from the database"""
-    try:
-        # Fetch the signal analysis data from the database
-            analysis_data = await self.db.get_signal_analysis(signal_id)
+            # Log the callback data
+            logger.info(f"Button callback opgeroepen met data: {callback_data}")
             
-            if analysis_data:
-                return analysis_data
-        else:
-            logger.warning(f"No analysis data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving signal analysis: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_sentiment(self, signal_id):
-        """Retrieve signal sentiment from the database"""
-    try:
-        # Fetch the signal sentiment data from the database
-            sentiment_data = await self.db.get_signal_sentiment(signal_id)
+            # Answer the callback query to stop the loading indicator
+            await query.answer()
             
-            if sentiment_data:
-                return sentiment_data
-        else:
-            logger.warning(f"No sentiment data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving signal sentiment: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_calendar(self, signal_id):
-        """Retrieve signal calendar data from the database"""
-    try:
-        # Fetch the signal calendar data from the database
-            calendar_data = await self.db.get_signal_calendar(signal_id)
+            # Handle analyze from signal button
+            if callback_data.startswith("analyze_from_signal_"):
+                return await self.analyze_from_signal_callback(update, context)
+                
+            # Help button
+            if callback_data == "help":
+                await self.help_command(update, context)
+                return MENU
+                
+            # Menu navigation
+            if callback_data == CALLBACK_MENU_ANALYSE:
+                return await self.menu_analyse_callback(update, context)
+            elif callback_data == CALLBACK_MENU_SIGNALS:
+                return await self.menu_signals_callback(update, context)
+            
+            # Analysis type selection
+            elif callback_data == CALLBACK_ANALYSIS_TECHNICAL or callback_data == "analysis_technical":
+                return await self.analysis_technical_callback(update, context)
+            elif callback_data == CALLBACK_ANALYSIS_SENTIMENT or callback_data == "analysis_sentiment":
+                return await self.analysis_sentiment_callback(update, context)
+            elif callback_data == CALLBACK_ANALYSIS_CALENDAR or callback_data == "analysis_calendar":
+                return await self.analysis_calendar_callback(update, context)
+                
+            # Direct instrument_timeframe callbacks  
+            if "_timeframe_" in callback_data:
+                # Format: instrument_EURUSD_timeframe_H1
+                parts = callback_data.split("_")
+                instrument = parts[1]
+                timeframe = parts[3] if len(parts) > 3 else "1h"  # Default to 1h
+                return await self.show_technical_analysis(update, context, instrument=instrument, timeframe=timeframe)
+            
+            # Verwerk instrument keuzes met specifiek type (chart, sentiment, calendar)
+            if "_chart" in callback_data or "_sentiment" in callback_data or "_calendar" in callback_data:
+                # Direct doorsturen naar de instrument_callback methode
+                logger.info(f"Specifiek instrument type gedetecteerd in: {callback_data}")
+                return await self.instrument_callback(update, context)
+            
+            # Handle instrument signal choices
+            if "_signals" in callback_data and callback_data.startswith("instrument_"):
+                logger.info(f"Signal instrument selection detected: {callback_data}")
+                return await self.instrument_signals_callback(update, context)
+            
+            # Speciale afhandeling voor markt keuzes
+            if callback_data.startswith("market_"):
+                return await self.market_callback(update, context)
+            
+            # Signals handlers
+            if callback_data == "signals_add" or callback_data == CALLBACK_SIGNALS_ADD:
+                return await self.signals_add_callback(update, context)
+                
+            # Manage signals handler
+            if callback_data == "signals_manage" or callback_data == CALLBACK_SIGNALS_MANAGE:
+                return await self.signals_manage_callback(update, context)
+            
+            # Back navigation handlers
+            if callback_data == "back_menu" or callback_data == CALLBACK_BACK_MENU:
+                return await self.back_menu_callback(update, context)
+            elif callback_data == "back_analysis" or callback_data == CALLBACK_BACK_ANALYSIS:
+                return await self.analysis_callback(update, context)
+            elif callback_data == "back_signals" or callback_data == CALLBACK_BACK_SIGNALS:
+                return await self.back_signals_callback(update, context)
+            elif callback_data == "back_market" or callback_data == CALLBACK_BACK_MARKET:
+                return await self.back_market_callback(update, context)
+            elif callback_data == "back_instrument" or callback_data == CALLBACK_BACK_INSTRUMENT:
+                logger.info("Explicitly handling back_instrument callback in button_callback")
+                return await self.back_instrument_callback(update, context)
+                
+            # Handle delete signal
+            if callback_data.startswith("delete_signal_"):
+                # Extract signal ID from callback data
+                signal_id = callback_data.replace("delete_signal_", "")
+                
+                try:
+                    # Delete the signal subscription
+                    response = self.db.supabase.table('signal_subscriptions').delete().eq('id', signal_id).execute()
+                    
+                    if response and response.data:
+                        # Successfully deleted
+                        await query.answer("Signal subscription removed successfully")
+                    else:
+                        # Failed to delete
+                        await query.answer("Failed to remove signal subscription")
+                    
+                    # Refresh the manage signals view
+                    return await self.signals_manage_callback(update, context)
+                    
+                except Exception as e:
+                    logger.error(f"Error deleting signal subscription: {str(e)}")
+                    await query.answer("Error removing signal subscription")
+                    return await self.signals_manage_callback(update, context)
+                    
+            # Handle delete all signals
+            if callback_data == "delete_all_signals":
+                user_id = update.effective_user.id
+                
+                try:
+                    # Delete all signal subscriptions for this user
+                    response = self.db.supabase.table('signal_subscriptions').delete().eq('user_id', user_id).execute()
+                    
+                    if response and response.data:
+                        # Successfully deleted
+                        await query.answer("All signal subscriptions removed successfully")
+                    else:
+                        # Failed to delete
+                        await query.answer("Failed to remove signal subscriptions")
+                    
+                    # Refresh the manage signals view
+                    return await self.signals_manage_callback(update, context)
+                    
+                except Exception as e:
+                    logger.error(f"Error deleting all signal subscriptions: {str(e)}")
+                    await query.answer("Error removing signal subscriptions")
+                    return await self.signals_manage_callback(update, context)
+                    
+                    
+            # Default handling if no specific callback found, go back to menu
+            logger.warning(f"Unhandled callback_data: {callback_data}")
+            return MENU
             
-            if calendar_data:
-                return calendar_data
-        else:
-            logger.warning(f"No calendar data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving signal calendar: {str(e)}")
-        logger.exception(e)
-        return None
+        except Exception as e:
+            logger.error(f"Error in button_callback: {str(e)}")
+            logger.exception(e)
+            return MENU
 
-    async def _get_signal_market(self, signal_id):
-        """Retrieve signal market data from the database"""
-    try:
-        # Fetch the signal market data from the database
-            market_data = await self.db.get_signal_market(signal_id)
-            
-            if market_data:
-                return market_data
+    async def market_signals_callback(self, update: Update, context=None) -> int:
+        """Handle signals market selection"""
+        query = update.callback_query
+        await query.answer()
+        
+        # Set the signal context flag
+        if context and hasattr(context, 'user_data'):
+            context.user_data['is_signals_context'] = True
+        
+        # Get the signals GIF URL
+        gif_url = await get_signals_gif()
+        
+        # Update the message with the GIF and keyboard
+        success = await gif_utils.update_message_with_gif(
+            query=query,
+            gif_url=gif_url,
+            text="Select a market for trading signals:",
+            reply_markup=InlineKeyboardMarkup(MARKET_KEYBOARD_SIGNALS)
+        )
+        
+        if not success:
+            # If the helper function failed, try a direct approach as fallback
+            try:
+                # First try to edit message text
+                await query.edit_message_text(
+                    text="Select a market for trading signals:",
+                    parse_mode=ParseMode.HTML,
+                    reply_markup=InlineKeyboardMarkup(MARKET_KEYBOARD_SIGNALS)
+                )
+            except Exception as text_error:
+                # If that fails due to caption, try editing caption
+                if "There is no text in the message to edit" in str(text_error):
+                    try:
+                        await query.edit_message_caption(
+                            caption="Select a market for trading signals:",
+                            parse_mode=ParseMode.HTML,
+                            reply_markup=InlineKeyboardMarkup(MARKET_KEYBOARD_SIGNALS)
+                        )
+                    except Exception as e:
+                        logger.error(f"Failed to update caption in market_signals_callback: {str(e)}")
+                        # Try to send a new message as last resort
+                        await query.message.reply_text(
+                            text="Select a market for trading signals:",
+                            parse_mode=ParseMode.HTML,
+                            reply_markup=InlineKeyboardMarkup(MARKET_KEYBOARD_SIGNALS)
+                        )
+                else:
+                    # Re-raise for other errors
+                    raise
+                    
+        return CHOOSE_MARKET
+        
+    async def market_callback(self, update: Update, context=None) -> int:
+        """Handle market selection and show appropriate instruments"""
+        query = update.callback_query
+        await query.answer()
+        callback_data = query.data
+        
+        # Parse the market from callback data
+        parts = callback_data.split("_")
+        market = parts[1]  # Extract market type (forex, crypto, etc.)
+        
+        # Check if signal-specific context
+        is_signals_context = False
+        if callback_data.endswith("_signals"):
+            is_signals_context = True
+        elif context and hasattr(context, 'user_data'):
+            is_signals_context = context.user_data.get('is_signals_context', False)
+        
+        # Store market in context
+        if context and hasattr(context, 'user_data'):
+            context.user_data['market'] = market
+            context.user_data['is_signals_context'] = is_signals_context
+        
+        logger.info(f"Market callback: market={market}, signals_context={is_signals_context}")
+        
+        # Determine which keyboard to show based on market and context
+        keyboard = None
+        message_text = f"Select a {market.upper()} instrument:"
+        
+        if is_signals_context:
+            # Signal-specific keyboards
+            if market == 'forex':
+                keyboard = FOREX_KEYBOARD_SIGNALS
+            elif market == 'crypto':
+                keyboard = CRYPTO_KEYBOARD_SIGNALS
+            elif market == 'indices':
+                keyboard = INDICES_KEYBOARD_SIGNALS
+            elif market == 'commodities':
+                keyboard = COMMODITIES_KEYBOARD_SIGNALS
+            else:
+                # Default keyboard for unknown market
+                keyboard = [[InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="back_signals")]]
+                message_text = f"Unknown market: {market}"
+        else:
+            # Analysis-specific keyboards
+            analysis_type = context.user_data.get('analysis_type', 'technical') if context and hasattr(context, 'user_data') else 'technical'
+            
+            if analysis_type == 'sentiment':
+                if market == 'forex':
+                    keyboard = FOREX_SENTIMENT_KEYBOARD
+                elif market == 'crypto':
+                    keyboard = CRYPTO_SENTIMENT_KEYBOARD
+                elif market == 'indices':
+                    keyboard = INDICES_SENTIMENT_KEYBOARD
+                elif market == 'commodities':
+                    keyboard = COMMODITIES_SENTIMENT_KEYBOARD
+                else:
+                    keyboard = MARKET_SENTIMENT_KEYBOARD
+                message_text = f"Select instrument for sentiment analysis:"
+            elif analysis_type == 'calendar':
+                if market == 'forex':
+                    keyboard = FOREX_CALENDAR_KEYBOARD
+                else:
+                    keyboard = [[InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="back_analysis")]]
+                message_text = f"Select currency for economic calendar:"
+            else:
+                # Default to technical analysis
+                if market == 'forex':
+                    keyboard = FOREX_KEYBOARD
+                elif market == 'crypto':
+                    keyboard = CRYPTO_KEYBOARD
+                elif market == 'indices':
+                    keyboard = INDICES_KEYBOARD
+                elif market == 'commodities':
+                    keyboard = COMMODITIES_KEYBOARD
+                else:
+                    keyboard = [[InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="back_analysis")]]
+                    message_text = f"Unknown market: {market}"
+                message_text = f"Select instrument for technical analysis:"
+        
+        # Gebruik de keyboard zonder wijzigingen, verwijder de oude back_button logica
+        # De keyboards hebben al back knoppen, we voegen er geen extra meer toe
+        
+        # Show the keyboard
+        try:
+            await self.update_message(
+                query=query,
+                text=message_text,
+                keyboard=InlineKeyboardMarkup(keyboard),
+                parse_mode=ParseMode.HTML
+            )
+        except Exception as e:
+            logger.error(f"Error updating message in market_callback: {str(e)}")
+            # Try to create a new message as fallback
+            try:
+                await query.message.reply_text(
+                    text=message_text,
+                    reply_markup=InlineKeyboardMarkup(keyboard),
+                    parse_mode=ParseMode.HTML
+                )
+            except Exception as e2:
+                logger.error(f"Error sending new message in market_callback: {str(e2)}")
+        
+        return CHOOSE_INSTRUMENT
+        
+    async def back_market_callback(self, update: Update, context=None) -> int:
+        """Handle back_market button press"""
+        query = update.callback_query
+        await query.answer()
+        
+        logger.info("back_market_callback called")
+        
+        # Determine if we need to go back to signals or analysis flow
+        is_signals_context = False
+        if context and hasattr(context, 'user_data'):
+            is_signals_context = context.user_data.get('is_signals_context', False)
+        
+        if is_signals_context:
+            # Go back to signals menu
+            return await self.back_signals_callback(update, context)
         else:
-            logger.warning(f"No market data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving signal market: {str(e)}")
-        logger.exception(e)
-        return None
+            # Go back to analysis selection
+            return await self.analysis_callback(update, context)
 
-    async def _get_signal_trades(self, signal_id):
-        """Retrieve signal trades from the database"""
-    try:
-        # Fetch the signal trades data from the database
-        trades_data = await self.db.get_signal_trades(signal_id)
-            
-        if trades_data:
-            return trades_data
+    async def instrument_signals_callback(self, update: Update, context=None) -> int:
+        """Handle instrument selection for signals"""
+        query = update.callback_query
+        await query.answer()
+        callback_data = query.data
+        
+        # Extract the instrument from the callback data
+        # Format: "instrument_EURUSD_signals"
+        parts = callback_data.split("_")
+        instrument_parts = []
+        
+        # Find where the "signals" specifier starts
+        for i, part in enumerate(parts[1:], 1):  # Skip "instrument_" prefix
+            if part == "signals":
+                break
+            instrument_parts.append(part)
+        
+        # Join the instrument parts
+        instrument = "_".join(instrument_parts) if instrument_parts else ""
+        
+        # Store instrument in context
+        if context and hasattr(context, 'user_data'):
+            context.user_data['instrument'] = instrument
+            context.user_data['is_signals_context'] = True
+        
+        logger.info(f"Instrument signals callback: instrument={instrument}")
+        
+        if not instrument:
+            logger.error("No instrument found in callback data")
+            await query.edit_message_text(
+                text="Invalid instrument selection. Please try again.",
+                reply_markup=InlineKeyboardMarkup(MARKET_KEYBOARD_SIGNALS)
+            )
+            return CHOOSE_MARKET
+        
+        # Get applicable timeframes for this instrument
+        timeframes = []
+        if instrument in INSTRUMENT_TIMEFRAME_MAP:
+            # If the instrument has a predefined timeframe mapping
+            timeframe = INSTRUMENT_TIMEFRAME_MAP[instrument]
+            timeframe_display = TIMEFRAME_DISPLAY_MAP.get(timeframe, timeframe)
+            timeframes = [(timeframe, timeframe_display)]
         else:
-            logger.warning(f"No trades data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving signal trades: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_comments(self, signal_id):
-        """Retrieve signal comments from the database"""
-    try:
-        # Fetch the signal comments data from the database
-            comments_data = await self.db.get_signal_comments(signal_id)
+            # Default timeframes
+            for tf, display in TIMEFRAME_DISPLAY_MAP.items():
+                timeframes.append((tf, display))
+                
+        # Create keyboard for timeframe selection or direct subscription
+        keyboard = []
+        
+        if len(timeframes) == 1:
+            # Only one timeframe, offer direct subscription
+            timeframe, timeframe_display = timeframes[0]
             
-            if comments_data:
-                return comments_data
-        else:
-            logger.warning(f"No comments data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving signal comments: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_attachments(self, signal_id):
-        """Retrieve signal attachments from the database"""
-    try:
-        # Fetch the signal attachments data from the database
-            attachments_data = await self.db.get_signal_attachments(signal_id)
+            # Store in context
+            if context and hasattr(context, 'user_data'):
+                context.user_data['timeframe'] = timeframe
             
-            if attachments_data:
-                return attachments_data
-        else:
-            logger.warning(f"No attachments data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving signal attachments: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_notes(self, signal_id):
-        """Retrieve signal notes from the database"""
-    try:
-        # Fetch the signal notes data from the database
-            notes_data = await self.db.get_signal_notes(signal_id)
+            # Create a subscription for this instrument/timeframe
+            user_id = update.effective_user.id
             
-            if notes_data:
-                return notes_data
-        else:
-            logger.warning(f"No notes data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving signal notes: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_tags(self, signal_id):
-        """Retrieve signal tags from the database"""
-    try:
-        # Fetch the signal tags data from the database
-            tags_data = await self.db.get_signal_tags(signal_id)
+            try:
+                # Check if subscription already exists
+                response = self.db.supabase.table('signal_subscriptions').select('*').eq('user_id', user_id).eq('instrument', instrument).eq('timeframe', timeframe).execute()
+                
+                if response and response.data and len(response.data) > 0:
+                    # Subscription already exists
+                    message = f"‚úÖ You are already subscribed to <b>{instrument}</b> signals on {timeframe_display} timeframe!"
+                else:
+                    # Create new subscription
+                    market = _detect_market(instrument)
+                    
+                    subscription_data = {
+                        'user_id': user_id,
+                        'instrument': instrument,
+                        'timeframe': timeframe,
+                        'market': market,
+                        'created_at': datetime.now().isoformat()
+                    }
+                    
+                    insert_response = self.db.supabase.table('signal_subscriptions').insert(subscription_data).execute()
+                    
+                    if insert_response and insert_response.data:
+                        message = f"‚úÖ Successfully subscribed to <b>{instrument}</b> signals on {timeframe_display} timeframe!"
+                    else:
+                        message = f"‚ùå Error creating subscription for {instrument} on {timeframe_display} timeframe. Please try again."
+            except Exception as e:
+                logger.error(f"Error creating signal subscription: {str(e)}")
+                message = f"‚ùå Error creating subscription: {str(e)}"
+                
+            # Show confirmation and options to add more or manage
+            keyboard = [
+                [InlineKeyboardButton("‚ûï Add More", callback_data="signals_add")],
+                [InlineKeyboardButton("‚öôÔ∏è Manage Signals", callback_data="signals_manage")],
+                [InlineKeyboardButton("‚¨ÖÔ∏è Back to Signals", callback_data="back_signals")]
+            ]
             
-            if tags_data:
-                return tags_data
-        else:
-            logger.warning(f"No tags data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving signal tags: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_signals(self, signal_id):
-        """Retrieve related signals from the database"""
-    try:
-        # Fetch the related signals data from the database
-            related_signals_data = await self.db.get_related_signals(signal_id)
+            # Update message
+            await self.update_message(
+                query=query,
+                text=message,
+                keyboard=InlineKeyboardMarkup(keyboard),
+                parse_mode=ParseMode.HTML
+            )
             
-            if related_signals_data:
-                return related_signals_data
+            return CHOOSE_SIGNALS
         else:
-            logger.warning(f"No related signals data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related signals: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_articles(self, signal_id):
-        """Retrieve related articles from the database"""
-    try:
-        # Fetch the related articles data from the database
-            articles_data = await self.db.get_related_articles(signal_id)
+            # Multiple timeframes, let user select
+            message = f"Select timeframe for <b>{instrument}</b> signals:"
             
-            if articles_data:
-                return articles_data
-        else:
-            logger.warning(f"No related articles data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related articles: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_videos(self, signal_id):
-        """Retrieve related videos from the database"""
-    try:
-        # Fetch the related videos data from the database
-            videos_data = await self.db.get_related_videos(signal_id)
+            for tf, display in timeframes:
+                keyboard.append([InlineKeyboardButton(display, callback_data=f"timeframe_{instrument}_{tf}")])
             
-            if videos_data:
-                return videos_data
-        else:
-            logger.warning(f"No related videos data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related videos: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_trades(self, signal_id):
-    """Retrieve related trades from the database"""
-    try:
-        # Fetch the related trades data from the database
-        trades_data = await self.db.get_related_trades(signal_id)
+            # Add back button
+            keyboard.append([InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="back_signals")])
             
-        if trades_data:
-            return trades_data
-        else:
-            logger.warning(f"No related trades data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related trades: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_comments(self, signal_id):
-        """Retrieve related comments from the database"""
-    try:
-        # Fetch the related comments data from the database
-            comments_data = await self.db.get_related_comments(signal_id)
+            # Update message
+            await self.update_message(
+                query=query,
+                text=message,
+                keyboard=InlineKeyboardMarkup(keyboard),
+                parse_mode=ParseMode.HTML
+            )
             
-            if comments_data:
-                return comments_data
-        else:
-            logger.warning(f"No related comments data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related comments: {str(e)}")
-        logger.exception(e)
-        return None
+            return CHOOSE_TIMEFRAME
 
-    async def _get_signal_related_attachments(self, signal_id):
-        """Retrieve related attachments from the database"""
-    try:
-        # Fetch the related attachments data from the database
-            attachments_data = await self.db.get_related_attachments(signal_id)
+    async def instrument_callback(self, update: Update, context=None) -> int:
+        """Handle instrument selections with specific types (chart, sentiment, calendar)"""
+        query = update.callback_query
+        callback_data = query.data
+        
+        # Parse the callback data to extract the instrument and type
+        parts = callback_data.split("_")
+        # For format like "instrument_EURUSD_sentiment" or "market_forex_sentiment"
+        
+        if callback_data.startswith("instrument_"):
+            # Extract the instrument, handling potential underscores in instrument name
+            instrument_parts = []
+            analysis_type = ""
             
-            if attachments_data:
-                return attachments_data
-        else:
-            logger.warning(f"No related attachments data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related attachments: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_notes(self, signal_id):
-        """Retrieve related notes from the database"""
-    try:
-        # Fetch the related notes data from the database
-            notes_data = await self.db.get_related_notes(signal_id)
+            # Find where the type specifier starts
+            for i, part in enumerate(parts[1:], 1):  # Skip "instrument_" prefix
+                if part in ["chart", "sentiment", "calendar", "signals"]:
+                    analysis_type = part
+                    break
+                instrument_parts.append(part)
             
-            if notes_data:
-                return notes_data
-        else:
-            logger.warning(f"No related notes data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related notes: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_tags(self, signal_id):
-        """Retrieve related tags from the database"""
-    try:
-        # Fetch the related tags data from the database
-            tags_data = await self.db.get_related_tags(signal_id)
+            # Join the instrument parts if we have any
+            instrument = "_".join(instrument_parts) if instrument_parts else ""
             
-            if tags_data:
-                return tags_data
-        else:
-            logger.warning(f"No related tags data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related tags: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_signals(self, signal_id):
-        """Retrieve related signals from the database"""
-    try:
-        # Fetch the related signals data from the database
-            related_signals_data = await self.db.get_related_signals(signal_id)
+            logger.info(f"Instrument callback: instrument={instrument}, type={analysis_type}")
             
-            if related_signals_data:
-                return related_signals_data
-        else:
-            logger.warning(f"No related signals data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related signals: {str(e)}")
-        logger.exception(e)
-        return None
+            # Store in context
+            if context and hasattr(context, 'user_data'):
+                context.user_data['instrument'] = instrument
+                context.user_data['analysis_type'] = analysis_type
+            
+            # Handle the different analysis types
+            if analysis_type == "chart":
+                return await self.show_technical_analysis(update, context, instrument=instrument)
+            elif analysis_type == "sentiment":
+                return await self.show_sentiment_analysis(update, context, instrument=instrument)
+            elif analysis_type == "calendar":
+                return await self.show_calendar_analysis(update, context, instrument=instrument)
+            elif analysis_type == "signals":
+                # This should be handled by instrument_signals_callback
+                return await self.instrument_signals_callback(update, context)
+        
+        elif callback_data.startswith("market_"):
+            # Handle market_*_sentiment callbacks
+            market = parts[1]
+            analysis_type = parts[2] if len(parts) > 2 else ""
+            
+            logger.info(f"Market callback with analysis type: market={market}, type={analysis_type}")
+            
+            # Store in context
+            if context and hasattr(context, 'user_data'):
+                context.user_data['market'] = market
+                context.user_data['analysis_type'] = analysis_type
+            
+            # Determine which keyboard to show based on market and analysis type
+            if analysis_type == "sentiment":
+                if market == "forex":
+                    keyboard = FOREX_SENTIMENT_KEYBOARD
+                elif market == "crypto":
+                    keyboard = CRYPTO_SENTIMENT_KEYBOARD
+                elif market == "indices":
+                    keyboard = INDICES_SENTIMENT_KEYBOARD
+                elif market == "commodities":
+                    keyboard = COMMODITIES_SENTIMENT_KEYBOARD
+                else:
+                    keyboard = MARKET_SENTIMENT_KEYBOARD
+                
+                try:
+                    await query.edit_message_text(
+                        text=f"Select instrument for sentiment analysis:",
+                        reply_markup=InlineKeyboardMarkup(keyboard),
+                        parse_mode=ParseMode.HTML
+                    )
+                except Exception as e:
+                    logger.error(f"Error updating message in instrument_callback: {str(e)}")
+                    try:
+                        await query.edit_message_caption(
+                            caption=f"Select instrument for sentiment analysis:",
+                            reply_markup=InlineKeyboardMarkup(keyboard),
+                            parse_mode=ParseMode.HTML
+                        )
+                    except Exception as e:
+                        logger.error(f"Error updating caption in instrument_callback: {str(e)}")
+                        # Last resort - send a new message
+                        await query.message.reply_text(
+                            text=f"Select instrument for sentiment analysis:",
+                            reply_markup=InlineKeyboardMarkup(keyboard),
+                            parse_mode=ParseMode.HTML
+                        )
+            else:
+                # For other market types, call the market_callback method
+                return await self.market_callback(update, context)
+        
+        return CHOOSE_INSTRUMENT
 
-    async def _get_signal_related_articles(self, signal_id):
-        """Retrieve related articles from the database"""
-    try:
-        # Fetch the related articles data from the database
-            articles_data = await self.db.get_related_articles(signal_id)
-            
-            if articles_data:
-                return articles_data
-        else:
-            logger.warning(f"No related articles data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related articles: {str(e)}")
-        logger.exception(e)
-        return None
+    async def show_technical_analysis(self, update: Update, context=None, instrument=None, timeframe=None) -> int:
+        """Display technical analysis for the given instrument and timeframe."""
+        query = update.callback_query
+        user_id = update.effective_user.id
+        if query: 
+            await query.answer()
 
-    async def _get_signal_related_videos(self, signal_id):
-        """Retrieve related videos from the database"""
-    try:
-        # Fetch the related videos data from the database
-            videos_data = await self.db.get_related_videos(signal_id)
-            
-            if videos_data:
-                return videos_data
-        else:
-            logger.warning(f"No related videos data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related videos: {str(e)}")
-        logger.exception(e)
-        return None
+        is_from_signal_flow = False
+        signal_id_from_context = None
+        current_instrument = instrument
+        current_timeframe = timeframe
+        original_message = None
 
-    async def _get_signal_related_trades(self, signal_id):
-    """Retrieve related trades from the database"""
-    try:
-        # Fetch the related trades data from the database
-        trades_data = await self.db.get_related_trades(signal_id)
-            
-        if trades_data:
-            return trades_data
-        else:
-            logger.warning(f"No related trades data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related trades: {str(e)}")
-        logger.exception(e)
-        return None
+        if context and hasattr(context, 'user_data'):
+            current_instrument = current_instrument or context.user_data.get('instrument')
+            current_timeframe = current_timeframe or context.user_data.get('timeframe')
+            is_from_signal_flow = context.user_data.get('from_signal', False)
+            signal_id_from_context = context.user_data.get('signal_id')
+        
+        logger.info(f"show_technical_analysis: instrument={current_instrument}, timeframe={current_timeframe}, from_signal={is_from_signal_flow}, signal_id={signal_id_from_context}")
+
+        # Define back button logic helper
+        def get_back_button_row_list(): # Returns a list of rows for InlineKeyboardMarkup
+            button_row = []
+            if is_from_signal_flow:
+                # For signal flow, back goes to the "Signal Analysis Options" screen
+                button_row.append(InlineKeyboardButton("‚¨ÖÔ∏è Back to Analysis Options", callback_data="back_to_signal_analysis"))
+            else:
+                # For regular /menu flow, back goes to the "Analysis Menu"
+                button_row.append(InlineKeyboardButton("‚¨ÖÔ∏è Back to Analysis Menu", callback_data="menu_analyse"))
+            return [button_row]
 
-    async def _get_signal_related_comments(self, signal_id):
-        """Retrieve related comments from the database"""
-    try:
-        # Fetch the related comments data from the database
-            comments_data = await self.db.get_related_comments(signal_id)
+        if not current_instrument:
+            logger.warning("Instrument not provided for technical analysis")
+            error_text_no_inst = "Please select an instrument first."
             
-            if comments_data:
-                return comments_data
-        else:
-            logger.warning(f"No related comments data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related comments: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_attachments(self, signal_id):
-        """Retrieve related attachments from the database"""
-    try:
-        # Fetch the related attachments data from the database
-            attachments_data = await self.db.get_related_attachments(signal_id)
+            kb_no_inst_rows = get_back_button_row_list()
+            kb_no_inst = InlineKeyboardMarkup(kb_no_inst_rows)
             
-            if attachments_data:
-                return attachments_data
-        else:
-            logger.warning(f"No related attachments data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related attachments: {str(e)}")
-        logger.exception(e)
-        return None
+            if query: await query.edit_message_text(text=error_text_no_inst, reply_markup=kb_no_inst)
+            else: await update.effective_message.reply_text(text=error_text_no_inst, reply_markup=kb_no_inst)
+            return CHOOSE_MARKET if not is_from_signal_flow else CHOOSE_ANALYSIS
 
-    async def _get_signal_related_notes(self, signal_id):
-        """Retrieve related notes from the database"""
-    try:
-        # Fetch the related notes data from the database
-            notes_data = await self.db.get_related_notes(signal_id)
-            
-            if notes_data:
-                return notes_data
-        else:
-            logger.warning(f"No related notes data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related notes: {str(e)}")
-        logger.exception(e)
-        return None
+        if not current_timeframe:
+            current_timeframe = INSTRUMENT_TIMEFRAME_MAP.get(current_instrument, "1h")
+            if context and hasattr(context, 'user_data'):
+                 context.user_data['timeframe'] = current_timeframe
 
-    async def _get_signal_related_tags(self, signal_id):
-        """Retrieve related tags from the database"""
-    try:
-        # Fetch the related tags data from the database
-            tags_data = await self.db.get_related_tags(signal_id)
-            
-            if tags_data:
-                return tags_data
-        else:
-            logger.warning(f"No related tags data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related tags: {str(e)}")
-        logger.exception(e)
-        return None
+        loading_message_text = f"‚è≥ Generating technical analysis for {current_instrument} ({current_timeframe})..."
+        
+        if query and query.message:
+            try:
+                if query.message.photo or query.message.animation or query.message.document:
+                    await query.edit_message_caption(caption=loading_message_text, parse_mode=ParseMode.HTML)
+                else:
+                    await query.edit_message_text(text=loading_message_text, parse_mode=ParseMode.HTML)
+                original_message = query.message
+            except Exception as e:
+                logger.warning(f"Failed to edit existing message for loading in TA: {e}. Sending new.")
+                try:
+                    original_message = await update.effective_chat.send_message(text=loading_message_text, parse_mode=ParseMode.HTML)
+                except Exception as send_err:
+                    logger.error(f"Failed to send new loading message in TA: {send_err}")
+        elif update.effective_message:
+            try:
+                original_message = await update.effective_message.reply_text(text=loading_message_text, parse_mode=ParseMode.HTML)
+            except Exception as send_err:
+                logger.error(f"Failed to send reply loading message in TA: {send_err}")
 
-    async def _get_signal_related_signals(self, signal_id):
-        """Retrieve related signals from the database"""
-    try:
-        # Fetch the related signals data from the database
-            related_signals_data = await self.db.get_related_signals(signal_id)
-            
-            if related_signals_data:
-                return related_signals_data
-        else:
-            logger.warning(f"No related signals data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related signals: {str(e)}")
-        logger.exception(e)
-        return None
+        try:
+            analysis_data = await self.chart_service.get_technical_analysis(current_instrument, current_timeframe, user_id)
 
-    async def _get_signal_related_articles(self, signal_id):
-        """Retrieve related articles from the database"""
-    try:
-        # Fetch the related articles data from the database
-            articles_data = await self.db.get_related_articles(signal_id)
-            
-            if articles_data:
-                return articles_data
-        else:
-            logger.warning(f"No related articles data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related articles: {str(e)}")
-        logger.exception(e)
-        return None
+            if not analysis_data or 'error' in analysis_data:
+                error_msg = analysis_data.get('error', 'Could not retrieve analysis.') if analysis_data else 'Could not retrieve analysis.'
+                logger.error(f"TA service error for {current_instrument} ({current_timeframe}): {error_msg}")
+                error_text = f"‚ö†Ô∏è Error: {error_msg}"
+                
+                error_keyboard_rows = get_back_button_row_list()
+                error_keyboard = InlineKeyboardMarkup(error_keyboard_rows)
 
-    async def _get_signal_related_videos(self, signal_id):
-        """Retrieve related videos from the database"""
-    try:
-        # Fetch the related videos data from the database
-            videos_data = await self.db.get_related_videos(signal_id)
-            
-            if videos_data:
-                return videos_data
-        else:
-            logger.warning(f"No related videos data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related videos: {str(e)}")
-        logger.exception(e)
-        return None
+                target_message = original_message or (query.message if query else update.effective_message)
+                if target_message:
+                    try:
+                        if target_message.photo or target_message.animation or target_message.document:
+                            await target_message.edit_caption(caption=error_text, reply_markup=error_keyboard, parse_mode=ParseMode.HTML)
+                        else:
+                            await target_message.edit_text(text=error_text, reply_markup=error_keyboard, parse_mode=ParseMode.HTML)
+                    except Exception as edit_err:
+                        logger.warning(f"Failed to edit message with TA service error: {edit_err}. Sending new.")
+                        await update.effective_chat.send_message(text=error_text, reply_markup=error_keyboard, parse_mode=ParseMode.HTML)
+                else:
+                    await update.effective_chat.send_message(text=error_text, reply_markup=error_keyboard, parse_mode=ParseMode.HTML)
+                return MENU
 
-    async def _get_signal_related_trades(self, signal_id):
-    """Retrieve related trades from the database"""
-    try:
-        # Fetch the related trades data from the database
-        trades_data = await self.db.get_related_trades(signal_id)
-            
-        if trades_data:
-            return trades_data
-        else:
-            logger.warning(f"No related trades data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related trades: {str(e)}")
-        logger.exception(e)
-        return None
+            image_path = analysis_data.get("image_path")
+            caption = analysis_data.get("analysis_text", "Technical analysis results.")
+            
+            # Timeframe buttons (only for non-signal flow or if explicitly allowed)
+            timeframe_buttons = []
+            if not is_from_signal_flow: # Only show timeframe options in normal menu flow
+                available_timeframes = ["1m", "15m", "1h", "4h"] # Example
+                timeframe_buttons_row = []
+                for tf in available_timeframes:
+                    if tf != current_timeframe: # Don't show current timeframe as a button
+                        timeframe_buttons_row.append(
+                            InlineKeyboardButton(tf.upper(), callback_data=f"instrument_{current_instrument}_timeframe_{tf}")
+                        )
+                if timeframe_buttons_row:
+                    timeframe_buttons.append(timeframe_buttons_row)
 
-    async def _get_signal_related_comments(self, signal_id):
-        """Retrieve related comments from the database"""
-    try:
-        # Fetch the related comments data from the database
-            comments_data = await self.db.get_related_comments(signal_id)
-            
-            if comments_data:
-                return comments_data
-        else:
-            logger.warning(f"No related comments data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related comments: {str(e)}")
-        logger.exception(e)
-        return None
+            final_keyboard_rows = timeframe_buttons + get_back_button_row_list()
+            final_keyboard = InlineKeyboardMarkup(final_keyboard_rows)
 
-    async def _get_signal_related_attachments(self, signal_id):
-        """Retrieve related attachments from the database"""
-    try:
-        # Fetch the related attachments data from the database
-            attachments_data = await self.db.get_related_attachments(signal_id)
+            if image_path:
+                try:
+                    with open(image_path, 'rb') as photo_file:
+                        # If original_message was a text message, we need to delete it and send a new one with photo
+                        if original_message and not (original_message.photo or original_message.animation or original_message.document):
+                            try:
+                                await original_message.delete()
+                            except Exception as del_err:
+                                logger.warning(f"Could not delete text message to replace with photo: {del_err}")
+                            await update.effective_chat.send_photo(
+                                photo=photo_file,
+                                caption=caption,
+                                reply_markup=final_keyboard,
+                                parse_mode=ParseMode.HTML
+                            )
+                        else: # Edit existing media message or send new if original_message is None
+                            input_media_photo = InputMediaPhoto(media=photo_file, caption=caption, parse_mode=ParseMode.HTML)
+                            if query and query.message: # If it's a callback, try to edit
+                                await query.edit_message_media(media=input_media_photo, reply_markup=final_keyboard)
+                            else: # If it's from a command or edit failed, send new
+                                await update.effective_chat.send_photo(
+                                   photo=InputFile(image_path), caption=caption, reply_markup=final_keyboard, parse_mode=ParseMode.HTML
+                                )
+                except Exception as img_err:
+                    logger.error(f"Error sending TA image for {current_instrument}: {img_err}. Sending text only.")
+                    # Fallback to text if image fails
+                    target_message_text = original_message or (query.message if query else update.effective_message)
+                    if target_message_text:
+                        await target_message_text.edit_text(text=caption, reply_markup=final_keyboard, parse_mode=ParseMode.HTML)
+                    else:
+                        await update.effective_chat.send_message(text=caption, reply_markup=final_keyboard, parse_mode=ParseMode.HTML)
+
+                finally:
+                    if os.path.exists(image_path):
+                        os.remove(image_path) # Clean up the image file
+            else: # No image path, just send/edit text
+                target_message_text_only = original_message or (query.message if query else update.effective_message)
+                if target_message_text_only:
+                    if target_message_text_only.photo or target_message_text_only.animation or target_message_text_only.document:
+                         await target_message_text_only.edit_caption(caption=caption, reply_markup=final_keyboard, parse_mode=ParseMode.HTML)
+                    else:
+                         await target_message_text_only.edit_text(text=caption, reply_markup=final_keyboard, parse_mode=ParseMode.HTML)
+                else:
+                     await update.effective_chat.send_message(text=caption, reply_markup=final_keyboard, parse_mode=ParseMode.HTML)
             
-            if attachments_data:
-                return attachments_data
-        else:
-            logger.warning(f"No related attachments data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related attachments: {str(e)}")
-        logger.exception(e)
-        return None
+            return SHOW_RESULT
 
-    async def _get_signal_related_notes(self, signal_id):
-        """Retrieve related notes from the database"""
-    try:
-        # Fetch the related notes data from the database
-            notes_data = await self.db.get_related_notes(signal_id)
+        except Exception as e:
+            logger.error(f"Outer error in show_technical_analysis for {current_instrument} ({current_timeframe}): {e}")
+            logger.exception(e)
+            error_text = f"An unexpected error occurred. Please try again later."
             
-            if notes_data:
-                return notes_data
-        else:
-            logger.warning(f"No related notes data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related notes: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_tags(self, signal_id):
-        """Retrieve related tags from the database"""
-    try:
-        # Fetch the related tags data from the database
-            tags_data = await self.db.get_related_tags(signal_id)
+            error_keyboard_rows = get_back_button_row_list()
+            error_keyboard = InlineKeyboardMarkup(error_keyboard_rows)
             
-            if tags_data:
-                return tags_data
-        else:
-            logger.warning(f"No related tags data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related tags: {str(e)}")
-        logger.exception(e)
-        return None
+            target_message_exception = original_message or (query.message if query else update.effective_message)
+            if target_message_exception:
+                try:
+                    if target_message_exception.photo or target_message_exception.animation or target_message_exception.document:
+                        await target_message_exception.edit_caption(caption=error_text, reply_markup=error_keyboard, parse_mode=ParseMode.HTML)
+                    else:
+                        await target_message_exception.edit_text(text=error_text, reply_markup=error_keyboard, parse_mode=ParseMode.HTML)
+                except Exception as edit_error:
+                    logger.warning(f"Failed to edit message with outer TA error: {edit_error}. Sending new.")
+                    await update.effective_chat.send_message(text=error_text, reply_markup=error_keyboard, parse_mode=ParseMode.HTML)
+            else:
+                await update.effective_chat.send_message(text=error_text, reply_markup=error_keyboard, parse_mode=ParseMode.HTML)
+            return MENU
 
-    async def _get_signal_related_signals(self, signal_id):
-        """Retrieve related signals from the database"""
-    try:
-        # Fetch the related signals data from the database
-            related_signals_data = await self.db.get_related_signals(signal_id)
+    async def back_to_signal_analysis_callback(self, update: Update, context=None) -> int:
+        """Handle back_to_signal_analysis button press"""
+        query = update.callback_query
+        await query.answer()
+        
+        # Add detailed logging for debugging
+        logger.info("back_to_signal_analysis_callback called")
+        logger.info(f"Query data: {query.data}")
+        if context and hasattr(context, 'user_data'):
+            logger.info(f"Context user_data: {context.user_data}")
+        
+        try:
+            # Get instrument from context
+            instrument = None
+            if context and hasattr(context, 'user_data'):
+                instrument = context.user_data.get('instrument')
             
-            if related_signals_data:
-                return related_signals_data
-        else:
-            logger.warning(f"No related signals data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related signals: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_articles(self, signal_id):
-        """Retrieve related articles from the database"""
-    try:
-        # Fetch the related articles data from the database
-            articles_data = await self.db.get_related_articles(signal_id)
+            # Check if message has photo or animation
+            has_photo = bool(query.message.photo) or query.message.animation is not None
             
-            if articles_data:
-                return articles_data
-        else:
-            logger.warning(f"No related articles data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related articles: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_videos(self, signal_id):
-        """Retrieve related videos from the database"""
-    try:
-        # Fetch the related videos data from the database
-            videos_data = await self.db.get_related_videos(signal_id)
+            # Use the standard SIGNAL_ANALYSIS_KEYBOARD
+            keyboard = SIGNAL_ANALYSIS_KEYBOARD
             
-            if videos_data:
-                return videos_data
-        else:
-            logger.warning(f"No related videos data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related videos: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_trades(self, signal_id):
-    """Retrieve related trades from the database"""
-    try:
-        # Fetch the related trades data from the database
-        trades_data = await self.db.get_related_trades(signal_id)
+            # Format the message text
+            text = f"Select your analysis type:"
             
-        if trades_data:
-            return trades_data
-        else:
-            logger.warning(f"No related trades data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related trades: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_comments(self, signal_id):
-        """Retrieve related comments from the database"""
-    try:
-        # Fetch the related comments data from the database
-            comments_data = await self.db.get_related_comments(signal_id)
+            if has_photo:
+                # Try to delete the message first (if possible)
+                try:
+                    await query.message.delete()
+                    await context.bot.send_message(
+                        chat_id=update.effective_chat.id,
+                        text=text,
+                        reply_markup=InlineKeyboardMarkup(keyboard),
+                        parse_mode=ParseMode.HTML
+                    )
+                    return SIGNAL_DETAILS
+                except Exception as delete_error:
+                    logger.error(f"Could not delete message: {str(delete_error)}")
+                    
+                    # Try to replace the photo with a transparent GIF
+                    try:
+                        transparent_gif_url = "https://upload.wikimedia.org/wikipedia/commons/c/ca/1x1.png"
+                        await query.message.edit_media(
+                            media=InputMediaAnimation(
+                                media=transparent_gif_url,
+                                caption=text
+                            ),
+                            reply_markup=InlineKeyboardMarkup(keyboard)
+                        )
+                        return SIGNAL_DETAILS
+                    except Exception as e:
+                        logger.error(f"Could not replace photo: {str(e)}")
+                        
+                        # Final fallback - try to edit the caption
+                        try:
+                            await query.message.edit_caption(
+                                caption=text,
+                                reply_markup=InlineKeyboardMarkup(keyboard),
+                                parse_mode=ParseMode.HTML
+                            )
+                        except Exception as caption_error:
+                            logger.error(f"Could not edit caption: {str(caption_error)}")
+                            # Just log the error, will try to edit the message text next
+            else:
+                # No photo, just edit the message text
+                try:
+                    await query.edit_message_text(
+                        text=text,
+                        reply_markup=InlineKeyboardMarkup(keyboard),
+                        parse_mode=ParseMode.HTML
+                    )
+                except Exception as e:
+                    logger.error(f"Error updating message: {str(e)}")
             
-            if comments_data:
-                return comments_data
-        else:
-            logger.warning(f"No related comments data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related comments: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_attachments(self, signal_id):
-        """Retrieve related attachments from the database"""
-    try:
-        # Fetch the related attachments data from the database
-            attachments_data = await self.db.get_related_attachments(signal_id)
+            return SIGNAL_DETAILS
             
-            if attachments_data:
-                return attachments_data
-        else:
-            logger.warning(f"No related attachments data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related attachments: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_notes(self, signal_id):
-        """Retrieve related notes from the database"""
-    try:
-        # Fetch the related notes data from the database
-            notes_data = await self.db.get_related_notes(signal_id)
+        except Exception as e:
+            logger.error(f"Error in back_to_signal_analysis_callback: {str(e)}")
+            
+            # Error recovery - return to signal menu
+            try:
+                await query.edit_message_text(
+                    text="An error occurred. Please try again from the signals menu.",
+                    reply_markup=InlineKeyboardMarkup(SIGNALS_KEYBOARD)
+                )
+            except Exception:
+                pass
             
-            if notes_data:
-                return notes_data
-        else:
-            logger.warning(f"No related notes data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related notes: {str(e)}")
-        logger.exception(e)
-        return None
+            return CHOOSE_SIGNALS
 
-    async def _get_signal_related_tags(self, signal_id):
-        """Retrieve related tags from the database"""
-    try:
-        # Fetch the related tags data from the database
-            tags_data = await self.db.get_related_tags(signal_id)
-            
-            if tags_data:
-                return tags_data
-        else:
-            logger.warning(f"No related tags data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related tags: {str(e)}")
-        logger.exception(e)
-        return None
+    async def handle_subscription_callback(self, update: Update, context=None) -> int:
+        """Handle subscription button press"""
+        query = update.callback_query
+        await query.answer()
+        
+        # Check if we have Stripe service configured
+        if not self.stripe_service:
+            logger.error("Stripe service not configured")
+            await query.edit_message_text(
+                text="Sorry, subscription service is not available right now. Please try again later.",
+                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="back_menu")]])
+            )
+            return MENU
+        
+        # Get the subscription URL
+        subscription_url = "https://buy.stripe.com/3cs3eF9Hu9256NW9AA"  # 14-day free trial URL
+        features = get_subscription_features()
+        
+        # Format the subscription message
+        message = f"""
+üöÄ <b>Welcome to Sigmapips AI!</b> üöÄ
 
-    async def _get_signal_related_signals(self, signal_id):
-        """Retrieve related signals from the database"""
-    try:
-        # Fetch the related signals data from the database
-            related_signals_data = await self.db.get_related_signals(signal_id)
-            
-            if related_signals_data:
-                return related_signals_data
-        else:
-            logger.warning(f"No related signals data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related signals: {str(e)}")
-        logger.exception(e)
-        return None
+<b>Discover powerful trading signals for various markets:</b>
+‚Ä¢ <b>Forex</b> - Major and minor currency pairs
+‚Ä¢ <b>Crypto</b> - Bitcoin, Ethereum and other top cryptocurrencies
+‚Ä¢ <b>Indices</b> - Global market indices
+‚Ä¢ <b>Commodities</b> - Gold, silver and oil
 
-    async def _get_signal_related_articles(self, signal_id):
-        """Retrieve related articles from the database"""
-    try:
-        # Fetch the related articles data from the database
-            articles_data = await self.db.get_related_articles(signal_id)
-            
-            if articles_data:
-                return articles_data
-        else:
-            logger.warning(f"No related articles data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related articles: {str(e)}")
-        logger.exception(e)
-        return None
+<b>Features:</b>
+‚úÖ Real-time trading signals
+‚úÖ Multi-timeframe analysis (1m, 15m, 1h, 4h)
+‚úÖ Advanced chart analysis
+‚úÖ Sentiment indicators
+‚úÖ Economic calendar integration
 
-    async def _get_signal_related_videos(self, signal_id):
-        """Retrieve related videos from the database"""
-    try:
-        # Fetch the related videos data from the database
-            videos_data = await self.db.get_related_videos(signal_id)
+<b>Start today with a FREE 14-day trial!</b>
+"""
+        
+        # Create keyboard with subscription button
+        keyboard = [
+            [InlineKeyboardButton("üî• Start 14-day FREE Trial", url=subscription_url)],
+            [InlineKeyboardButton("‚¨ÖÔ∏è Back to Menu", callback_data="back_menu")]
+        ]
+        
+        # Update message with subscription information
+        try:
+            # Get a welcome GIF URL
+            gif_url = await get_welcome_gif()
             
-            if videos_data:
-                return videos_data
-        else:
-            logger.warning(f"No related videos data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related videos: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_trades(self, signal_id):
-    """Retrieve related trades from the database"""
-    try:
-        # Fetch the related trades data from the database
-        trades_data = await self.db.get_related_trades(signal_id)
+            # Update the message with the GIF using the helper function
+            success = await gif_utils.update_message_with_gif(
+                query=query,
+                gif_url=gif_url,
+                text=message,
+                reply_markup=InlineKeyboardMarkup(keyboard)
+            )
             
-        if trades_data:
-            return trades_data
-        else:
-            logger.warning(f"No related trades data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related trades: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_comments(self, signal_id):
-        """Retrieve related comments from the database"""
-    try:
-        # Fetch the related comments data from the database
-            comments_data = await self.db.get_related_comments(signal_id)
+            if not success:
+                # If the helper function failed, try a direct approach as fallback
+                try:
+                    await query.edit_message_text(
+                        text=message,
+                        reply_markup=InlineKeyboardMarkup(keyboard),
+                        parse_mode=ParseMode.HTML
+                    )
+                except Exception as text_error:
+                    # If that fails due to caption, try editing caption
+                    if "There is no text in the message to edit" in str(text_error):
+                        await query.edit_message_caption(
+                            caption=message,
+                            reply_markup=InlineKeyboardMarkup(keyboard),
+                            parse_mode=ParseMode.HTML
+                        )
+        except Exception as e:
+            logger.error(f"Error updating message with subscription info: {str(e)}")
+            # Try to send a new message as fallback
+            await query.message.reply_text(
+                text=message,
+                reply_markup=InlineKeyboardMarkup(keyboard),
+                parse_mode=ParseMode.HTML
+            )
+        
+        return SUBSCRIBE
+        
+    async def get_subscribers_for_instrument(self, instrument: str, timeframe: str = None) -> List[int]:
+        """
+        Get a list of subscribed user IDs for a specific instrument and timeframe
+        
+        Args:
+            instrument: The trading instrument (e.g., EURUSD)
+            timeframe: Optional timeframe filter
             
-            if comments_data:
-                return comments_data
-        else:
-            logger.warning(f"No related comments data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related comments: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_attachments(self, signal_id):
-        """Retrieve related attachments from the database"""
-    try:
-        # Fetch the related attachments data from the database
-            attachments_data = await self.db.get_related_attachments(signal_id)
+        Returns:
+            List of subscribed user IDs
+        """
+        try:
+            logger.info(f"Getting subscribers for {instrument} timeframe: {timeframe}")
             
-            if attachments_data:
-                return attachments_data
-        else:
-            logger.warning(f"No related attachments data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related attachments: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_notes(self, signal_id):
-        """Retrieve related notes from the database"""
-    try:
-        # Fetch the related notes data from the database
-            notes_data = await self.db.get_related_notes(signal_id)
+            # Get all subscribers from the database
+            # Note: Using get_signal_subscriptions instead of find_all
+            subscribers = await self.db.get_signal_subscriptions(instrument, timeframe)
             
-            if notes_data:
-                return notes_data
-        else:
-            logger.warning(f"No related notes data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related notes: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_tags(self, signal_id):
-        """Retrieve related tags from the database"""
-    try:
-        # Fetch the related tags data from the database
-            tags_data = await self.db.get_related_tags(signal_id)
+            if not subscribers:
+                logger.warning(f"No subscribers found for {instrument}")
+                return []
+                
+            # Filter out subscribers that don't have an active subscription
+            active_subscribers = []
+            for subscriber in subscribers:
+                user_id = subscriber['user_id']
+                
+                # Check if user is subscribed
+                is_subscribed = await self.db.is_user_subscribed(user_id)
+                
+                # Check if payment has failed
+                payment_failed = await self.db.has_payment_failed(user_id)
+                
+                if is_subscribed and not payment_failed:
+                    active_subscribers.append(user_id)
+                else:
+                    logger.info(f"User {user_id} doesn't have an active subscription, skipping signal")
             
-            if tags_data:
-                return tags_data
-        else:
-            logger.warning(f"No related tags data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related tags: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_signals(self, signal_id):
-        """Retrieve related signals from the database"""
-    try:
-        # Fetch the related signals data from the database
-            related_signals_data = await self.db.get_related_signals(signal_id)
+            return active_subscribers
             
-            if related_signals_data:
-                return related_signals_data
-        else:
-            logger.warning(f"No related signals data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related signals: {str(e)}")
-        logger.exception(e)
-        return None
+        except Exception as e:
+            logger.error(f"Error getting subscribers: {str(e)}")
+            # FOR TESTING: Add admin users if available
+            if hasattr(self, 'admin_users') and self.admin_users:
+                logger.info(f"Returning admin users for testing: {self.admin_users}")
+                return self.admin_users
+            return []
 
-    async def _get_signal_related_articles(self, signal_id):
-        """Retrieve related articles from the database"""
-    try:
-        # Fetch the related articles data from the database
-            articles_data = await self.db.get_related_articles(signal_id)
+    async def process_signal(self, signal_data: Dict[str, Any]) -> bool:
+        """
+        Process a trading signal from TradingView webhook or API
+        
+        Supports two formats:
+        1. TradingView format: instrument, signal, price, sl, tp1, tp2, tp3, interval
+        2. Custom format: instrument, direction, entry, stop_loss, take_profit, timeframe
+        
+        Returns:
+            bool: True if signal was processed successfully, False otherwise
+        """
+        try:
+            # Log the incoming signal data
+            logger.info(f"Processing signal: {signal_data}")
             
-            if articles_data:
-                return articles_data
-        else:
-            logger.warning(f"No related articles data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related articles: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_videos(self, signal_id):
-        """Retrieve related videos from the database"""
-    try:
-        # Fetch the related videos data from the database
-            videos_data = await self.db.get_related_videos(signal_id)
+            # Check which format we're dealing with and normalize it
+            instrument = signal_data.get('instrument')
             
-            if videos_data:
-                return videos_data
-        else:
-            logger.warning(f"No related videos data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related videos: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_trades(self, signal_id):
-    """Retrieve related trades from the database"""
-    try:
-        # Fetch the related trades data from the database
-        trades_data = await self.db.get_related_trades(signal_id)
+            # Handle TradingView format (price, sl, interval)
+            if 'price' in signal_data and 'sl' in signal_data:
+                price = signal_data.get('price')
+                sl = signal_data.get('sl')
+                tp1 = signal_data.get('tp1')
+                tp2 = signal_data.get('tp2')
+                tp3 = signal_data.get('tp3')
+                interval = signal_data.get('interval', '1h')
+                
+                # Determine signal direction based on price and SL relationship
+                direction = "BUY" if float(sl) < float(price) else "SELL"
+                
+                # Create normalized signal data
+                normalized_data = {
+                    'instrument': instrument,
+                    'direction': direction,
+                    'entry': price,
+                    'stop_loss': sl,
+                    'take_profit': tp1,  # Use first take profit level
+                    'timeframe': interval
+                }
+                
+                # Add optional fields if present
+                normalized_data['tp1'] = tp1
+                normalized_data['tp2'] = tp2
+                normalized_data['tp3'] = tp3
             
-        if trades_data:
-            return trades_data
-        else:
-            logger.warning(f"No related trades data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related trades: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_comments(self, signal_id):
-        """Retrieve related comments from the database"""
-    try:
-        # Fetch the related comments data from the database
-            comments_data = await self.db.get_related_comments(signal_id)
+            # Handle custom format (direction, entry, stop_loss, timeframe)
+            elif 'direction' in signal_data and 'entry' in signal_data:
+                direction = signal_data.get('direction')
+                entry = signal_data.get('entry')
+                stop_loss = signal_data.get('stop_loss')
+                take_profit = signal_data.get('take_profit')
+                timeframe = signal_data.get('timeframe', '1h')
+                
+                # Create normalized signal data
+                normalized_data = {
+                    'instrument': instrument,
+                    'direction': direction,
+                    'entry': entry,
+                    'stop_loss': stop_loss,
+                    'take_profit': take_profit,
+                    'timeframe': timeframe
+                }
+            else:
+                logger.error(f"Missing required signal data")
+                return False
             
-            if comments_data:
-                return comments_data
-        else:
-            logger.warning(f"No related comments data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related comments: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_attachments(self, signal_id):
-        """Retrieve related attachments from the database"""
-    try:
-        # Fetch the related attachments data from the database
-            attachments_data = await self.db.get_related_attachments(signal_id)
+            # Basic validation
+            if not normalized_data.get('instrument') or not normalized_data.get('direction') or not normalized_data.get('entry'):
+                logger.error(f"Missing required fields in normalized signal data: {normalized_data}")
+                return False
+                
+            # Create signal ID for tracking
+            signal_id = f"{normalized_data['instrument']}_{normalized_data['direction']}_{normalized_data['timeframe']}_{int(time.time())}"
             
-            if attachments_data:
-                return attachments_data
-        else:
-            logger.warning(f"No related attachments data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related attachments: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_notes(self, signal_id):
-        """Retrieve related notes from the database"""
-    try:
-        # Fetch the related notes data from the database
-            notes_data = await self.db.get_related_notes(signal_id)
+            # Format the signal message
+            message = self._format_signal_message(normalized_data)
             
-            if notes_data:
-                return notes_data
-        else:
-            logger.warning(f"No related notes data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related notes: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_tags(self, signal_id):
-        """Retrieve related tags from the database"""
-    try:
-        # Fetch the related tags data from the database
-            tags_data = await self.db.get_related_tags(signal_id)
+            # Determine market type for the instrument
+            market_type = _detect_market(instrument)
             
-            if tags_data:
-                return tags_data
-        else:
-            logger.warning(f"No related tags data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related tags: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_signals(self, signal_id):
-        """Retrieve related signals from the database"""
-    try:
-        # Fetch the related signals data from the database
-            related_signals_data = await self.db.get_related_signals(signal_id)
+            # Store the full signal data for reference
+            normalized_data['id'] = signal_id
+            normalized_data['timestamp'] = datetime.now().isoformat()
+            normalized_data['message'] = message
+            normalized_data['market'] = market_type
+            
+            # Save signal for history tracking
+            if not os.path.exists(self.signals_dir):
+                os.makedirs(self.signals_dir, exist_ok=True)
+                
+            # Save to signals directory
+            with open(f"{self.signals_dir}/{signal_id}.json", 'w') as f:
+                json.dump(normalized_data, f)
+            
+            # FOR TESTING: Always send to admin for testing
+            if hasattr(self, 'admin_users') and self.admin_users:
+                try:
+                    logger.info(f"Sending signal to admin users for testing: {self.admin_users}")
+                    for admin_id in self.admin_users:
+                        # Prepare keyboard with analysis options
+                        keyboard = [
+                            [InlineKeyboardButton("üîç Analyze Market", callback_data=f"analyze_from_signal_{instrument}_{signal_id}")]
+                        ]
+                        
+                        # Send the signal
+                        await self.bot.send_message(
+                            chat_id=admin_id,
+                            text=message,
+                            parse_mode=ParseMode.HTML,
+                            reply_markup=InlineKeyboardMarkup(keyboard)
+                        )
+                        logger.info(f"Test signal sent to admin {admin_id}")
+                        
+                        # Store signal reference for quick access
+                        if not hasattr(self, 'user_signals'):
+                            self.user_signals = {}
+                            
+                        admin_str_id = str(admin_id)
+                        if admin_str_id not in self.user_signals:
+                            self.user_signals[admin_str_id] = {}
+                        
+                        self.user_signals[admin_str_id][signal_id] = normalized_data
+                except Exception as e:
+                    logger.error(f"Error sending test signal to admin: {str(e)}")
             
-            if related_signals_data:
-                return related_signals_data
-        else:
-            logger.warning(f"No related signals data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related signals: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_articles(self, signal_id):
-        """Retrieve related articles from the database"""
-    try:
-        # Fetch the related articles data from the database
-            articles_data = await self.db.get_related_articles(signal_id)
+            # Get subscribers for this instrument
+            timeframe = normalized_data.get('timeframe', '1h')
+            subscribers = await self.get_subscribers_for_instrument(instrument, timeframe)
             
-            if articles_data:
-                return articles_data
-        else:
-            logger.warning(f"No related articles data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related articles: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_videos(self, signal_id):
-        """Retrieve related videos from the database"""
-    try:
-        # Fetch the related videos data from the database
-            videos_data = await self.db.get_related_videos(signal_id)
+            if not subscribers:
+                logger.warning(f"No subscribers found for {instrument}")
+                return True  # Successfully processed, just no subscribers
             
-            if videos_data:
-                return videos_data
-        else:
-            logger.warning(f"No related videos data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related videos: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_trades(self, signal_id):
-    """Retrieve related trades from the database"""
-    try:
-        # Fetch the related trades data from the database
-        trades_data = await self.db.get_related_trades(signal_id)
+            # Send signal to all subscribers
+            logger.info(f"Sending signal {signal_id} to {len(subscribers)} subscribers")
             
-        if trades_data:
-            return trades_data
-        else:
-            logger.warning(f"No related trades data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related trades: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_comments(self, signal_id):
-        """Retrieve related comments from the database"""
-    try:
-        # Fetch the related comments data from the database
-            comments_data = await self.db.get_related_comments(signal_id)
+            sent_count = 0
+            for user_id in subscribers:
+                try:
+                    # Prepare keyboard with analysis options
+                    keyboard = [
+                        [InlineKeyboardButton("üîç Analyze Market", callback_data=f"analyze_from_signal_{instrument}_{signal_id}")]
+                    ]
+                    
+                    # Send the signal
+                    await self.bot.send_message(
+                        chat_id=user_id,
+                        text=message,
+                        parse_mode=ParseMode.HTML,
+                        reply_markup=InlineKeyboardMarkup(keyboard)
+                    )
+                    
+                    sent_count += 1
+                    
+                    # Store signal reference for quick access
+                    if not hasattr(self, 'user_signals'):
+                        self.user_signals = {}
+                        
+                    user_str_id = str(user_id)
+                    if user_str_id not in self.user_signals:
+                        self.user_signals[user_str_id] = {}
+                    
+                    self.user_signals[user_str_id][signal_id] = normalized_data
+                    
+                except Exception as e:
+                    logger.error(f"Error sending signal to user {user_id}: {str(e)}")
             
-            if comments_data:
-                return comments_data
-        else:
-            logger.warning(f"No related comments data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related comments: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_attachments(self, signal_id):
-        """Retrieve related attachments from the database"""
-    try:
-        # Fetch the related attachments data from the database
-            attachments_data = await self.db.get_related_attachments(signal_id)
+            logger.info(f"Successfully sent signal {signal_id} to {sent_count}/{len(subscribers)} subscribers")
+            return True
             
-            if attachments_data:
-                return attachments_data
-        else:
-            logger.warning(f"No related attachments data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related attachments: {str(e)}")
-        logger.exception(e)
-        return None
+        except Exception as e:
+            logger.error(f"Error processing signal: {str(e)}")
+            logger.exception(e)
+            return False
 
-    async def _get_signal_related_notes(self, signal_id):
-        """Retrieve related notes from the database"""
-    try:
-        # Fetch the related notes data from the database
-            notes_data = await self.db.get_related_notes(signal_id)
+    def _format_signal_message(self, signal_data: Dict[str, Any]) -> str:
+        """Format signal data into a nice message for Telegram"""
+        try:
+            # Extract fields from signal data
+            instrument = signal_data.get('instrument', 'Unknown')
+            direction = signal_data.get('direction', 'Unknown')
+            entry = signal_data.get('entry', 'Unknown')
+            stop_loss = signal_data.get('stop_loss')
+            take_profit = signal_data.get('take_profit')
+            timeframe = signal_data.get('timeframe', '1h')
             
-            if notes_data:
-                return notes_data
-        else:
-            logger.warning(f"No related notes data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related notes: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_tags(self, signal_id):
-        """Retrieve related tags from the database"""
-    try:
-        # Fetch the related tags data from the database
-            tags_data = await self.db.get_related_tags(signal_id)
+            # Get multiple take profit levels if available
+            tp1 = signal_data.get('tp1', take_profit)
+            tp2 = signal_data.get('tp2')
+            tp3 = signal_data.get('tp3')
             
-            if tags_data:
-                return tags_data
-        else:
-            logger.warning(f"No related tags data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related tags: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_signals(self, signal_id):
-        """Retrieve related signals from the database"""
-    try:
-        # Fetch the related signals data from the database
-            related_signals_data = await self.db.get_related_signals(signal_id)
+            # Add emoji based on direction
+            direction_emoji = "üü¢" if direction.upper() == "BUY" else "üî¥"
             
-            if related_signals_data:
-                return related_signals_data
-        else:
-            logger.warning(f"No related signals data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related signals: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_articles(self, signal_id):
-        """Retrieve related articles from the database"""
-    try:
-        # Fetch the related articles data from the database
-            articles_data = await self.db.get_related_articles(signal_id)
+            # Format the message with multiple take profits if available
+            message = f"<b>üéØ New Trading Signal üéØ</b>\n\n"
+            message += f"<b>Instrument:</b> {instrument}\n"
+            message += f"<b>Action:</b> {direction.upper()} {direction_emoji}\n\n"
+            message += f"<b>Entry Price:</b> {entry}\n"
             
-            if articles_data:
-                return articles_data
-        else:
-            logger.warning(f"No related articles data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related articles: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_videos(self, signal_id):
-        """Retrieve related videos from the database"""
-    try:
-        # Fetch the related videos data from the database
-            videos_data = await self.db.get_related_videos(signal_id)
+            if stop_loss:
+                message += f"<b>Stop Loss:</b> {stop_loss} üî¥\n"
             
-            if videos_data:
-                return videos_data
-        else:
-            logger.warning(f"No related videos data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related videos: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_trades(self, signal_id):
-    """Retrieve related trades from the database"""
-    try:
-        # Fetch the related trades data from the database
-        trades_data = await self.db.get_related_trades(signal_id)
+            # Add take profit levels
+            if tp1:
+                message += f"<b>Take Profit 1:</b> {tp1} üéØ\n"
+            if tp2:
+                message += f"<b>Take Profit 2:</b> {tp2} üéØ\n"
+            if tp3:
+                message += f"<b>Take Profit 3:</b> {tp3} üéØ\n"
             
-        if trades_data:
-            return trades_data
-        else:
-            logger.warning(f"No related trades data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related trades: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_comments(self, signal_id):
-        """Retrieve related comments from the database"""
-    try:
-        # Fetch the related comments data from the database
-            comments_data = await self.db.get_related_comments(signal_id)
+            message += f"\n<b>Timeframe:</b> {timeframe}\n"
+            message += f"<b>Strategy:</b> TradingView Signal\n\n"
             
-            if comments_data:
-                return comments_data
-        else:
-            logger.warning(f"No related comments data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related comments: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_attachments(self, signal_id):
-        """Retrieve related attachments from the database"""
-    try:
-        # Fetch the related attachments data from the database
-            attachments_data = await self.db.get_related_attachments(signal_id)
+            message += "‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî\n\n"
+            message += "<b>Risk Management:</b>\n"
+            message += "‚Ä¢ Position size: 1-2% max\n"
+            message += "‚Ä¢ Use proper stop loss\n"
+            message += "‚Ä¢ Follow your trading plan\n\n"
             
-            if attachments_data:
-                return attachments_data
-        else:
-            logger.warning(f"No related attachments data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related attachments: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_notes(self, signal_id):
-        """Retrieve related notes from the database"""
-    try:
-        # Fetch the related notes data from the database
-            notes_data = await self.db.get_related_notes(signal_id)
+            message += "‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî\n\n"
             
-            if notes_data:
-                return notes_data
-        else:
-            logger.warning(f"No related notes data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related notes: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_tags(self, signal_id):
-        """Retrieve related tags from the database"""
-    try:
-        # Fetch the related tags data from the database
-            tags_data = await self.db.get_related_tags(signal_id)
+            # Generate AI verdict
+            ai_verdict = f"The {instrument} {direction.lower()} signal shows a promising setup with defined entry at {entry} and stop loss at {stop_loss}. Multiple take profit levels provide opportunities for partial profit taking."
+            message += f"<b>ü§ñ SigmaPips AI Verdict:</b>\n{ai_verdict}"
             
-            if tags_data:
-                return tags_data
-        else:
-            logger.warning(f"No related tags data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related tags: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_signals(self, signal_id):
-        """Retrieve related signals from the database"""
-    try:
-        # Fetch the related signals data from the database
-            related_signals_data = await self.db.get_related_signals(signal_id)
+            return message
             
-            if related_signals_data:
-                return related_signals_data
-        else:
-            logger.warning(f"No related signals data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related signals: {str(e)}")
-        logger.exception(e)
-        return None
+        except Exception as e:
+            logger.error(f"Error formatting signal message: {str(e)}")
+            # Return simple message on error
+            return f"New {signal_data.get('instrument', 'Unknown')} {signal_data.get('direction', 'Unknown')} Signal"
 
-    async def _get_signal_related_articles(self, signal_id):
-        """Retrieve related articles from the database"""
-    try:
-        # Fetch the related articles data from the database
-            articles_data = await self.db.get_related_articles(signal_id)
+    async def _load_signals(self):
+        """Load stored signals from the database"""
+        try:
+            self.logger.info("Loading stored signals")
             
-            if articles_data:
-                return articles_data
-        else:
-            logger.warning(f"No related articles data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related articles: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_videos(self, signal_id):
-        """Retrieve related videos from the database"""
-    try:
-        # Fetch the related videos data from the database
-            videos_data = await self.db.get_related_videos(signal_id)
+            try:
+                # Check if the get_active_signals method exists on the database object
+                if hasattr(self.db, 'get_active_signals'):
+                    signals = await self.db.get_active_signals()
+                    self.logger.info(f"Found {len(signals)} active signals")
+                    
+                    # Process each signal
+                    for signal in signals:
+                        # Check necessary fields
+                        if 'user_id' in signal and 'market' in signal and 'instrument' in signal:
+                            user_id = signal['user_id']
+                            market = signal['market']
+                            instrument = signal['instrument']
+                            
+                            # Add to user_signals dictionary
+                            if user_id not in self.user_signals:
+                                self.user_signals[user_id] = {}
+                            if market not in self.user_signals[user_id]:
+                                self.user_signals[user_id][market] = []
+                            
+                            # Add instrument if not already in list
+                            if instrument not in self.user_signals[user_id][market]:
+                                self.user_signals[user_id][market].append(instrument)
+                else:
+                    self.logger.warning("Database does not have get_active_signals method - signals won't be loaded")
+                    # Initialize empty user_signals dict
+                    self.user_signals = {}
+            except AttributeError:
+                self.logger.warning("Database missing get_active_signals method - falling back to empty signals")
+                # Initialize empty user_signals dict
+                self.user_signals = {}
+                
+            self.logger.info("Signals loaded")
             
-            if videos_data:
-                return videos_data
-        else:
-            logger.warning(f"No related videos data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related videos: {str(e)}")
-        logger.exception(e)
-        return None
+        except Exception as e:
+            self.logger.error(f"Error loading signals: {str(e)}")
+            self.logger.exception(e)
+            # Initialize empty user_signals dict in case of error
+            self.user_signals = {}
 
-    async def _get_signal_related_trades(self, signal_id):
-    """Retrieve related trades from the database"""
-    try:
-        # Fetch the related trades data from the database
-        trades_data = await self.db.get_related_trades(signal_id)
-            
-        if trades_data:
-            return trades_data
-        else:
-            logger.warning(f"No related trades data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related trades: {str(e)}")
-        logger.exception(e)
-        return None
+    async def back_signals_callback(self, update: Update, context=None) -> int:
+        """Handle back_signals button press"""
+        query = update.callback_query
+        await query.answer()
+        
+        logger.info("back_signals_callback called")
+        
+        # Create keyboard for signal menu
+        keyboard = [
+            [InlineKeyboardButton("üìä Add Signal", callback_data="signals_add")],
+            [InlineKeyboardButton("‚öôÔ∏è Manage Signals", callback_data="signals_manage")],
+            [InlineKeyboardButton("‚¨ÖÔ∏è Back to Menu", callback_data="back_menu")]
+        ]
+        reply_markup = InlineKeyboardMarkup(keyboard)
+        
+        # Update message
+        await self.update_message(
+            query=query,
+            text="<b>üìà Signal Management</b>\n\nManage your trading signals",
+            keyboard=reply_markup
+        )
+        
+        return SIGNALS
 
-    async def _get_signal_related_comments(self, signal_id):
-        """Retrieve related comments from the database"""
-    try:
-        # Fetch the related comments data from the database
-            comments_data = await self.db.get_related_comments(signal_id)
+    async def analysis_callback(self, update: Update, context=None) -> int:
+        """Handle back button from market selection to analysis menu"""
+        query = update.callback_query
+        await query.answer()
+        
+        logger.info("analysis_callback called - returning to analysis menu")
+        
+        # Determine if we have a photo or animation
+        has_photo = False
+        if query and query.message:
+            has_photo = bool(query.message.photo) or query.message.animation is not None
             
-            if comments_data:
-                return comments_data
-        else:
-            logger.warning(f"No related comments data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related comments: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_attachments(self, signal_id):
-        """Retrieve related attachments from the database"""
-    try:
-        # Fetch the related attachments data from the database
-            attachments_data = await self.db.get_related_attachments(signal_id)
+        # Get the analysis GIF URL
+        gif_url = "https://media.giphy.com/media/gSzIKNrqtotEYrZv7i/giphy.gif"
+        
+        # Multi-step approach to handle media messages
+        try:
+            # Step 1: Try to delete the message and send a new one
+            chat_id = update.effective_chat.id
+            message_id = query.message.message_id
             
-            if attachments_data:
-                return attachments_data
-        else:
-            logger.warning(f"No related attachments data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related attachments: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_notes(self, signal_id):
-        """Retrieve related notes from the database"""
-    try:
-        # Fetch the related notes data from the database
-            notes_data = await self.db.get_related_notes(signal_id)
+            try:
+                # Try to delete the current message
+                await context.bot.delete_message(chat_id=chat_id, message_id=message_id)
+                # Send a new message with the analysis menu
+                await context.bot.send_animation(
+                    chat_id=chat_id,
+                    animation=gif_url,
+                    caption="Select your analysis type:",
+                    reply_markup=InlineKeyboardMarkup(ANALYSIS_KEYBOARD),
+                    parse_mode=ParseMode.HTML
+                )
+                logger.info("Successfully deleted message and sent new analysis menu")
+                return CHOOSE_ANALYSIS
+            except Exception as delete_error:
+                logger.warning(f"Could not delete message: {str(delete_error)}")
+                
+                # Step 2: If deletion fails, try replacing with a GIF or transparent GIF
+                try:
+                    if has_photo:
+                        # Replace with the analysis GIF
+                        await query.edit_message_media(
+                            media=InputMediaAnimation(
+                                media=gif_url,
+                                caption="Select your analysis type:"
+                            ),
+                            reply_markup=InlineKeyboardMarkup(ANALYSIS_KEYBOARD)
+                        )
+                    else:
+                        # Just update the text
+                        await query.edit_message_text(
+                            text="Select your analysis type:",
+                            reply_markup=InlineKeyboardMarkup(ANALYSIS_KEYBOARD),
+                            parse_mode=ParseMode.HTML
+                        )
+                    logger.info("Updated message with analysis menu")
+                    return CHOOSE_ANALYSIS
+                except Exception as media_error:
+                    logger.warning(f"Could not update media: {str(media_error)}")
+                    
+                    # Step 3: As last resort, only update the caption
+                    try:
+                        await query.edit_message_caption(
+                            caption="Select your analysis type:",
+                            reply_markup=InlineKeyboardMarkup(ANALYSIS_KEYBOARD),
+                            parse_mode=ParseMode.HTML
+                        )
+                        logger.info("Updated caption with analysis menu")
+                        return CHOOSE_ANALYSIS
+                    except Exception as caption_error:
+                        logger.error(f"Failed to update caption in analysis_callback: {str(caption_error)}")
+                        # Send a new message as absolutely last resort
+                        await context.bot.send_message(
+                            chat_id=chat_id,
+                            text="Select your analysis type:",
+                            parse_mode=ParseMode.HTML,
+                            reply_markup=InlineKeyboardMarkup(ANALYSIS_KEYBOARD)
+                        )
+        except Exception as e:
+            logger.error(f"Error in analysis_callback: {str(e)}")
+            # Send a new message as fallback
+            await context.bot.send_message(
+                chat_id=update.effective_chat.id,
+                text="Select your analysis type:",
+                parse_mode=ParseMode.HTML,
+                reply_markup=InlineKeyboardMarkup(ANALYSIS_KEYBOARD)
+            )
             
-            if notes_data:
-                return notes_data
-        else:
-            logger.warning(f"No related notes data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related notes: {str(e)}")
-        logger.exception(e)
-        return None
+        return CHOOSE_ANALYSIS
 
-    async def _get_signal_related_tags(self, signal_id):
-        """Retrieve related tags from the database"""
-    try:
-        # Fetch the related tags data from the database
-            tags_data = await self.db.get_related_tags(signal_id)
+    async def back_menu_callback(self, update: Update, context=None) -> int:
+        """Handle back_menu button press to return to main menu.
+        
+        This function properly separates the /menu flow from the signal flow
+        by clearing context data to prevent mixing of flows.
+        """
+        query = update.callback_query
+        await query.answer()
+        
+        try:
+            # Reset all context data to ensure clean separation between flows
+            if context and hasattr(context, 'user_data'):
+                # Log the current context for debugging
+                logger.info(f"Clearing user context data: {context.user_data}")
+                
+                # List of keys to remove to ensure separation of flows
+                keys_to_remove = [
+                    'instrument', 'market', 'analysis_type', 'timeframe',
+                    'signal_id', 'from_signal', 'is_signals_context',
+                    'signal_instrument', 'signal_direction', 'signal_timeframe',
+                    'signal_instrument_backup', 'signal_direction_backup', 'signal_timeframe_backup',
+                    'signal_id_backup', 'loading_message'
+                ]
+                
+                # Remove all flow-specific keys
+                for key in keys_to_remove:
+                    if key in context.user_data:
+                        del context.user_data[key]
+                
+                # Explicitly set the signals context flag to False
+                context.user_data['is_signals_context'] = False
+                context.user_data['from_signal'] = False
+                
+                logger.info(f"Set menu flow context: {context.user_data}")
             
-            if tags_data:
-                return tags_data
-        else:
-            logger.warning(f"No related tags data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related tags: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_signals(self, signal_id):
-        """Retrieve related signals from the database"""
-    try:
-        # Fetch the related signals data from the database
-            related_signals_data = await self.db.get_related_signals(signal_id)
+            # GIF URL for the welcome animation
+            gif_url = "https://media.giphy.com/media/gSzIKNrqtotEYrZv7i/giphy.gif"
             
-            if related_signals_data:
-                return related_signals_data
-        else:
-            logger.warning(f"No related signals data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related signals: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_articles(self, signal_id):
-        """Retrieve related articles from the database"""
-    try:
-        # Fetch the related articles data from the database
-            articles_data = await self.db.get_related_articles(signal_id)
+            try:
+                # First approach: delete the current message and send a new one
+                await query.message.delete()
+                await context.bot.send_animation(
+                    chat_id=update.effective_chat.id,
+                    animation=gif_url,
+                    caption=WELCOME_MESSAGE,
+                    parse_mode=ParseMode.HTML,
+                    reply_markup=InlineKeyboardMarkup(START_KEYBOARD)
+                )
+                return MENU
+            except Exception as delete_e:
+                logger.warning(f"Could not delete message: {str(delete_e)}")
+                
+                # Try to replace with a GIF
+                try:
+                    # If message has photo or animation, replace media
+                    if query.message.photo or query.message.animation:
+                        await query.edit_message_media(
+                            media=InputMediaAnimation(
+                                media=gif_url,
+                                caption=WELCOME_MESSAGE
+                            ),
+                            reply_markup=InlineKeyboardMarkup(START_KEYBOARD)
+                        )
+                    else:
+                        # Otherwise just update text
+                        await query.edit_message_text(
+                            text=WELCOME_MESSAGE,
+                            parse_mode=ParseMode.HTML,
+                            reply_markup=InlineKeyboardMarkup(START_KEYBOARD)
+                        )
+                except Exception as e:
+                    logger.warning(f"Could not update message media/text: {str(e)}")
+                    
+                    # Last resort: try to update just the caption
+                    try:
+                        await query.edit_message_caption(
+                            caption=WELCOME_MESSAGE,
+                            parse_mode=ParseMode.HTML,
+                            reply_markup=InlineKeyboardMarkup(START_KEYBOARD)
+                        )
+                    except Exception as caption_e:
+                        logger.error(f"Failed to update caption in back_menu_callback: {str(caption_e)}")
+                        
+                        # Absolute last resort: send a new message
+                        await context.bot.send_message(
+                            chat_id=update.effective_chat.id,
+                            text=WELCOME_MESSAGE,
+                            parse_mode=ParseMode.HTML,
+                            reply_markup=InlineKeyboardMarkup(START_KEYBOARD)
+                        )
             
-            if articles_data:
-                return articles_data
-        else:
-            logger.warning(f"No related articles data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related articles: {str(e)}")
-        logger.exception(e)
-        return None
+            return MENU
+        except Exception as e:
+            logger.error(f"Error in back_menu_callback: {str(e)}")
+            # Try to recover by sending a basic menu as fallback
+            await context.bot.send_message(
+                chat_id=update.effective_chat.id,
+                text=WELCOME_MESSAGE,
+                parse_mode=ParseMode.HTML,
+                reply_markup=InlineKeyboardMarkup(START_KEYBOARD)
+            )
+            return MENU
 
-    async def _get_signal_related_videos(self, signal_id):
-        """Retrieve related videos from the database"""
-    try:
-        # Fetch the related videos data from the database
-            videos_data = await self.db.get_related_videos(signal_id)
+    async def menu_signals_callback(self, update: Update, context=None) -> int:
+        """Handle menu_signals button press to show signals management menu.
+        
+        This function properly sets up the signals flow context to ensure it doesn't
+        mix with the regular menu flow.
+        """
+        query = update.callback_query
+        await query.answer()
+        
+        logger.info("menu_signals_callback called")
+        
+        try:
+            # Set the signals context flag to True and reset other context
+            if context and hasattr(context, 'user_data'):
+                # First clear any previous flow-specific data to prevent mixing
+                context.user_data.clear()
+                
+                # Set flags specifically for signals flow
+                context.user_data['is_signals_context'] = True
+                context.user_data['from_signal'] = False
+                
+                logger.info(f"Set signal flow context: {context.user_data}")
             
-            if videos_data:
-                return videos_data
-        else:
-            logger.warning(f"No related videos data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related videos: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_trades(self, signal_id):
-    """Retrieve related trades from the database"""
-    try:
-        # Fetch the related trades data from the database
-        trades_data = await self.db.get_related_trades(signal_id)
+            # Get the signals GIF URL for better UX
+            signals_gif_url = "https://media.giphy.com/media/gSzIKNrqtotEYrZv7i/giphy.gif"
             
-        if trades_data:
-            return trades_data
-        else:
-            logger.warning(f"No related trades data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related trades: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_comments(self, signal_id):
-        """Retrieve related comments from the database"""
-    try:
-        # Fetch the related comments data from the database
-            comments_data = await self.db.get_related_comments(signal_id)
+            # Create keyboard for signals menu
+            keyboard = [
+                [InlineKeyboardButton("üìä Add Signal", callback_data="signals_add")],
+                [InlineKeyboardButton("‚öôÔ∏è Manage Signals", callback_data="signals_manage")],
+                [InlineKeyboardButton("‚¨ÖÔ∏è Back to Menu", callback_data="back_menu")]
+            ]
+            reply_markup = InlineKeyboardMarkup(keyboard)
             
-            if comments_data:
-                return comments_data
-        else:
-            logger.warning(f"No related comments data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related comments: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_attachments(self, signal_id):
-        """Retrieve related attachments from the database"""
-    try:
-        # Fetch the related attachments data from the database
-            attachments_data = await self.db.get_related_attachments(signal_id)
+            # Try to update with GIF for better visual feedback
+            try:
+                # First try to delete and send new message with GIF
+                await query.message.delete()
+                await context.bot.send_animation(
+                    chat_id=update.effective_chat.id,
+                    animation=signals_gif_url,
+                    caption="<b>üìà Signal Management</b>\n\nManage your trading signals",
+                    parse_mode=ParseMode.HTML,
+                    reply_markup=reply_markup
+                )
+                return SIGNALS
+            except Exception as delete_error:
+                logger.warning(f"Could not delete message: {str(delete_error)}")
+                
+                # If deletion fails, try replacing with a GIF
+                try:
+                    # If message has photo or animation, replace media
+                    if hasattr(query.message, 'photo') and query.message.photo or hasattr(query.message, 'animation') and query.message.animation:
+                        await query.edit_message_media(
+                            media=InputMediaAnimation(
+                                media=signals_gif_url,
+                                caption="<b>üìà Signal Management</b>\n\nManage your trading signals"
+                            ),
+                            reply_markup=reply_markup
+                        )
+                    else:
+                        # Otherwise just update text
+                        await query.edit_message_text(
+                            text="<b>üìà Signal Management</b>\n\nManage your trading signals",
+                            parse_mode=ParseMode.HTML,
+                            reply_markup=reply_markup
+                        )
+                    return SIGNALS
+                except Exception as e:
+                    logger.warning(f"Could not update message media/text: {str(e)}")
+                    
+                    # Last resort: try to update just the caption
+                    try:
+                        await query.edit_message_caption(
+                            caption="<b>üìà Signal Management</b>\n\nManage your trading signals",
+                            parse_mode=ParseMode.HTML,
+                            reply_markup=reply_markup
+                        )
+                    except Exception as caption_e:
+                        logger.error(f"Failed to update caption in menu_signals_callback: {str(caption_e)}")
+                        
+                        # Absolute last resort: send a new message
+                        await context.bot.send_message(
+                            chat_id=update.effective_chat.id,
+                            text="<b>üìà Signal Management</b>\n\nManage your trading signals",
+                            parse_mode=ParseMode.HTML,
+                            reply_markup=reply_markup
+                        )
             
-            if attachments_data:
-                return attachments_data
-        else:
-            logger.warning(f"No related attachments data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related attachments: {str(e)}")
-        logger.exception(e)
-        return None
+            return SIGNALS
+        except Exception as e:
+            logger.error(f"Error in menu_signals_callback: {str(e)}")
+            # Fallback approach on error
+            await context.bot.send_message(
+                chat_id=update.effective_chat.id,
+                text="<b>üìà Signal Management</b>\n\nManage your trading signals",
+                parse_mode=ParseMode.HTML,
+                reply_markup=InlineKeyboardMarkup(SIGNALS_KEYBOARD)
+            )
+            return SIGNALS
 
-    async def _get_signal_related_notes(self, signal_id):
-        """Retrieve related notes from the database"""
-    try:
-        # Fetch the related notes data from the database
-            notes_data = await self.db.get_related_notes(signal_id)
+    async def signals_add_callback(self, update: Update, context=None) -> int:
+        """Handle signals_add button press to add new signal subscriptions"""
+        query = update.callback_query
+        await query.answer()
+        
+        logger.info("signals_add_callback called")
+        
+        # Make sure we're in the signals flow context
+        if context and hasattr(context, 'user_data'):
+            context.user_data['is_signals_context'] = True
+            context.user_data['from_signal'] = False
             
-            if notes_data:
-                return notes_data
-        else:
-            logger.warning(f"No related notes data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related notes: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_tags(self, signal_id):
-        """Retrieve related tags from the database"""
-    try:
-        # Fetch the related tags data from the database
-            tags_data = await self.db.get_related_tags(signal_id)
+            # Set flag for adding signals
+            context.user_data['adding_signals'] = True
             
-            if tags_data:
-                return tags_data
-        else:
-            logger.warning(f"No related tags data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related tags: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_signals(self, signal_id):
-        """Retrieve related signals from the database"""
-    try:
-        # Fetch the related signals data from the database
-            related_signals_data = await self.db.get_related_signals(signal_id)
+            logger.info(f"Set signal flow context: {context.user_data}")
+        
+        # Create keyboard for market selection
+        keyboard = MARKET_KEYBOARD_SIGNALS
+        
+        # Update message with market selection
+        await self.update_message(
+            query=query,
+            text="Select a market for trading signals:",
+            keyboard=InlineKeyboardMarkup(keyboard),
+            parse_mode=ParseMode.HTML
+        )
+        
+        return CHOOSE_MARKET
+        
+    async def signals_manage_callback(self, update: Update, context=None) -> int:
+        """Handle signals_manage callback to manage signal preferences"""
+        query = update.callback_query
+        await query.answer()
+        
+        logger.info("signals_manage_callback called")
+        
+        try:
+            # Get user's current subscriptions
+            user_id = update.effective_user.id
             
-            if related_signals_data:
-                return related_signals_data
-        else:
-            logger.warning(f"No related signals data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related signals: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_articles(self, signal_id):
-        """Retrieve related articles from the database"""
-    try:
-        # Fetch the related articles data from the database
-            articles_data = await self.db.get_related_articles(signal_id)
+            # Fetch user's signal subscriptions from the database
+            try:
+                response = self.db.supabase.table('signal_subscriptions').select('*').eq('user_id', user_id).execute()
+                preferences = response.data if response and hasattr(response, 'data') else []
+            except Exception as db_error:
+                logger.error(f"Database error fetching signal subscriptions: {str(db_error)}")
+                preferences = []
+            
+            if not preferences:
+                # No subscriptions yet
+                text = "You don't have any signal subscriptions yet. Add some first!"
+                keyboard = [
+                    [InlineKeyboardButton("‚ûï Add Signal Pairs", callback_data="signals_add")],
+                    [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="back_signals")]
+                ]
+                
+                await self.update_message(
+                    query=query,
+                    text=text,
+                    keyboard=InlineKeyboardMarkup(keyboard),
+                    parse_mode=ParseMode.HTML
+                )
+                return CHOOSE_SIGNALS
             
-            if articles_data:
-                return articles_data
-        else:
-            logger.warning(f"No related articles data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related articles: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_videos(self, signal_id):
-        """Retrieve related videos from the database"""
-    try:
-        # Fetch the related videos data from the database
-            videos_data = await self.db.get_related_videos(signal_id)
+            # Format current subscriptions
+            message = "<b>Your Signal Subscriptions:</b>\n\n"
             
-            if videos_data:
-                return videos_data
-        else:
-            logger.warning(f"No related videos data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related videos: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_trades(self, signal_id):
-    """Retrieve related trades from the database"""
-    try:
-        # Fetch the related trades data from the database
-        trades_data = await self.db.get_related_trades(signal_id)
+            for i, pref in enumerate(preferences, 1):
+                market = pref.get('market', 'unknown')
+                instrument = pref.get('instrument', 'unknown')
+                timeframe = pref.get('timeframe', 'ALL')
+                
+                message += f"{i}. {market.upper()} - {instrument} ({timeframe})\n"
             
-        if trades_data:
-            return trades_data
-        else:
-            logger.warning(f"No related trades data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related trades: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_comments(self, signal_id):
-        """Retrieve related comments from the database"""
-    try:
-        # Fetch the related comments data from the database
-            comments_data = await self.db.get_related_comments(signal_id)
+            # Add buttons to manage subscriptions
+            keyboard = [
+                [InlineKeyboardButton("‚ûï Add More", callback_data="signals_add")],
+                [InlineKeyboardButton("üóëÔ∏è Remove All", callback_data="delete_all_signals")],
+                [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="back_signals")]
+            ]
             
-            if comments_data:
-                return comments_data
-        else:
-            logger.warning(f"No related comments data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related comments: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_attachments(self, signal_id):
-        """Retrieve related attachments from the database"""
-    try:
-        # Fetch the related attachments data from the database
-            attachments_data = await self.db.get_related_attachments(signal_id)
+            # Add individual delete buttons if there are preferences
+            if preferences:
+                for i, pref in enumerate(preferences):
+                    signal_id = pref.get('id')
+                    if signal_id:
+                        instrument = pref.get('instrument', 'unknown')
+                        keyboard.insert(-1, [InlineKeyboardButton(f"‚ùå Delete {instrument}", callback_data=f"delete_signal_{signal_id}")])
             
-            if attachments_data:
-                return attachments_data
-        else:
-            logger.warning(f"No related attachments data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related attachments: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_notes(self, signal_id):
-        """Retrieve related notes from the database"""
-    try:
-        # Fetch the related notes data from the database
-            notes_data = await self.db.get_related_notes(signal_id)
+            await self.update_message(
+                query=query,
+                text=message,
+                keyboard=InlineKeyboardMarkup(keyboard),
+                parse_mode=ParseMode.HTML
+            )
             
-            if notes_data:
-                return notes_data
-        else:
-            logger.warning(f"No related notes data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related notes: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_tags(self, signal_id):
-        """Retrieve related tags from the database"""
-    try:
-        # Fetch the related tags data from the database
-            tags_data = await self.db.get_related_tags(signal_id)
+            return CHOOSE_SIGNALS
             
-            if tags_data:
-                return tags_data
-        else:
-            logger.warning(f"No related tags data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related tags: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_signals(self, signal_id):
-        """Retrieve related signals from the database"""
-    try:
-        # Fetch the related signals data from the database
-            related_signals_data = await self.db.get_related_signals(signal_id)
+        except Exception as e:
+            logger.error(f"Error in signals_manage_callback: {str(e)}")
             
-            if related_signals_data:
-                return related_signals_data
-        else:
-            logger.warning(f"No related signals data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related signals: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_articles(self, signal_id):
-        """Retrieve related articles from the database"""
-    try:
-        # Fetch the related articles data from the database
-            articles_data = await self.db.get_related_articles(signal_id)
+            # Error recovery - go back to signals menu
+            keyboard = [
+                [InlineKeyboardButton("üìä Add Signal", callback_data="signals_add")],
+                [InlineKeyboardButton("‚öôÔ∏è Manage Signals", callback_data="signals_manage")],
+                [InlineKeyboardButton("‚¨ÖÔ∏è Back to Menu", callback_data="back_menu")]
+            ]
+            reply_markup = InlineKeyboardMarkup(keyboard)
             
-            if articles_data:
-                return articles_data
-        else:
-            logger.warning(f"No related articles data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related articles: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_videos(self, signal_id):
-        """Retrieve related videos from the database"""
-    try:
-        # Fetch the related videos data from the database
-            videos_data = await self.db.get_related_videos(signal_id)
+            await self.update_message(
+                query=query,
+                text="<b>üìà Signal Management</b>\n\nManage your trading signals",
+                keyboard=reply_markup,
+                parse_mode=ParseMode.HTML
+            )
             
-            if videos_data:
-                return videos_data
-        else:
-            logger.warning(f"No related videos data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related videos: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_trades(self, signal_id):
-    """Retrieve related trades from the database"""
-    try:
-        # Fetch the related trades data from the database
-        trades_data = await self.db.get_related_trades(signal_id)
+            return CHOOSE_SIGNALS
+        
+    async def back_instrument_callback(self, update: Update, context=None) -> int:
+        """Handle back button to return to instrument selection"""
+        query = update.callback_query
+        await query.answer()
+        
+        # Add detailed logging
+        logger.info("back_instrument_callback called")
+        logger.info(f"Query data: {query.data}")
+        if context and hasattr(context, 'user_data'):
+            logger.info(f"Context user_data: {context.user_data}")
+        
+        try:
+            # Clear style/timeframe data but keep instrument
+            if context and hasattr(context, 'user_data'):
+                keys_to_clear = ['style', 'timeframe']
+                for key in keys_to_clear:
+                    if key in context.user_data:
+                        del context.user_data[key]
+                logger.info("Cleared style/timeframe data from context")
+            
+            # Get market and analysis type from context
+            market = None
+            analysis_type = None
+            if context and hasattr(context, 'user_data'):
+                market = context.user_data.get('market')
+                analysis_type = context.user_data.get('analysis_type')
+                is_signals_context = context.user_data.get('is_signals_context', False)
+                logger.info(f"Context info: market={market}, analysis_type={analysis_type}, is_signals_context={is_signals_context}")
             
-        if trades_data:
-            return trades_data
-        else:
-            logger.warning(f"No related trades data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related trades: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_comments(self, signal_id):
-        """Retrieve related comments from the database"""
-    try:
-        # Fetch the related comments data from the database
-            comments_data = await self.db.get_related_comments(signal_id)
+            if not market:
+                logger.warning("No market found in context, defaulting to forex")
+                market = "forex"
             
-            if comments_data:
-                return comments_data
-        else:
-            logger.warning(f"No related comments data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related comments: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_attachments(self, signal_id):
-        """Retrieve related attachments from the database"""
-    try:
-        # Fetch the related attachments data from the database
-            attachments_data = await self.db.get_related_attachments(signal_id)
+            # If we're in signals context, go back to signals menu
+            if is_signals_context and hasattr(self, 'back_signals_callback'):
+                logger.info("Going back to signals menu because is_signals_context=True")
+                return await self.back_signals_callback(update, context)
             
-            if attachments_data:
-                return attachments_data
-        else:
-            logger.warning(f"No related attachments data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related attachments: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_notes(self, signal_id):
-        """Retrieve related notes from the database"""
-    try:
-        # Fetch the related notes data from the database
-            notes_data = await self.db.get_related_notes(signal_id)
+            # Otherwise go back to market selection
+            logger.info("Going back to market selection")
+            return await self.back_market_callback(update, context)
             
-            if notes_data:
-                return notes_data
-        else:
-            logger.warning(f"No related notes data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related notes: {str(e)}")
-        logger.exception(e)
-        return None
+        except Exception as e:
+            logger.error(f"Failed to handle back_instrument_callback: {str(e)}")
+            logger.exception(e)
+            # Try to recover by going to market selection
+            if hasattr(self, 'back_market_callback'):
+                return await self.back_market_callback(update, context)
+            else:
+                # Last resort fallback - update message with error
+                await self.update_message(
+                    query, 
+                    "Sorry, an error occurred. Please use /menu to start again.", 
+                    keyboard=None
+                )
+                return ConversationHandler.END
 
-    async def _get_signal_related_tags(self, signal_id):
-        """Retrieve related tags from the database"""
-    try:
-        # Fetch the related tags data from the database
-            tags_data = await self.db.get_related_tags(signal_id)
+    def _convert_html_to_markdown(self, text):
+        """Convert simple HTML tags to Markdown format for Telegram"""
+        if not text:
+            return text
             
-            if tags_data:
-                return tags_data
-        else:
-            logger.warning(f"No related tags data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related tags: {str(e)}")
-        logger.exception(e)
-        return None
+        # Convert bold
+        text = re.sub(r'<b>(.*?)</b>', r'*\1*', text)
+        
+        # Convert italic
+        text = re.sub(r'<i>(.*?)</i>', r'_\1_', text)
+        
+        # Convert underline - Telegram markdown doesn't support underline, so use italic
+        text = re.sub(r'<u>(.*?)</u>', r'_\1_', text)
+        
+        # Convert any other tag by removing it
+        text = re.sub(r'<[^>]*>', '', text)
+        
+        # Escape special markdown characters that are not part of formatting
+        for char in ['[', ']', '(', ')', '~', '`', '>', '#', '+', '-', '=', '|', '{', '}', '.']:
+            text = text.replace(char, f'\\{char}')
+        
+        return text
 
-    async def _get_signal_related_signals(self, signal_id):
-        """Retrieve related signals from the database"""
-    try:
-        # Fetch the related signals data from the database
-            related_signals_data = await self.db.get_related_signals(signal_id)
-            
-            if related_signals_data:
-                return related_signals_data
-        else:
-            logger.warning(f"No related signals data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related signals: {str(e)}")
-        logger.exception(e)
-        return None
+    async def run(self):
+        """Run the telegram bot application"""
+        try:
+            logger.info("Setting up and running the Telegram bot")
+            
+            # Make sure handlers are properly registered
+            if hasattr(self, 'application') and self.application:
+                # Ensure the menu_command handler is correctly registered
+                # Re-register it to be sure
+                self.application.add_handler(CommandHandler("menu", self.menu_command))
+                logger.info("Re-registered /menu command handler")
+                
+                # Initialize application
+                if hasattr(self, 'init_task') and self.init_task:
+                    await self.init_task
+                    logger.info("Application initialized")
+                else:
+                    # Initialize directly if no task exists
+                    await self.application.initialize()
+                    logger.info("Application initialized directly")
+                
+                # Set commands if task exists
+                if hasattr(self, 'set_commands_task') and self.set_commands_task:
+                    await self.set_commands_task
+                    logger.info("Bot commands set")
+                
+                # Initialize services
+                await self.initialize_services()
+                logger.info("Services initialized")
+                
+                # Start the bot
+                await self.application.start()
+                logger.info("Bot started, running until stopped")
+                
+                # If we made it this far, set the bot_started flag
+                self.bot_started = True
+                
+                # Run the bot until it receives a stop signal
+                await self.application.updater.start_polling(drop_pending_updates=True)
+                logger.info("Bot polling started")
+                
+                # Run until stopped - Use proper waiting mechanism instead of idle()
+                # Create a simple infinite loop to keep the application running
+                stop_signal = asyncio.Event()
+                try:
+                    await stop_signal.wait()
+                except asyncio.CancelledError:
+                    pass
+                logger.info("Bot stopped")
+                
+            else:
+                logger.error("Application not properly initialized")
+                raise RuntimeError("Application not properly initialized")
+                
+        except Exception as e:
+            logger.error(f"Error running the bot: {str(e)}")
+            logger.exception(e)
+            raise
 
-    async def _get_signal_related_articles(self, signal_id):
-        """Retrieve related articles from the database"""
+if __name__ == "__main__":
+    # Create parser for command-line arguments
+    import argparse
+    parser = argparse.ArgumentParser(description="Trading Bot")
+    parser.add_argument("--debug", action="store_true", help="Enable debug mode")
+    parser.add_argument("--log-level", type=str, default="INFO", help="Log level (DEBUG, INFO, WARNING, ERROR, CRITICAL)")
+    args = parser.parse_args()
+    
+    # Setup logging based on command line arguments
+    logger = setup_logging(args.log_level)
+    logger.info("Starting trading bot")
+    
+    # Set to sync mode for deployment on Railway
     try:
-        # Fetch the related articles data from the database
-            articles_data = await self.db.get_related_articles(signal_id)
+        # Initialize database connection
+        from trading_bot.services.database.db import Database
+        db = Database()
+        logger.info("Database connection initialized")
+        
+        # Initialize Stripe service if needed
+        stripe_service = None
+        try:
+            from trading_bot.services.payment_service.stripe_service import StripeService
+            # Pass the database to StripeService
+            stripe_service = StripeService(db=db)
+            logger.info("Stripe service initialized")
+        except Exception as e:
+            logger.error(f"Failed to initialize Stripe service: {str(e)}")
             
-            if articles_data:
-                return articles_data
-        else:
-            logger.warning(f"No related articles data found for signal ID {signal_id}")
-            return None
-    except Exception as e:
-        logger.error(f"Error retrieving related articles: {str(e)}")
-        logger.exception(e)
-        return None
-
-    async def _get_signal_related_videos(self, signal_id):
-        """Retrieve related videos from the database"""
-    try:
-        # Fetch the related videos data from the database
-            videos_data = await self.db.get_related_videos(signal_id)
+        # Initialize Telegram service with the database
+        try:
+            telegram_service = TelegramService(db=db, stripe_service=stripe_service)
+            logger.info("Telegram service initialized")
+            
+            # Print bot info
+            if hasattr(telegram_service, 'bot') and telegram_service.bot:
+                bot_info = telegram_service.bot.get_me()
+                logger.info(f"Bot info: {bot_info}")
+        except Exception as e:
+            logger.error(f"Failed to initialize Telegram service: {str(e)}")
+            raise
+        
+        # Run the bot
+        asyncio.run(telegram_service.run())
             
-            if videos_data:
-                return videos_data
-        else:
-            logger.warning(f"No related videos data found for signal ID {signal_id}")
-            return None
     except Exception as e:
-        logger.error(f"Error retrieving related videos: {str(e)}")
-        logger.exception(e)
-        return None
-
+        logger.error(f"Error in main function: {str(e)}")
+        logger.exception(e)
\ No newline at end of file
-- 
2.47.1

